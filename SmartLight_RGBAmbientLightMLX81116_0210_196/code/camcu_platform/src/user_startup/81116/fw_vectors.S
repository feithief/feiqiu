/**
 * @file
 * @brief Interrupt vector table
 * @internal
 *
 * @copyright (C) 2015-2018 Melexis N.V.
 * git flash 137e5489
 *
 * Melexis N.V. is supplying this code for use with Melexis N.V. processor based microcontrollers only.
 *
 * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY,
 * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.  MELEXIS N.V. SHALL NOT IN ANY CIRCUMSTANCES,
 * BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 * @endinternal
 *
 * @ingroup 81116-project
 *
 * @details
 * This file was autogenerated. The information of the source is described below:
 * Tag: DIG81116_IR_2_0_6_20180604_111120
 */

#define JMPVECTOR(addr,lbl)     JVECTOR (addr), _##lbl
#define CALLVECTOR(addr,lbl,pr) CVECTOR (addr), _##lbl, (pr)

    .macro JVECTOR name, lbl
    .org    \name, 0x0
    mov UPR, #0x0
    .word   0x76DA          ; Opcode of JMPF to evade linker relaxation
    .word   \lbl(addr17)    ; addr17 to get word address [16:1] of the label
    .endm

    .macro CVECTOR name, lbl, priority
    .org    \name, 0x0
#ifdef REMAP_FP0_2_FLASH
    psup    #\priority
#else
    mov     UPR, #\priority
#endif
    .word   0x76DA          ; JMPF but used as word to evade relaxation
    .word   \lbl(addr17)
    .endm

;----------------------------------------------------------------------------------------------------------------------------------------
; Interrupt vector table
    .section .fw_vectors,"xa",@progbits
    .global __fw_vectors
    .weak __fw_vectors

;              Vector    ISR                      CPU prio       Allowed    Vector
;              offset    Handler                  within ISR     SW prio    name
;----------------------------------------------------------------------------------------------------------------------------------------
__fw_vectors:
    JMPVECTOR  (0x0000,  fw_start)                              ; [0, 0]    MLX16_RESET Reset
    .org 6
    .word 0xA55A ^ PROJECT_ID                                   ; FW_FLASH_KEY = FLASH_FW_PATTERN ^ PRODUCT_VERSION_16
    JMPVECTOR  (0x0008,  _fatal)                                ; [0, 0]    MLX16_STACKERR Stack error
    JMPVECTOR  (0x0010,  _fatal)                                ; [0, 0]    MLX16_PROTERR Protection error
    JMPVECTOR  (0x0018,  _fatal)                                ; [0, 0]    MLX16_MEMERR Memory error
    JMPVECTOR  (0x0020,  _fatal)                                ; [0, 0]    MLX16_OPERR Operation error
    .org 38
    .word BIST_PAGE_COUNT                                       ; FW_FLASH_BIST_PAGES_COUNT
    JMPVECTOR  (0x0028,  _fatal)                                ; [0, 0]    unused_5
    CALLVECTOR (0x0030,  _MLX16_EXCHG_INT,          0)          ; [1, 1]    MLX16_EXCHG Exchange (PTC and Debugger)
    CALLVECTOR (0x0038,  _MLX16_DMAERR_INT,         0)          ; [1, 1]    MLX16_DMAERR DMA error
    CALLVECTOR (0x0040,  _AWD_ATT_INT,              0)          ; [1, 1]    AWD_ATT Absolute watchdog attention
    CALLVECTOR (0x0048,  _IWD_ATT_INT,              0)          ; [1, 1]    IWD_ATT Intelligent watchdog attention
    CALLVECTOR (0x0050,  _EE_ECC_INT,               0)          ; [1, 1]    EE_ECC
    CALLVECTOR (0x0058,  _FL_ECC_INT,               0)          ; [1, 1]    FL_ECC
    CALLVECTOR (0x0060,  _UV_VDDA_INT,              0)          ; [1, 1]    UV_VDDA
    CALLVECTOR (0x0068,  _UV_VS_INT,                0)          ; [1, 1]    UV_VS
    CALLVECTOR (0x0070,  _OVT_INT,                  1)          ; [2, 2]    OVT
    CALLVECTOR (0x0078,  _STIMER_INT,               2)          ; [3, 6]    STIMER Simple Timer interrupt
    CALLVECTOR (0x0080,  _CTIMER0_1_INT,            2)          ; [3, 6]    CTIMER0_1 Complex Timer interrupt 1
    CALLVECTOR (0x0088,  _CTIMER0_2_INT,            2)          ; [3, 6]    CTIMER0_2 Complex Timer interrupt 2
    CALLVECTOR (0x0090,  _CTIMER0_3_INT,            2)          ; [3, 6]    CTIMER0_3 Complex Timer interrupt 3
    CALLVECTOR (0x0098,  _CTIMER1_1_INT,            2)          ; [3, 6]    CTIMER1_1 Complex Timer interrupt 1
    CALLVECTOR (0x00a0,  _CTIMER1_2_INT,            2)          ; [3, 6]    CTIMER1_2 Complex Timer interrupt 2
    CALLVECTOR (0x00a8,  _CTIMER1_3_INT,            2)          ; [3, 6]    CTIMER1_3 Complex Timer interrupt 3
    CALLVECTOR (0x00b0,  _PWM_MASTER1_CMP_INT,      2)          ; [3, 6]    PWM_MASTER1_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00b8,  _PWM_MASTER1_END_INT,      2)          ; [3, 6]    PWM_MASTER1_END Interrupt at the end of the PWM period
    CALLVECTOR (0x00c0,  _PWM_SLAVE1_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE1_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00c8,  _PWM_SLAVE2_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE2_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00d0,  _PWM_SLAVE3_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE3_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00d8,  _PWM_SLAVE4_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE4_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00e0,  _PWM_SLAVE5_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE5_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00e8,  _PWM_SLAVE6_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE6_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00f0,  _PWM_SLAVE7_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE7_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x00f8,  _PWM_SLAVE8_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE8_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x0100,  _PWM_SLAVE9_CMP_INT,       2)          ; [3, 6]    PWM_SLAVE9_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x0108,  _PWM_SLAVE10_CMP_INT,      2)          ; [3, 6]    PWM_SLAVE10_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x0110,  _PWM_SLAVE11_CMP_INT,      2)          ; [3, 6]    PWM_SLAVE11_CMP Custom interrupt during the PWM period
    CALLVECTOR (0x0118,  _ADC_SAR_INT,              2)          ; [3, 6]    ADC_SAR ADC interrupt
    CALLVECTOR (0x0120,  _EE_COMPLETE_INT,          2)          ; [3, 6]    EE_COMPLETE
    CALLVECTOR (0x0128,  _FL_COMPLETE_INT,          2)          ; [3, 6]    FL_COMPLETE
    CALLVECTOR (0x0130,  _OV_VS_INT,                2)          ; [3, 6]    OV_VS
    CALLVECTOR (0x0138,  _OVT_WARN_INT,             2)          ; [3, 6]    OVT_WARN
    CALLVECTOR (0x0140,  _UV_VDD5_INT,              2)          ; [3, 6]    UV_VDD5
    CALLVECTOR (0x0148,  _AA_IN_INT,                2)          ; [3, 6]    AA_IN on selected edge of AA_IN
    CALLVECTOR (0x0150,  _UART_SB_INT,              2)          ; [3, 6]    UART_SB UART Stop bit error
    CALLVECTOR (0x0158,  _UART_RS_INT,              2)          ; [3, 6]    UART_RS UART Receive error
    CALLVECTOR (0x0160,  _UART_RR_INT,              2)          ; [3, 6]    UART_RR UART Receive
    CALLVECTOR (0x0168,  _UART_TS_INT,              2)          ; [3, 6]    UART_TS UART Transmit end
    CALLVECTOR (0x0170,  _UART_TR_INT,              2)          ; [3, 6]    UART_TR UART Transmit beginning
    CALLVECTOR (0x0178,  _UART_TE_INT,              2)          ; [3, 6]    UART_TE UART Transmit error
    CALLVECTOR (0x0180,  _MFT_INT,                  3)          ; [3, 6]    MFT Melibus frame transmitted
    CALLVECTOR (0x0188,  _MFR_INT,                  3)          ; [3, 6]    MFR Melibus frame received
    CALLVECTOR (0x0190,  _MHR_INT,                  2)          ; [3, 6]    MHR Melibus header received (for transmit only)
    CALLVECTOR (0x0198,  _MER_INT,                  3)          ; [3, 6]    MER Melibus error
    CALLVECTOR (0x01a0,  _TX_TIMEOUT_INT,           2)          ; [3, 6]    TX_TIMEOUT TX dominant time out monitor
    CALLVECTOR (0x01a8,  _MLX16_SOFT_INT,           6)          ; [7, 7]    MLX16_SOFT Software Interrupt request
    .word 0x0000                                                ; explicit filling of vector table section

