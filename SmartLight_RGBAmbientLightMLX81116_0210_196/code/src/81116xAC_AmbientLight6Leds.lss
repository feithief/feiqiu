mlx16-gcc (Melexis Mlx16-GCC v3.0.39) 7.1.0
Copyright (C) 2017 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


81116xAC_AmbientLight6Leds.elf:     file format elf32-mlx16-fx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_vectors   000001b0  00005800  00005800  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005e  00001000  000059b0  00000264  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000047e  0000105e  00005a0e  000002c2  2**1
                  ALLOC
  3 .flash_data   00002eb2  00005a0e  00005a0e  000002c2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .flash_fill   00004f3c  000088c0  000088c0  00003174  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .flash_crc    00000004  0000d7fc  0000d7fc  000080b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .debug_frame  00001c2a  00000000  00000000  000080b4  2**1
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0001be70  00000000  00000000  00009cde  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001a74  00000000  00000000  00025b4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000230  00000000  00000000  000275c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00002d76  00000000  00000000  000277f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00007277  00000000  00000000  0002a568  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000004d  00000000  00000000  000317df  2**0
                  CONTENTS, READONLY
 13 .debug_loc    0000221e  00000000  00000000  0003182c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubnames 00000020  00000000  00000000  00033a4a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubtypes 0000002b  00000000  00000000  00033a6a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .fw_vectors:

00005800 <__fw_vectors>:
    5800:	54f0      	mov	UPr, #0
    5802:	76da 4248 	jmpf	0x8490 <_fw_start>
    5806:	b558      	and	A, dp:0x58 <.Ldebug_line0+0x17>
    5808:	54f0      	mov	UPr, #0
    580a:	76da 1ae0 	jmpf	0x35c0 <__fatal>
    580e:	0000      	nop
    5810:	54f0      	mov	UPr, #0
    5812:	76da 1ae0 	jmpf	0x35c0 <__fatal>
    5816:	0000      	nop
    5818:	54f0      	mov	UPr, #0
    581a:	76da 1ae0 	jmpf	0x35c0 <__fatal>
    581e:	0000      	nop
    5820:	54f0      	mov	UPr, #0
    5822:	76da 1ae0 	jmpf	0x35c0 <__fatal>
    5826:	0100      	jmp	0x5a28 <.LASF700>
    5828:	54f0      	mov	UPr, #0
    582a:	76da 1ae0 	jmpf	0x35c0 <__fatal>
    582e:	0000      	nop
    5830:	54f0      	mov	UPr, #0
    5832:	76da 429c 	jmpf	0x8538 <__MLX16_EXCHG_INT>
    5836:	0000      	nop
    5838:	54f0      	mov	UPr, #0
    583a:	76da 42a8 	jmpf	0x8550 <__MLX16_DMAERR_INT>
    583e:	0000      	nop
    5840:	54f0      	mov	UPr, #0
    5842:	76da 42b3 	jmpf	0x8566 <__AWD_ATT_INT>
    5846:	0000      	nop
    5848:	54f0      	mov	UPr, #0
    584a:	76da 42be 	jmpf	0x857c <__IWD_ATT_INT>
    584e:	0000      	nop
    5850:	54f0      	mov	UPr, #0
    5852:	76da 42c9 	jmpf	0x8592 <__EE_ECC_INT>
    5856:	0000      	nop
    5858:	54f0      	mov	UPr, #0
    585a:	76da 42d4 	jmpf	0x85a8 <__FL_ECC_INT>
    585e:	0000      	nop
    5860:	54f0      	mov	UPr, #0
    5862:	76da 42df 	jmpf	0x85be <__UV_VDDA_INT>
    5866:	0000      	nop
    5868:	54f0      	mov	UPr, #0
    586a:	76da 42ea 	jmpf	0x85d4 <__UV_VS_INT>
    586e:	0000      	nop
    5870:	54f1      	mov	UPr, #1
    5872:	76da 42f5 	jmpf	0x85ea <__OVT_INT>
    5876:	0000      	nop
    5878:	54f2      	mov	UPr, #2
    587a:	76da 4300 	jmpf	0x8600 <__STIMER_INT>
    587e:	0000      	nop
    5880:	54f2      	mov	UPr, #2
    5882:	76da 430b 	jmpf	0x8616 <__CTIMER0_1_INT>
    5886:	0000      	nop
    5888:	54f2      	mov	UPr, #2
    588a:	76da 4316 	jmpf	0x862c <__CTIMER0_2_INT>
    588e:	0000      	nop
    5890:	54f2      	mov	UPr, #2
    5892:	76da 4321 	jmpf	0x8642 <__CTIMER0_3_INT>
    5896:	0000      	nop
    5898:	54f2      	mov	UPr, #2
    589a:	76da 432c 	jmpf	0x8658 <__CTIMER1_1_INT>
    589e:	0000      	nop
    58a0:	54f2      	mov	UPr, #2
    58a2:	76da 4337 	jmpf	0x866e <__CTIMER1_2_INT>
    58a6:	0000      	nop
    58a8:	54f2      	mov	UPr, #2
    58aa:	76da 4342 	jmpf	0x8684 <__CTIMER1_3_INT>
    58ae:	0000      	nop
    58b0:	54f2      	mov	UPr, #2
    58b2:	76da 3aec 	jmpf	0x75d8 <__PWM_MASTER1_CMP_INT>
    58b6:	0000      	nop
    58b8:	54f2      	mov	UPr, #2
    58ba:	76da 434d 	jmpf	0x869a <__PWM_MASTER1_END_INT>
    58be:	0000      	nop
    58c0:	54f2      	mov	UPr, #2
    58c2:	76da 4358 	jmpf	0x86b0 <__PWM_SLAVE1_CMP_INT>
    58c6:	0000      	nop
    58c8:	54f2      	mov	UPr, #2
    58ca:	76da 4363 	jmpf	0x86c6 <__PWM_SLAVE2_CMP_INT>
    58ce:	0000      	nop
    58d0:	54f2      	mov	UPr, #2
    58d2:	76da 436e 	jmpf	0x86dc <__PWM_SLAVE3_CMP_INT>
    58d6:	0000      	nop
    58d8:	54f2      	mov	UPr, #2
    58da:	76da 4379 	jmpf	0x86f2 <__PWM_SLAVE4_CMP_INT>
    58de:	0000      	nop
    58e0:	54f2      	mov	UPr, #2
    58e2:	76da 4384 	jmpf	0x8708 <__PWM_SLAVE5_CMP_INT>
    58e6:	0000      	nop
    58e8:	54f2      	mov	UPr, #2
    58ea:	76da 438f 	jmpf	0x871e <__PWM_SLAVE6_CMP_INT>
    58ee:	0000      	nop
    58f0:	54f2      	mov	UPr, #2
    58f2:	76da 439a 	jmpf	0x8734 <__PWM_SLAVE7_CMP_INT>
    58f6:	0000      	nop
    58f8:	54f2      	mov	UPr, #2
    58fa:	76da 43a5 	jmpf	0x874a <__PWM_SLAVE8_CMP_INT>
    58fe:	0000      	nop
    5900:	54f2      	mov	UPr, #2
    5902:	76da 43b0 	jmpf	0x8760 <__PWM_SLAVE9_CMP_INT>
    5906:	0000      	nop
    5908:	54f2      	mov	UPr, #2
    590a:	76da 43bb 	jmpf	0x8776 <__PWM_SLAVE10_CMP_INT>
    590e:	0000      	nop
    5910:	54f2      	mov	UPr, #2
    5912:	76da 43c6 	jmpf	0x878c <__PWM_SLAVE11_CMP_INT>
    5916:	0000      	nop
    5918:	54f2      	mov	UPr, #2
    591a:	76da 3569 	jmpf	0x6ad2 <__ADC_SAR_INT>
    591e:	0000      	nop
    5920:	54f2      	mov	UPr, #2
    5922:	76da 43d1 	jmpf	0x87a2 <__EE_COMPLETE_INT>
    5926:	0000      	nop
    5928:	54f2      	mov	UPr, #2
    592a:	76da 43dc 	jmpf	0x87b8 <__FL_COMPLETE_INT>
    592e:	0000      	nop
    5930:	54f2      	mov	UPr, #2
    5932:	76da 43e7 	jmpf	0x87ce <__OV_VS_INT>
    5936:	0000      	nop
    5938:	54f2      	mov	UPr, #2
    593a:	76da 43f2 	jmpf	0x87e4 <__OVT_WARN_INT>
    593e:	0000      	nop
    5940:	54f2      	mov	UPr, #2
    5942:	76da 43fd 	jmpf	0x87fa <__UV_VDD5_INT>
    5946:	0000      	nop
    5948:	54f2      	mov	UPr, #2
    594a:	76da 4408 	jmpf	0x8810 <__AA_IN_INT>
    594e:	0000      	nop
    5950:	54f2      	mov	UPr, #2
    5952:	76da 4413 	jmpf	0x8826 <__UART_SB_INT>
    5956:	0000      	nop
    5958:	54f2      	mov	UPr, #2
    595a:	76da 441e 	jmpf	0x883c <__UART_RS_INT>
    595e:	0000      	nop
    5960:	54f2      	mov	UPr, #2
    5962:	76da 4429 	jmpf	0x8852 <__UART_RR_INT>
    5966:	0000      	nop
    5968:	54f2      	mov	UPr, #2
    596a:	76da 4434 	jmpf	0x8868 <__UART_TS_INT>
    596e:	0000      	nop
    5970:	54f2      	mov	UPr, #2
    5972:	76da 443f 	jmpf	0x887e <__UART_TR_INT>
    5976:	0000      	nop
    5978:	54f2      	mov	UPr, #2
    597a:	76da 444a 	jmpf	0x8894 <__UART_TE_INT>
    597e:	0000      	nop
    5980:	54f3      	mov	UPr, #3
    5982:	76da 372f 	jmpf	0x6e5e <__MFT_INT>
    5986:	0000      	nop
    5988:	54f3      	mov	UPr, #3
    598a:	76da 375b 	jmpf	0x6eb6 <__MFR_INT>
    598e:	0000      	nop
    5990:	54f2      	mov	UPr, #2
    5992:	76da 3762 	jmpf	0x6ec4 <__MHR_INT>
    5996:	0000      	nop
    5998:	54f3      	mov	UPr, #3
    599a:	76da 3769 	jmpf	0x6ed2 <__MER_INT>
    599e:	0000      	nop
    59a0:	54f2      	mov	UPr, #2
    59a2:	76da 3773 	jmpf	0x6ee6 <__TX_TIMEOUT_INT>
    59a6:	0000      	nop
    59a8:	54f6      	mov	UPr, #6
    59aa:	76da 4455 	jmpf	0x88aa <__MLX16_SOFT_INT>
    59ae:	0000      	nop

Disassembly of section .flash_data:

00005a0e <.LC0>:
    5a0e:	0bc5      	setb	io:0x18.5

00005a10 <.LC0>:
    5a10:	a55a      	or	A, dp:0x5a <.Ldebug_line0+0x19>
    5a12:	0001      	jmp	0x5a16 <.LC0+0x6>
    5a14:	0000      	nop
    5a16:	0000      	nop

00005a18 <_TtoCIE>:
    5a18:	ffd8 026e 01e7 01c6 fffe 000a fffd fffc     ..n.............
    5a28:	0001 fffc ffec 031d 02ae 0296 fffe 0007     ................
    5a38:	fffc ffd4 0000 fffb fff6 0371 0314 0301     ..........q.....
    5a48:	fffe 0005 fffd ffcd 0000 fffc 0000 03b0     ................
    5a58:	036e 0362 0004 0005 fffd ffd7 0000 fffc     n.b.............
    5a68:	0019 03e8 03e8 03e8 0000 0000 0000 0000     ................
    5a78:	0000 0000 0032 03c1 0411 03e1 0001 fffd     ....2...........
    5a88:	0002 001a 0000 0000 0055 032c 03d4 037c     ........U.,...|.
    5a98:	0009 fffd 0006 0048 ffff 0004 0078 0156     ......H.....x.V.
    5aa8:	035d 0427 0051 ffaf 014f ff65 ffcc 0048     ].'.Q...O.e...H.

00005ab8 <_LEDADCINDEX>:
    5ab8:	0000 0009 0001 000a 0002 000b 0003 000c     ................
    5ac8:	0004 000d 0005 000e 0006 000f 0007 0010     ................
    5ad8:	0008 0011 0012 0013                         ........

00005ae0 <_ADCCHANNELLIST>:
    5ae0:	45ac 4f44 85ac 4f44 49ac 4f44 89ac 4f44     .EDO..DO.IDO..DO
    5af0:	4dac 4f44 8dac 4f44 d1ac 4f44 11ac 4f45     .MDO..DO..DO..EO
    5b00:	d5ac 4f44 15ac 4f45 d9ac 4f44 19ac 4f45     ..DO..EO..DO..EO
    5b10:	5dac 4f45 9dac 4f45 61ac 4f45 a1ac 4f45     .]EO..EO.aEO..EO
    5b20:	65ac 4f45 a5ac 4f45 0180 0004 0184 0004     .eEO..EO........

00005b30 <_MelInterruptConfigurationDefault>:
    5b30:	631f                                        .c

00005b32 <_MelConfigurationDefault>:
    5b32:	0001 000a 1206 11de 12f2 0000               ............

00005b3e <_LEDCHANNELMAP>:
    5b3e:	0001 0000 0002 000a 0009 000b 0004 0003     ................
    5b4e:	0005 000d 000c 000e 0007 0006 0008 0010     ................
    5b5e:	000f 0011                                   ....

00005b62 <.L48>:
    5b62:	3f75      	xor	X, ep:0x75 <.LASF3+0x6>
    5b64:	3fef      	xor	X, ep:0xef <.LASF101+0x30>
    5b66:	3ff3      	xor	X, ep:0xf3 <.LASF101+0x34>
    5b68:	4159      	mov	dp:0x59 <.Ldebug_line0+0x18>, AL
    5b6a:	41f2      	mov	dp:0xf2 <.LASF101+0x33>, AL

00005b6c <_crc_ccitt>:
    5b6c:	5801      	inc	S, #2

00005b6e <.LCFI0>:
    5b6e:	7e05      	lod	X, [S-6]

00005b70 <.LM2>:
    5b70:	7aee      	lod	Y, X
    5b72:	6400      	lod	YL, #0
    5b74:	7ae8      	swap	Y
    5b76:	36da 00ff 	and	X, #255
    5b7a:	7eec      	swap	X
    5b7c:	e6ee      	or	Y, X

00005b7e <.LM3>:
    5b7e:	fee2      	xor	Y, A

00005b80 <.LM4>:
    5b80:	72e6      	lod	A, Y

00005b82 <.LVL4>:
    5b82:	44b2      	lsr	A, #2
    5b84:	44b2      	lsr	A, #2
    5b86:	7ee2      	lod	X, A
    5b88:	340f      	and	X, #15
    5b8a:	3ee6      	xor	X, Y

00005b8c <.LM5>:
    5b8c:	72ee      	lod	A, X
    5b8e:	b40f      	and	A, #15
    5b90:	44d2      	rr	A, #2
    5b92:	44d2      	rr	A, #2
    5b94:	3ee2      	xor	X, A

00005b96 <.LVL6>:
    5b96:	5e01      	mov	[S-2], X

00005b98 <.LM6>:
    5b98:	6201      	lod	AL, [S-2]
    5b9a:	5cf2      	usex	A
    5b9c:	44a2      	asl	A, #2
    5b9e:	44a2      	asl	A, #2
    5ba0:	4422      	asl	A

00005ba2 <.LVL8>:
    5ba2:	beee      	xor	A, X

00005ba4 <.LM7>:
    5ba4:	5403      	ret	#4

00005ba6 <___mulsi3>:
    5ba6:	5edf      	push	X
    5ba8:	7eef      	lod	X, S
    5baa:	2808      	sub	X, #8
    5bac:	1002      	call	0x5bb2 <___mulsi3_1>
    5bae:	7ecf      	pop	X
    5bb0:	5401      	ret

00005bb2 <___mulsi3_1>:
    5bb2:	4c83      	push	D
    5bb4:	4cf3      	swap	YA
    5bb6:	4806      	mulu	D, A, [X++]
    5bb8:	4cf3      	swap	YA
    5bba:	4847      	macu	D, A, [X]
    5bbc:	2802      	sub	X, #2
    5bbe:	48cf      	asl	D, #16
    5bc0:	4847      	macu	D, A, [X]
    5bc2:	4c80      	mov	YA, D
    5bc4:	4cc3      	pop	D
    5bc6:	5401      	ret

00005bc8 <___mulsi3_D>:
    5bc8:	5edf      	push	X
    5bca:	7eef      	lod	X, S
    5bcc:	2002      	add	X, #2
    5bce:	17f1      	call	0x5bb2 <___mulsi3_1>
    5bd0:	7ecf      	pop	X
    5bd2:	5401      	ret

00005bd4 <___mlx_umuldi3>:
    5bd4:	5edf      	push	X
    5bd6:	7a13      	lod	Y, [S-20]
    5bd8:	720b      	lod	A, [S-12]
    5bda:	4821      	mulu	YA, A, Y
    5bdc:	52df      	push	A
    5bde:	4cc9      	movu	D, Y
    5be0:	7a15      	lod	Y, [S-22]
    5be2:	720b      	lod	A, [S-12]
    5be4:	4821      	mulu	YA, A, Y
    5be6:	7ee6      	lod	X, Y
    5be8:	4c08      	addu	D, A
    5bea:	7a13      	lod	Y, [S-20]
    5bec:	720d      	lod	A, [S-14]
    5bee:	4841      	macu	D, A, Y
    5bf0:	4c80      	mov	YA, D
    5bf2:	52df      	push	A
    5bf4:	4cc9      	movu	D, Y
    5bf6:	4c0b      	addu	D, X
    5bf8:	7a0b      	lod	Y, [S-12]
    5bfa:	7217      	lod	A, [S-24]
    5bfc:	4821      	mulu	YA, A, Y
    5bfe:	4c08      	addu	D, A
    5c00:	7ee6      	lod	X, Y
    5c02:	7a15      	lod	Y, [S-22]
    5c04:	720d      	lod	A, [S-14]
    5c06:	4821      	mulu	YA, A, Y
    5c08:	22e6      	add	X, Y
    5c0a:	4c08      	addu	D, A
    5c0c:	7a13      	lod	Y, [S-20]
    5c0e:	720f      	lod	A, [S-16]
    5c10:	4841      	macu	D, A, Y
    5c12:	4c80      	mov	YA, D
    5c14:	52df      	push	A
    5c16:	4cc9      	movu	D, Y
    5c18:	4c0b      	addu	D, X
    5c1a:	7a19      	lod	Y, [S-26]
    5c1c:	720b      	lod	A, [S-12]
    5c1e:	4841      	macu	D, A, Y
    5c20:	7a17      	lod	Y, [S-24]
    5c22:	720d      	lod	A, [S-14]
    5c24:	4841      	macu	D, A, Y
    5c26:	7a15      	lod	Y, [S-22]
    5c28:	720f      	lod	A, [S-16]
    5c2a:	4841      	macu	D, A, Y
    5c2c:	7a13      	lod	Y, [S-20]
    5c2e:	7211      	lod	A, [S-18]
    5c30:	4841      	macu	D, A, Y
    5c32:	4c80      	mov	YA, D
    5c34:	7e07      	lod	X, [S-8]
    5c36:	7aef      	lod	Y, S
    5c38:	e806      	sub	Y, #6
    5c3a:	54c6      	movsw	[X++], [Y++]
    5c3c:	54c6      	movsw	[X++], [Y++]
    5c3e:	54c6      	movsw	[X++], [Y++]
    5c40:	52f8      	mov	[X], A
    5c42:	5409      	ret	#10

00005c44 <___mlx_lshrdi3>:
    5c44:	5edf      	push	X
    5c46:	7e0d      	lod	X, [S-14]
    5c48:	1908      	je	0x5c5a <return_data>

00005c4a <shift_loop>:
    5c4a:	58e4      	mov	YA, [S-12]
    5c4c:	48a0      	lsr	YA, #1
    5c4e:	58c2      	mov	D, [S-8]
    5c50:	4880      	lsr	D, #1
    5c52:	0c9f      	mov	YH.7, C
    5c54:	58a4      	mov	[S-12], YA
    5c56:	5882      	mov	[S-8], D
    5c58:	1bf8      	djnz	X, 0x5c4a <shift_loop>

00005c5a <return_data>:
    5c5a:	7ecf      	pop	X
    5c5c:	58c3      	mov	D, [S-10]
    5c5e:	4c86      	mov	[X++], D
    5c60:	58c1      	mov	D, [S-6]
    5c62:	4c87      	mov	[X], D
    5c64:	5401      	ret

00005c66 <___divsi3>:
    5c66:	7c00      	lod	X, #0
    5c68:	4cc0      	mov	D, YA
    5c6a:	1d82      	jnn	0x5c70 <a_positive>
    5c6c:	4cd0      	neg	D
    5c6e:	7c01      	lod	X, #1

00005c70 <a_positive>:
    5c70:	7205      	lod	A, [S-6]
    5c72:	7a03      	lod	Y, [S-4]
    5c74:	1d82      	jnn	0x5c7a <b_positive>
    5c76:	4cf0      	neg	YA
    5c78:	3c01      	xor	X, #1

00005c7a <b_positive>:
    5c7a:	5edf      	push	X
    5c7c:	7c00      	lod	X, #0
    5c7e:	4ca3      	push	YA
    5c80:	4c80      	mov	YA, D
    5c82:	102a      	call	0x5cd8 <___udivmodsi4>
    5c84:	5c03      	dec	S, #4
    5c86:	7ecf      	pop	X
    5c88:	1901      	je	0x5c8c <done>
    5c8a:	4cf0      	neg	YA

00005c8c <done>:
    5c8c:	5401      	ret

00005c8e <___modsi3>:
    5c8e:	7c00      	lod	X, #0
    5c90:	4cc0      	mov	D, YA
    5c92:	1d82      	jnn	0x5c98 <ma_positive>
    5c94:	4cd0      	neg	D
    5c96:	7c01      	lod	X, #1

00005c98 <ma_positive>:
    5c98:	7205      	lod	A, [S-6]
    5c9a:	7a03      	lod	Y, [S-4]
    5c9c:	1d81      	jnn	0x5ca0 <mb_positive>
    5c9e:	4cf0      	neg	YA

00005ca0 <mb_positive>:
    5ca0:	5edf      	push	X
    5ca2:	7c01      	lod	X, #1
    5ca4:	4ca3      	push	YA
    5ca6:	4c80      	mov	YA, D
    5ca8:	1017      	call	0x5cd8 <___udivmodsi4>
    5caa:	5c03      	dec	S, #4
    5cac:	7ecf      	pop	X
    5cae:	1901      	je	0x5cb2 <mdone>
    5cb0:	4cf0      	neg	YA

00005cb2 <mdone>:
    5cb2:	5401      	ret

00005cb4 <__divU32_U32byU16>:
    5cb4:	5edf      	push	X
    5cb6:	4ca3      	push	YA
    5cb8:	72e6      	lod	A, Y
    5cba:	7800      	lod	Y, #0
    5cbc:	7e09      	lod	X, [S-10]
    5cbe:	4c63      	divu	YA, X
    5cc0:	4c63      	divu	YA, X
    5cc2:	5201      	mov	[S-2], A
    5cc4:	7203      	lod	A, [S-4]
    5cc6:	4c63      	divu	YA, X
    5cc8:	4c63      	divu	YA, X
    5cca:	7a01      	lod	Y, [S-2]
    5ccc:	7e05      	lod	X, [S-6]
    5cce:	5407      	ret	#8

00005cd0 <___udivsi3>:
    5cd0:	7c00      	lod	X, #0
    5cd2:	0002      	jmp	0x5cd8 <___udivmodsi4>

00005cd4 <___umodsi3>:
    5cd4:	7c01      	lod	X, #1
    5cd6:	0000      	nop

00005cd8 <___udivmodsi4>:
    5cd8:	5edf      	push	X
    5cda:	2c00      	cmp	X, #0
    5cdc:	1d06      	jne	0x5cea <chk1_skipped>
    5cde:	7e05      	lod	X, [S-6]
    5ce0:	1d05      	jne	0x5cec <chk1_passed>
    5ce2:	7e07      	lod	X, [S-8]
    5ce4:	5e01      	mov	[S-2], X
    5ce6:	17e6      	call	0x5cb4 <__divU32_U32byU16>
    5ce8:	5403      	ret	#4

00005cea <chk1_skipped>:
    5cea:	7e05      	lod	X, [S-6]

00005cec <chk1_passed>:
    5cec:	2607      	or	X, [S-8]
    5cee:	1d03      	jne	0x5cf6 <chk2_passed>
    5cf0:	4cfa ffff 	movs	YA, #65535
    5cf4:	5403      	ret	#4

00005cf6 <chk2_passed>:
    5cf6:	4cc0      	mov	D, YA
    5cf8:	7eef      	lod	X, S
    5cfa:	2808      	sub	X, #8
    5cfc:	4cea 0000 	movu	YA, #0
    5d00:	54e0      	mov	Cx, #0

00005d02 <Loop>:
    5d02:	48c0      	asl	D, #1
    5d04:	4402      	rlc	A
    5d06:	4406      	rlc	Y
    5d08:	1802      	jc	0x5d0e <L1_1>
    5d0a:	4cb7      	cmp	YA, [X]
    5d0c:	1803      	jc	0x5d14 <L1_2>

00005d0e <L1_1>:
    5d0e:	4c37      	sub	YA, [X]
    5d10:	4c0a 0001 	addu	D, #1

00005d14 <L1_2>:
    5d14:	48c0      	asl	D, #1
    5d16:	4402      	rlc	A
    5d18:	4406      	rlc	Y
    5d1a:	1802      	jc	0x5d20 <L2_1>
    5d1c:	4cb7      	cmp	YA, [X]
    5d1e:	1803      	jc	0x5d26 <L2_2>

00005d20 <L2_1>:
    5d20:	4c37      	sub	YA, [X]
    5d22:	4c0a 0001 	addu	D, #1

00005d26 <L2_2>:
    5d26:	1fed      	djnz	Cx, 0x5d02 <Loop>

00005d28 <done>:
    5d28:	7ecf      	pop	X
    5d2a:	1d01      	jne	0x5d2e <exit>
    5d2c:	4c80      	mov	YA, D

00005d2e <exit>:
    5d2e:	5401      	ret
    5d30:	5edf      	push	X
    5d32:	4ca3      	push	YA
    5d34:	72e6      	lod	A, Y
    5d36:	7800      	lod	Y, #0
    5d38:	7e09      	lod	X, [S-10]
    5d3a:	4c63      	divu	YA, X
    5d3c:	4c63      	divu	YA, X
    5d3e:	5201      	mov	[S-2], A
    5d40:	7203      	lod	A, [S-4]
    5d42:	4c63      	divu	YA, X
    5d44:	4c63      	divu	YA, X
    5d46:	7a01      	lod	Y, [S-2]
    5d48:	7e05      	lod	X, [S-6]
    5d4a:	5407      	ret	#8

00005d4c <_main>:
 * background routines will be handled in endless loop.
 * @return 0
 */
int main(void)
{
  system_Init();
    5d4c:	82db 3ccb 	callf	0x7996 <_system_Init>

00005d50 <.L2>:

  while (1)
  {
    system_Main_Loop();
    5d50:	82db 3d3f 	callf	0x7a7e <_system_Main_Loop>
    5d54:	07fd      	jmp	0x5d50 <.L2>

00005d56 <_algoUpdateRedCIE>:
*@param[in] Y  red Luminous in CIE color. This value has been multiplied by 10000.
*
*@retval    None.
*/
void algoUpdateRedCIE(uint16_t ledIndex, int16_t x, int16_t y, int32_t Y)
{
    5d56:	5801      	inc	S, #2

00005d58 <.LCFI0>:
  redxyY[ledIndex].x = x;
    5d58:	44a2      	asl	A, #2
    5d5a:	4422      	asl	A

00005d5c <.LVL1>:
    5d5c:	a2da 1196 	add	A, #4502
    5d60:	7ae2      	lod	Y, A
    5d62:	7e05      	lod	X, [S-6]
    5d64:	5ed6      	mov	[Y++], X

00005d66 <.LM3>:
  redxyY[ledIndex].y = y;
    5d66:	7e07      	lod	X, [S-8]
    5d68:	5ef0      	mov	[Y], X

00005d6a <.LM4>:
  redxyY[ledIndex].Y = Y/6;
    5d6a:	7ae2      	lod	Y, A
    5d6c:	e004      	add	Y, #4
    5d6e:	5a01      	mov	[S-2], Y
    5d70:	54ca 0006 	pushw	#6
    5d74:	54ca 0000 	pushw	#0

00005d78 <.LCFI1>:
    5d78:	58e6      	mov	YA, [S-16]
    5d7a:	1775      	call	0x5c66 <___divsi3>
    5d7c:	5c03      	dec	S, #4

00005d7e <.LCFI2>:
    5d7e:	7e01      	lod	X, [S-2]
    5d80:	4ca7      	mov	[X], YA

00005d82 <.LM5>:
}
    5d82:	5403      	ret	#4

00005d84 <_algoUpdateGreenCIE>:
*@param[in] Y  green Luminous in CIE color. This value has been multiplied by 10000.
*
*@retval    None.
*/
void algoUpdateGreenCIE(uint16_t ledIndex, int16_t x, int16_t y, int32_t Y)
{
    5d84:	5801      	inc	S, #2

00005d86 <.LCFI3>:
  greenxyY[ledIndex].x = x;
    5d86:	44a2      	asl	A, #2
    5d88:	4422      	asl	A

00005d8a <.LVL4>:
    5d8a:	a2da 1166 	add	A, #4454
    5d8e:	7ae2      	lod	Y, A
    5d90:	7e05      	lod	X, [S-6]
    5d92:	5ed6      	mov	[Y++], X

00005d94 <.LM8>:
  greenxyY[ledIndex].y = y;
    5d94:	7e07      	lod	X, [S-8]
    5d96:	5ef0      	mov	[Y], X

00005d98 <.LM9>:
  greenxyY[ledIndex].Y = Y/6;
    5d98:	7ae2      	lod	Y, A
    5d9a:	e004      	add	Y, #4
    5d9c:	5a01      	mov	[S-2], Y
    5d9e:	54ca 0006 	pushw	#6
    5da2:	54ca 0000 	pushw	#0

00005da6 <.LCFI4>:
    5da6:	58e6      	mov	YA, [S-16]
    5da8:	175e      	call	0x5c66 <___divsi3>
    5daa:	5c03      	dec	S, #4

00005dac <.LCFI5>:
    5dac:	7e01      	lod	X, [S-2]
    5dae:	4ca7      	mov	[X], YA

00005db0 <.LM10>:
}
    5db0:	5403      	ret	#4

00005db2 <_algoUpdateBlueCIE>:
*@param[in] Y  blue Luminous in CIE color. This value has been multiplied by 10000.
*
*@retval    None.
*/
void algoUpdateBlueCIE(uint16_t ledIndex, int16_t x, int16_t y, int32_t Y)
{
    5db2:	5801      	inc	S, #2

00005db4 <.LCFI6>:
  bluexyY[ledIndex].x = x;
    5db4:	44a2      	asl	A, #2
    5db6:	4422      	asl	A

00005db8 <.LVL7>:
    5db8:	a2da 1136 	add	A, #4406
    5dbc:	7ae2      	lod	Y, A
    5dbe:	7e05      	lod	X, [S-6]
    5dc0:	5ed6      	mov	[Y++], X

00005dc2 <.LM13>:
  bluexyY[ledIndex].y = y;
    5dc2:	7e07      	lod	X, [S-8]
    5dc4:	5ef0      	mov	[Y], X

00005dc6 <.LM14>:
  bluexyY[ledIndex].Y = Y/6;
    5dc6:	7ae2      	lod	Y, A
    5dc8:	e004      	add	Y, #4
    5dca:	5a01      	mov	[S-2], Y
    5dcc:	54ca 0006 	pushw	#6
    5dd0:	54ca 0000 	pushw	#0

00005dd4 <.LCFI7>:
    5dd4:	58e6      	mov	YA, [S-16]
    5dd6:	1747      	call	0x5c66 <___divsi3>
    5dd8:	5c03      	dec	S, #4

00005dda <.LCFI8>:
    5dda:	7e01      	lod	X, [S-2]
    5ddc:	4ca7      	mov	[X], YA

00005dde <.LM15>:
}
    5dde:	5403      	ret	#4

00005de0 <_algoGetPWMOutput>:
*@param[out] outputPWM  PWM duty cycle generated by this module.
*
*@retval    always true.
*/
bool_t algoGetPWMOutput(SColorParams * const inputColor, SPWMParams *outputPWM)
{
    5de0:	584f      	inc	S, #80

00005de2 <.LCFI9>:
    5de2:	7e53      	lod	X, [S-84]
    5de4:	6400      	lod	YL, #0
    5de6:	54ec      	mov	Cx, #12
    5de8:	46de      	mov	[X++], YL
    5dea:	1ffe      	djnz	Cx, 0x5de8 <.LASF53+0x5>
    5dec:	7e53      	lod	X, [S-84]
    5dee:	200c      	add	X, #12
    5df0:	54ec      	mov	Cx, #12
    5df2:	46de      	mov	[X++], YL
    5df4:	1ffe      	djnz	Cx, 0x5df2 <.LASF780+0x6>
    5df6:	7e53      	lod	X, [S-84]
    5df8:	2018      	add	X, #24
    5dfa:	54ec      	mov	Cx, #12
    5dfc:	46de      	mov	[X++], YL
    5dfe:	1ffe      	djnz	Cx, 0x5dfc <.LASF780+0x10>
    5e00:	7ae2      	lod	Y, A
    5e02:	e018      	add	Y, #24
    5e04:	5a35      	mov	[S-54], Y

00005e06 <.LM17>:
  for (index = 0; index < RGBLEDMAX; index++)
  {
    /*Turn off lights by default.*/
    outputPWM->PWM_R[index] = 0;
    outputPWM->PWM_G[index] = 0;
    outputPWM->PWM_B[index] = 0;
    5e06:	7018      	lod	A, #24

00005e08 <.LVL11>:
    5e08:	5237      	mov	[S-56], A

00005e0a <.L22>:
  }

  for (index = 0; index < RGBLEDMAX; index++)
  {
    /*if intensity is 0, then turn off lights.*/
    if (inputColor->intensity[index] == 0)
    5e0a:	7a35      	lod	Y, [S-54]
    5e0c:	72d6      	lod	A, [Y++]
    5e0e:	5a35      	mov	[S-54], Y
    5e10:	1d01      	jne	0x5e14 <.LM19>
    5e12:	03e7      	jmp	0x65e2 <.L5>

00005e14 <.LM19>:
      continue;

	if ((inputColor->colorU[index] > 529) || (inputColor->colorU[index] < 76))
    5e14:	e0e6      	add	Y, #-26
    5e16:	7af0      	lod	Y, [Y]
    5e18:	5a15      	mov	[S-22], Y
    5e1a:	e0b4      	add	Y, #-76
    5e1c:	5a1d      	mov	[S-30], Y
    5e1e:	eeda 01c5 	cmp	Y, #453
    5e22:	1a01      	jule	0x5e26 <.LM20>
    5e24:	03de      	jmp	0x65e2 <.L5>

00005e26 <.LM20>:
		continue;

	if ((inputColor->colorV[index] > 565) || (inputColor->colorV[index] < 113))
    5e26:	7a35      	lod	Y, [S-54]
    5e28:	e0f2      	add	Y, #-14
    5e2a:	7af0      	lod	Y, [Y]
    5e2c:	5a19      	mov	[S-26], Y
    5e2e:	72e6      	lod	A, Y
    5e30:	a08f      	add	A, #-113
    5e32:	aeda 01c4 	cmp	A, #452
    5e36:	1a01      	jule	0x5e3a <.LM21>
    5e38:	03d4      	jmp	0x65e2 <.L5>

00005e3a <.LM21>:
		continue;

	tempValue = (uint32_t)(inputColor->colorU[index] - 76) * (565 - 517) / (uint32_t)(529 - 76);
    5e3a:	721d      	lod	A, [S-30]
    5e3c:	4802 0030 	mulu	D, A, #48
    5e40:	54ca 01c5 	pushw	#453
    5e44:	54ca 0000 	pushw	#0

00005e48 <.LCFI10>:
    5e48:	4c80      	mov	YA, D
    5e4a:	1742      	call	0x5cd0 <___udivsi3>
    5e4c:	5c03      	dec	S, #4

00005e4e <.LCFI11>:

	VUpLimit = 565 - (uint16_t)tempValue + 15;
    5e4e:	7ada 0244 	lod	Y, #580
    5e52:	eae2      	sub	Y, A
    5e54:	5a21      	mov	[S-34], Y

00005e56 <.LM23>:

	if (inputColor->colorU[index] <= 203)
    5e56:	7215      	lod	A, [S-22]
    5e58:	aeda 00cb 	cmp	A, #203
    5e5c:	1a01      	jule	0x5e60 <.LM24>
    5e5e:	03c9      	jmp	0x65f2 <.L6>

00005e60 <.LM24>:
	{
		tempValue = (uint32_t)((inputColor->colorU[index] - 76)) * (565 - 114) / (uint32_t)(203 - 76);
    5e60:	721d      	lod	A, [S-30]
    5e62:	4802 01c3 	mulu	D, A, #451
    5e66:	54ca 007f 	pushw	#127
    5e6a:	54ca 0000 	pushw	#0

00005e6e <.LCFI12>:
    5e6e:	4c80      	mov	YA, D
    5e70:	172f      	call	0x5cd0 <___udivsi3>

00005e72 <.LVL22>:
    5e72:	5c03      	dec	S, #4

00005e74 <.LCFI13>:
		VDownLimit = 565 - (uint16_t)tempValue - 15;
    5e74:	7ada 0226 	lod	Y, #550
    5e78:	eae2      	sub	Y, A
    5e7a:	72e6      	lod	A, Y

00005e7c <.L7>:
	{
		tempValue = (uint32_t)(inputColor->colorU[index] - 203) * (517 - 114) / (uint32_t)(529 - 203);
		VDownLimit = 114 + (uint16_t)tempValue - 15;
	}

	if ((inputColor->colorV[index] >= VUpLimit) || (inputColor->colorV[index] <= VDownLimit))
    5e7c:	7a19      	lod	Y, [S-26]
    5e7e:	ee21      	cmp	Y, [S-34]
    5e80:	1801      	jc	0x5e84 <.LM27>
    5e82:	03af      	jmp	0x65e2 <.L5>

00005e84 <.LM27>:
    5e84:	eee2      	cmp	Y, A
    5e86:	1e01      	jug	0x5e8a <.LBB110>
    5e88:	03ac      	jmp	0x65e2 <.L5>

00005e8a <.LBB110>:

uint32_t tempDenominator, tempu, tempv, templ;
/*get target CIE color by input LIN and other signals.*/
static void __algoGetTargetColorFromCIE1976(uint16_t ledIndex, SColorParams *inputColor, SCIEColor *targetColor)
{
  tempDenominator  = (uint32_t)inputColor->colorU[ledIndex]*6 + 12000;
    5e8a:	7215      	lod	A, [S-22]

00005e8c <.LVL26>:
    5e8c:	4802 0006 	mulu	D, A, #6
    5e90:	4c02 2ee0 	add	D, #12000
    5e94:	0000 

00005e96 <.LM29>:
  tempDenominator  = tempDenominator - (uint32_t)inputColor->colorV[ledIndex]*16;
    5e96:	4ce9      	movu	YA, Y
    5e98:	48e3      	asl	YA, #4
    5e9a:	4c10      	sub	D, YA
    5e9c:	588d      	mov	[S-30], D
    5e9e:	4c80      	mov	YA, D
    5ea0:	52d8 1336 	mov	0x1336 <_tempDenominator>, A
    5ea4:	5ad8 1338 	mov	0x1338 <_tempDenominator+0x2>, Y

00005ea8 <.LM30>:

  tempu = ((uint32_t)inputColor->colorU[ledIndex]*9)*1000;
    5ea8:	7215      	lod	A, [S-22]
    5eaa:	4802 2328 	mulu	D, A, #9000

00005eae <.LM31>:
  tempv = ((uint32_t)inputColor->colorV[ledIndex]*4)*1000;

  tempu = tempu/tempDenominator;
    5eae:	7a1d      	lod	Y, [S-30]
    5eb0:	5adf      	push	Y

00005eb2 <.LCFI14>:
    5eb2:	7a1d      	lod	Y, [S-30]
    5eb4:	5adf      	push	Y

00005eb6 <.LCFI15>:
    5eb6:	4c80      	mov	YA, D
    5eb8:	170b      	call	0x5cd0 <___udivsi3>
    5eba:	5c03      	dec	S, #4

00005ebc <.LCFI16>:
    5ebc:	58a9      	mov	[S-22], YA
    5ebe:	52d8 132e 	mov	0x132e <_tempu>, A
    5ec2:	5ad8 1330 	mov	0x1330 <_tempu+0x2>, Y

00005ec6 <.LM32>:
{
  tempDenominator  = (uint32_t)inputColor->colorU[ledIndex]*6 + 12000;
  tempDenominator  = tempDenominator - (uint32_t)inputColor->colorV[ledIndex]*16;

  tempu = ((uint32_t)inputColor->colorU[ledIndex]*9)*1000;
  tempv = ((uint32_t)inputColor->colorV[ledIndex]*4)*1000;
    5ec6:	7219      	lod	A, [S-26]
    5ec8:	4802 0fa0 	mulu	D, A, #4000

00005ecc <.LM33>:

  tempu = tempu/tempDenominator;
  tempv = tempv/tempDenominator;
    5ecc:	7a1d      	lod	Y, [S-30]
    5ece:	5adf      	push	Y

00005ed0 <.LCFI17>:
    5ed0:	7a1d      	lod	Y, [S-30]
    5ed2:	5adf      	push	Y

00005ed4 <.LCFI18>:
    5ed4:	4c80      	mov	YA, D
    5ed6:	16fc      	call	0x5cd0 <___udivsi3>
    5ed8:	5c03      	dec	S, #4

00005eda <.LCFI19>:
    5eda:	52d8 1332 	mov	0x1332 <_tempv>, A
    5ede:	5ad8 1334 	mov	0x1334 <_tempv+0x2>, Y

00005ee2 <.LBB112>:
*
*@param[in] a  int32 value wants to transfer.
*
*@retval    fix16_t value.
*/
static __inline fix16_t fix16_from_int(int32_t a)     { return a * fix16_one; }
    5ee2:	58e9      	mov	YA, [S-22]
    5ee4:	48ef      	asl	YA, #16

00005ee6 <.LBE112>:

  targetColor->x = fix16_mul(fix16_from_int(tempu), fix16ConstM);
    5ee6:	54ca 0042 	pushw	#66
    5eea:	54ca 0000 	pushw	#0

00005eee <.LCFI20>:
    5eee:	82db 344f 	callf	0x689e <_fix16_mul>
    5ef2:	523f      	mov	[S-64], A
    5ef4:	5a3d      	mov	[S-62], Y

00005ef6 <.LBB114>:
    5ef6:	72d8 1332 	lod	A, 0x1332 <_tempv>
    5efa:	48ef      	asl	YA, #16

00005efc <.LBE114>:
  targetColor->y = fix16_mul(fix16_from_int(tempv), fix16ConstM);
    5efc:	54ca 0042 	pushw	#66
    5f00:	54ca 0000 	pushw	#0

00005f04 <.LCFI21>:
    5f04:	82db 344f 	callf	0x689e <_fix16_mul>
    5f08:	524f      	mov	[S-80], A
    5f0a:	5a4d      	mov	[S-78], Y

00005f0c <.LM38>:

  templ = (uint32_t)inputColor->intensity[ledIndex]*(uint32_t)15625/(uint32_t)4000;
    5f0c:	7a3d      	lod	Y, [S-62]
    5f0e:	e0fe      	add	Y, #-2
    5f10:	72da 3d09 	lod	A, #15625
    5f14:	4825      	mulu	YA, A, [Y]
    5f16:	5c07      	dec	S, #8

00005f18 <.LCFI22>:
    5f18:	54ca 0fa0 	pushw	#4000
    5f1c:	54ca 0000 	pushw	#0

00005f20 <.LCFI23>:
    5f20:	16d7      	call	0x5cd0 <___udivsi3>
    5f22:	5c03      	dec	S, #4

00005f24 <.LCFI24>:
  if (templ < 39)
    5f24:	4cb2 0026 	cmp	YA, #38
    5f28:	0000 
    5f2a:	1e01      	jug	0x5f2e <.LM40>
    5f2c:	0370      	jmp	0x660e <.L8>

00005f2e <.LM40>:
  tempv = tempv/tempDenominator;

  targetColor->x = fix16_mul(fix16_from_int(tempu), fix16ConstM);
  targetColor->y = fix16_mul(fix16_from_int(tempv), fix16ConstM);

  templ = (uint32_t)inputColor->intensity[ledIndex]*(uint32_t)15625/(uint32_t)4000;
    5f2e:	52d8 133a 	mov	0x133a <_templ>, A
    5f32:	5ad8 133c 	mov	0x133c <_templ+0x2>, Y

00005f36 <.L9>:
    5f36:	72d8 133a 	lod	A, 0x133a <_templ>
    5f3a:	48ef      	asl	YA, #16

00005f3c <.LBE116>:
  if (templ < 39)
	  templ = 39;
  //templ = (uint32_t)inputColor->intensity[ledIndex]*(uint32_t)23437/(uint32_t)4000;
  targetColor->Y = fix16_mul(fix16_from_int(templ), fix16Const1M);
    5f3c:	54ca 0007 	pushw	#7
    5f40:	54ca 0000 	pushw	#0

00005f44 <.LCFI25>:
    5f44:	82db 344f 	callf	0x689e <_fix16_mul>

00005f48 <.LM43>:
  targetColor->Y = fix16_mul(intensityAdjustConst, targetColor->Y);
    5f48:	4ca3      	push	YA

00005f4a <.LCFI26>:
    5f4a:	4ce2 0000 	mov	YA, #65536
    5f4e:	0001 
    5f50:	82db 344f 	callf	0x689e <_fix16_mul>
    5f54:	5257      	mov	[S-88], A
    5f56:	5a55      	mov	[S-86], Y

00005f58 <.LBE110>:
		continue;

    /*get target CIE color by input LIN and other signals.*/
    __algoGetTargetColorFromCIE1976(index, inputColor, &targetColor);
    /*Compensate LED by temperature.*/
    __algoLedFixCIE(index, inputColor->ledTemprature[index]/DTEMP_MULTIPLIED_RATIO);
    5f58:	7a3d      	lod	Y, [S-62]
    5f5a:	e00a      	add	Y, #10
    5f5c:	72f0      	lod	A, [Y]
    5f5e:	4cf8      	movs	YA, A
    5f60:	4c72 000a 	divs	YA, #10
    5f64:	4c72 000a 	divs	YA, #10
    5f68:	4c7a 000a 	dadjs	YA, #10
    5f6c:	5221      	mov	[S-34], A

00005f6e <.LVL35>:
    5f6e:	72da 5a18 	lod	A, #23064
    5f72:	5229      	mov	[S-42], A

00005f74 <.LBB119>:
  int16_t line_p, redp, greenp, bluep;
  /*Temporary use*/
  //SCIExyY redTempxyY, greenTempxyY, blueTempxyY;
  int16_t tempShift;

  for( i = 0 ; i < (DMAX_TEMP_SHIFT_RECORD_AMOUNT-1) ; i++)
    5f74:	7000      	lod	A, #0
    5f76:	5c07      	dec	S, #8

00005f78 <.LCFI27>:
    5f78:	521d      	mov	[S-30], A
    5f7a:	7c07      	lod	X, #7

00005f7c <.L12>:
  {
    if ((ledTemp >= TtoCIE[i].Temperature) &&
    5f7c:	7219      	lod	A, [S-26]
    5f7e:	7a21      	lod	Y, [S-34]
    5f80:	aef0      	cmp	A, [Y]
    5f82:	1a83      	jsl	0x5f8a <.L10>

00005f84 <.LM47>:
        (ledTemp < TtoCIE[i+1].Temperature))
    5f84:	e014      	add	Y, #20

00005f86 <.LM48>:
  //SCIExyY redTempxyY, greenTempxyY, blueTempxyY;
  int16_t tempShift;

  for( i = 0 ; i < (DMAX_TEMP_SHIFT_RECORD_AMOUNT-1) ; i++)
  {
    if ((ledTemp >= TtoCIE[i].Temperature) &&
    5f86:	aef0      	cmp	A, [Y]
    5f88:	1a89      	jsl	0x5f9c <.L11>

00005f8a <.L10>:
    5f8a:	7a21      	lod	Y, [S-34]
    5f8c:	e014      	add	Y, #20
    5f8e:	5a21      	mov	[S-34], Y
    5f90:	721d      	lod	A, [S-30]
    5f92:	a001      	add	A, #1

00005f94 <.LVL39>:
    5f94:	521d      	mov	[S-30], A

00005f96 <.LM49>:
  int16_t line_p, redp, greenp, bluep;
  /*Temporary use*/
  //SCIExyY redTempxyY, greenTempxyY, blueTempxyY;
  int16_t tempShift;

  for( i = 0 ; i < (DMAX_TEMP_SHIFT_RECORD_AMOUNT-1) ; i++)
    5f96:	1bf2      	djnz	X, 0x5f7c <.L12>

00005f98 <.LM50>:
      break;
    }
  }

  if (fixLevel == -1)
    i = 0;
    5f98:	7000      	lod	A, #0

00005f9a <.LVL40>:
    5f9a:	521d      	mov	[S-30], A

00005f9c <.L11>:

  tempShift = (TtoCIE[i+1].Temperature-TtoCIE[i].Temperature);
    5f9c:	7e1d      	lod	X, [S-30]
    5f9e:	2001      	add	X, #1
    5fa0:	721d      	lod	A, [S-30]
    5fa2:	4872 0014 	muls	A, A, #20
    5fa6:	7ae2      	lod	Y, A
    5fa8:	e2da 5a18 	add	Y, #23064
    5fac:	5a1d      	mov	[S-30], Y

00005fae <.LVL42>:
    5fae:	72d6      	lod	A, [Y++]
    5fb0:	5225      	mov	[S-38], A
    5fb2:	72ee      	lod	A, X
    5fb4:	4872 0014 	muls	A, A, #20
    5fb8:	7ee2      	lod	X, A
    5fba:	22da 5a18 	add	X, #23064
    5fbe:	5e21      	mov	[S-34], X
    5fc0:	72de      	lod	A, [X++]
    5fc2:	aa25      	sub	A, [S-38]
    5fc4:	5215      	mov	[S-22], A

00005fc6 <.LM52>:

//fix red color
  line_p = ((TtoCIE[i+1].redYShift - TtoCIE[i].redYShift)<<4)/tempShift;
    5fc6:	7af0      	lod	Y, [Y]
    5fc8:	5a29      	mov	[S-42], Y

00005fca <.LM53>:
  redp = TtoCIE[i].redYShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4);
    5fca:	7219      	lod	A, [S-26]

00005fcc <.LVL46>:
    5fcc:	aa25      	sub	A, [S-38]
    5fce:	5219      	mov	[S-26], A
    5fd0:	7237      	lod	A, [S-56]
    5fd2:	44a2      	asl	A, #2
    5fd4:	5225      	mov	[S-38], A
    5fd6:	a2da 1196 	add	A, #4502
    5fda:	522d      	mov	[S-46], A

00005fdc <.LM54>:
    i = 0;

  tempShift = (TtoCIE[i+1].Temperature-TtoCIE[i].Temperature);

//fix red color
  line_p = ((TtoCIE[i+1].redYShift - TtoCIE[i].redYShift)<<4)/tempShift;
    5fdc:	72f8      	lod	A, [X]
    5fde:	aae6      	sub	A, Y
    5fe0:	44a2      	asl	A, #2
    5fe2:	44a2      	asl	A, #2
    5fe4:	7e15      	lod	X, [S-22]
    5fe6:	4cf8      	movs	YA, A
    5fe8:	4c73      	divs	YA, X
    5fea:	4c73      	divs	YA, X
    5fec:	4c7b      	dadjs	YA, X

00005fee <.LM55>:
  redp = TtoCIE[i].redYShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4);
    5fee:	7a19      	lod	Y, [S-26]
    5ff0:	4871      	muls	A, A, Y
    5ff2:	44f2      	asr	A, #2
    5ff4:	44f2      	asr	A, #2
    5ff6:	a229      	add	A, [S-42]

00005ff8 <.LM56>:
  currentRedCIE[ledIndex].Y = fix16_div(fix16_from_int(redp*redxyY[ledIndex].Y/1000), fix16Const10000);
    5ff8:	4cd8      	movs	D, A
    5ffa:	722d      	lod	A, [S-46]
    5ffc:	a0a4      	add	A, #-92
    5ffe:	7ae2      	lod	Y, A
    6000:	7ef0      	lod	X, [Y]
    6002:	5edf      	push	X

00006004 <.LCFI28>:
    6004:	7ef2      	lod	X, [Y+2]
    6006:	5edf      	push	X

00006008 <.LCFI29>:
    6008:	4c80      	mov	YA, D
    600a:	15cd      	call	0x5ba6 <___mulsi3>
    600c:	5c03      	dec	S, #4

0000600e <.LCFI30>:
    600e:	54ca 03e8 	pushw	#1000
    6012:	54ca 0000 	pushw	#0

00006016 <.LCFI31>:
    6016:	1627      	call	0x5c66 <___divsi3>
    6018:	5c03      	dec	S, #4

0000601a <.LBB121>:
    601a:	48ef      	asl	YA, #16

0000601c <.LBE121>:
    601c:	54ca 0000 	pushw	#0
    6020:	54ca 2710 	pushw	#10000

00006024 <.LCFI33>:
    6024:	1324      	call	0x666e <_fix16_div>
    6026:	4cc0      	mov	D, YA
    6028:	723b      	lod	A, [S-60]
    602a:	4872 0006 	muls	A, A, #6
    602e:	522d      	mov	[S-46], A
    6030:	a2da 10ee 	add	A, #4334
    6034:	5235      	mov	[S-54], A
    6036:	a2da ff78 	add	A, #65400
    603a:	5245      	mov	[S-70], A
    603c:	7ae2      	lod	Y, A
    603e:	4c85      	mov	[Y], D

00006040 <.LM59>:
  currentRedCIE[ledIndex].Y = fix16_mul(currentRedCIE[ledIndex].Y, fix16Const75);
    6040:	54ca 8000 	pushw	#32768
    6044:	54ca 0007 	pushw	#7

00006048 <.LCFI34>:
    6048:	4c80      	mov	YA, D
    604a:	82db 344f 	callf	0x689e <_fix16_mul>
    604e:	7e49      	lod	X, [S-74]
    6050:	4ca7      	mov	[X], YA

00006052 <.LM60>:

  line_p = ((TtoCIE[i+1].redxShift - TtoCIE[i].redxShift)<<4)/tempShift;
    6052:	7a25      	lod	Y, [S-38]
    6054:	e008      	add	Y, #8
    6056:	72f0      	lod	A, [Y]
    6058:	5247      	mov	[S-72], A
    605a:	7a29      	lod	Y, [S-42]
    605c:	e008      	add	Y, #8
    605e:	72f0      	lod	A, [Y]
    6060:	aa47      	sub	A, [S-72]
    6062:	44a2      	asl	A, #2
    6064:	44a2      	asl	A, #2
    6066:	7eef      	lod	X, S
    6068:	20e2      	add	X, #-30
    606a:	4cf8      	movs	YA, A
    606c:	4c77      	divs	YA, [X]
    606e:	4c77      	divs	YA, [X]
    6070:	4c7f      	dadjs	YA, [X]

00006072 <.LM61>:
  redp = TtoCIE[i].redxShift + ((line_p * (ledTemp-TtoCIE[i].Temperature))>>4);
    6072:	7a21      	lod	Y, [S-34]
    6074:	4871      	muls	A, A, Y
    6076:	44f2      	asr	A, #2
    6078:	44f2      	asr	A, #2
    607a:	a247      	add	A, [S-72]

0000607c <.LM62>:
  currentRedCIE[ledIndex].x = fix16_div(fix16_from_int(redxyY[ledIndex].x+redp), fix16Const10000);
    607c:	7a35      	lod	Y, [S-54]
    607e:	e0a0      	add	Y, #-96
    6080:	a2f0      	add	A, [Y]
    6082:	4cf6      	ssex	YA

00006084 <.LBB123>:
    6084:	48ef      	asl	YA, #16

00006086 <.LBE123>:
    6086:	54ca 0000 	pushw	#0
    608a:	54ca 2710 	pushw	#10000

0000608e <.LCFI35>:
    608e:	12ef      	call	0x666e <_fix16_div>
    6090:	7e3d      	lod	X, [S-62]
    6092:	22da ff70 	add	X, #65392
    6096:	5e55      	mov	[S-86], X
    6098:	4ca7      	mov	[X], YA

0000609a <.LM65>:

  line_p = ((TtoCIE[i+1].redyShift - TtoCIE[i].redyShift)<<4)/tempShift;
    609a:	7a29      	lod	Y, [S-42]
    609c:	e00a      	add	Y, #10
    609e:	72f0      	lod	A, [Y]
    60a0:	524b      	mov	[S-76], A
    60a2:	7a2d      	lod	Y, [S-46]
    60a4:	e00a      	add	Y, #10
    60a6:	72f0      	lod	A, [Y]
    60a8:	aa4b      	sub	A, [S-76]
    60aa:	44a2      	asl	A, #2
    60ac:	44a2      	asl	A, #2
    60ae:	7eef      	lod	X, S
    60b0:	20de      	add	X, #-34
    60b2:	4cf8      	movs	YA, A
    60b4:	4c77      	divs	YA, [X]
    60b6:	4c77      	divs	YA, [X]
    60b8:	4c7f      	dadjs	YA, [X]

000060ba <.LM66>:
  redp = TtoCIE[i].redyShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4);
    60ba:	7a25      	lod	Y, [S-38]
    60bc:	4871      	muls	A, A, Y
    60be:	44f2      	asr	A, #2
    60c0:	44f2      	asr	A, #2
    60c2:	a24b      	add	A, [S-76]

000060c4 <.LM67>:
  currentRedCIE[ledIndex].y = fix16_div(fix16_from_int(redxyY[ledIndex].y+redp), fix16Const10000);
    60c4:	7a39      	lod	Y, [S-58]
    60c6:	e0a2      	add	Y, #-94
    60c8:	a2f0      	add	A, [Y]
    60ca:	4cf6      	ssex	YA

000060cc <.LBB125>:
    60cc:	48ef      	asl	YA, #16

000060ce <.LBE125>:
    60ce:	54ca 0000 	pushw	#0
    60d2:	54ca 2710 	pushw	#10000

000060d6 <.LCFI36>:
    60d6:	12cb      	call	0x666e <_fix16_div>
    60d8:	7e41      	lod	X, [S-66]
    60da:	22da ff74 	add	X, #65396
    60de:	5e41      	mov	[S-66], X
    60e0:	4ca7      	mov	[X], YA

000060e2 <.LM70>:
//fix red color

//fix green color
  line_p = ((TtoCIE[i+1].greenYShift - TtoCIE[i].greenYShift)<<4)/tempShift;
    60e2:	7a2d      	lod	Y, [S-46]
    60e4:	72f4      	lod	A, [Y+4]
    60e6:	5221      	mov	[S-34], A

000060e8 <.LVL63>:
    60e8:	7e35      	lod	X, [S-54]
    60ea:	22da 1166 	add	X, #4454
    60ee:	5e43      	mov	[S-68], X
    60f0:	7a31      	lod	Y, [S-50]
    60f2:	72f4      	lod	A, [Y+4]
    60f4:	aa21      	sub	A, [S-34]
    60f6:	44a2      	asl	A, #2
    60f8:	44a2      	asl	A, #2
    60fa:	7eef      	lod	X, S
    60fc:	20da      	add	X, #-38
    60fe:	4cf8      	movs	YA, A
    6100:	4c77      	divs	YA, [X]
    6102:	4c77      	divs	YA, [X]
    6104:	4c7f      	dadjs	YA, [X]

00006106 <.LM71>:
  greenp = TtoCIE[i].greenYShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
    6106:	7a29      	lod	Y, [S-42]
    6108:	4871      	muls	A, A, Y
    610a:	44f2      	asr	A, #2
    610c:	44f2      	asr	A, #2
    610e:	a221      	add	A, [S-34]

00006110 <.LM72>:
  currentGreenCIE[ledIndex].Y = fix16_div(fix16_from_int(greenp*greenxyY[ledIndex].Y/1000), fix16Const10000);
    6110:	4cd8      	movs	D, A
    6112:	7243      	lod	A, [S-68]
    6114:	a0a4      	add	A, #-92
    6116:	7ae2      	lod	Y, A
    6118:	7ef0      	lod	X, [Y]
    611a:	5edf      	push	X

0000611c <.LCFI37>:
    611c:	7ef2      	lod	X, [Y+2]
    611e:	5edf      	push	X

00006120 <.LCFI38>:
    6120:	4c80      	mov	YA, D
    6122:	1541      	call	0x5ba6 <___mulsi3>
    6124:	5c03      	dec	S, #4

00006126 <.LCFI39>:
    6126:	54ca 03e8 	pushw	#1000
    612a:	54ca 0000 	pushw	#0

0000612e <.LCFI40>:
    612e:	159b      	call	0x5c66 <___divsi3>
    6130:	5c03      	dec	S, #4

00006132 <.LBB127>:
    6132:	48ef      	asl	YA, #16

00006134 <.LBE127>:
    6134:	54ca 0000 	pushw	#0
    6138:	54ca 2710 	pushw	#10000

0000613c <.LCFI42>:
    613c:	1298      	call	0x666e <_fix16_div>
    613e:	7e3d      	lod	X, [S-62]
    6140:	22da 10a6 	add	X, #4262
    6144:	5e41      	mov	[S-66], X
    6146:	22da ff78 	add	X, #65400
    614a:	5e57      	mov	[S-88], X
    614c:	4ca7      	mov	[X], YA

0000614e <.LM75>:
  currentGreenCIE[ledIndex].Y = fix16_mul(currentGreenCIE[ledIndex].Y, fix16Const75);
    614e:	54ca 8000 	pushw	#32768
    6152:	54ca 0007 	pushw	#7

00006156 <.LCFI43>:
    6156:	13a3      	call	0x689e <_fix16_mul>
    6158:	7e5b      	lod	X, [S-92]
    615a:	4ca7      	mov	[X], YA

0000615c <.LM76>:

  line_p = ((TtoCIE[i+1].greenxShift - TtoCIE[i].greenxShift)<<4)/tempShift;
    615c:	7a35      	lod	Y, [S-54]
    615e:	e00c      	add	Y, #12
    6160:	72f0      	lod	A, [Y]
    6162:	5263      	mov	[S-100], A
    6164:	7a39      	lod	Y, [S-58]
    6166:	e00c      	add	Y, #12
    6168:	72f0      	lod	A, [Y]
    616a:	aa63      	sub	A, [S-100]
    616c:	44a2      	asl	A, #2
    616e:	44a2      	asl	A, #2
    6170:	7eef      	lod	X, S
    6172:	20d2      	add	X, #-46
    6174:	4cf8      	movs	YA, A
    6176:	4c77      	divs	YA, [X]
    6178:	4c77      	divs	YA, [X]
    617a:	4c7f      	dadjs	YA, [X]

0000617c <.LM77>:
  greenp = TtoCIE[i].greenxShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4);
    617c:	7a31      	lod	Y, [S-50]
    617e:	4871      	muls	A, A, Y
    6180:	44f2      	asr	A, #2
    6182:	44f2      	asr	A, #2
    6184:	a263      	add	A, [S-100]

00006186 <.LM78>:
  currentGreenCIE[ledIndex].x = fix16_div(fix16_from_int(greenxyY[ledIndex].x+greenp), fix16Const10000);
    6186:	7a4b      	lod	Y, [S-76]
    6188:	e0a0      	add	Y, #-96
    618a:	a2f0      	add	A, [Y]
    618c:	4cf6      	ssex	YA

0000618e <.LBB129>:
    618e:	48ef      	asl	YA, #16

00006190 <.LBE129>:
    6190:	54ca 0000 	pushw	#0
    6194:	54ca 2710 	pushw	#10000

00006198 <.LCFI44>:
    6198:	126a      	call	0x666e <_fix16_div>
    619a:	7e49      	lod	X, [S-74]
    619c:	22da ff70 	add	X, #65392
    61a0:	5e5b      	mov	[S-92], X
    61a2:	4ca7      	mov	[X], YA

000061a4 <.LM81>:

  line_p = ((TtoCIE[i+1].greenyShift - TtoCIE[i].greenyShift)<<4)/tempShift;
    61a4:	7a39      	lod	Y, [S-58]
    61a6:	e00e      	add	Y, #14
    61a8:	72f0      	lod	A, [Y]
    61aa:	521d      	mov	[S-30], A
    61ac:	7a3d      	lod	Y, [S-62]
    61ae:	e00e      	add	Y, #14
    61b0:	72f0      	lod	A, [Y]
    61b2:	aa1d      	sub	A, [S-30]
    61b4:	44a2      	asl	A, #2
    61b6:	44a2      	asl	A, #2
    61b8:	7eef      	lod	X, S
    61ba:	20ce      	add	X, #-50
    61bc:	4cf8      	movs	YA, A
    61be:	4c77      	divs	YA, [X]
    61c0:	4c77      	divs	YA, [X]
    61c2:	4c7f      	dadjs	YA, [X]

000061c4 <.LM82>:
  greenp = TtoCIE[i].greenyShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
    61c4:	7a35      	lod	Y, [S-54]
    61c6:	4871      	muls	A, A, Y
    61c8:	44f2      	asr	A, #2
    61ca:	44f2      	asr	A, #2
    61cc:	a21d      	add	A, [S-30]

000061ce <.LM83>:
  currentGreenCIE[ledIndex].y = fix16_div(fix16_from_int(greenxyY[ledIndex].y+greenp), fix16Const10000);
    61ce:	7a4f      	lod	Y, [S-80]
    61d0:	e0a2      	add	Y, #-94
    61d2:	a2f0      	add	A, [Y]
    61d4:	4cf6      	ssex	YA

000061d6 <.LBB131>:
    61d6:	48ef      	asl	YA, #16

000061d8 <.LBE131>:
    61d8:	54ca 0000 	pushw	#0
    61dc:	54ca 2710 	pushw	#10000

000061e0 <.LCFI45>:
    61e0:	1246      	call	0x666e <_fix16_div>
    61e2:	7e4d      	lod	X, [S-78]
    61e4:	22da ff74 	add	X, #65396
    61e8:	5e4d      	mov	[S-78], X
    61ea:	4ca7      	mov	[X], YA

000061ec <.LM86>:
//fix green color

//fix blue color
  line_p = ((TtoCIE[i+1].blueYshift - TtoCIE[i].blueYshift)<<4)/tempShift;
    61ec:	7a3d      	lod	Y, [S-62]
    61ee:	72f6      	lod	A, [Y+6]
    61f0:	522f      	mov	[S-48], A
    61f2:	7e45      	lod	X, [S-70]
    61f4:	22da 1136 	add	X, #4406
    61f8:	5e45      	mov	[S-70], X

000061fa <.LM87>:
  bluep = TtoCIE[i].blueYshift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
  currentBlueCIE[ledIndex].Y = fix16_div(fix16_from_int(bluep*bluexyY[ledIndex].Y/1000), fix16Const10000);
    61fa:	5c1f      	dec	S, #32

000061fc <.LCFI46>:
  greenp = TtoCIE[i].greenyShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
  currentGreenCIE[ledIndex].y = fix16_div(fix16_from_int(greenxyY[ledIndex].y+greenp), fix16Const10000);
//fix green color

//fix blue color
  line_p = ((TtoCIE[i+1].blueYshift - TtoCIE[i].blueYshift)<<4)/tempShift;
    61fc:	7a21      	lod	Y, [S-34]
    61fe:	72f6      	lod	A, [Y+6]
    6200:	aa0f      	sub	A, [S-16]
    6202:	44a2      	asl	A, #2
    6204:	44a2      	asl	A, #2
    6206:	7e15      	lod	X, [S-22]
    6208:	4cf8      	movs	YA, A
    620a:	4c73      	divs	YA, X
    620c:	4c73      	divs	YA, X
    620e:	4c7b      	dadjs	YA, X

00006210 <.LM89>:
  bluep = TtoCIE[i].blueYshift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
    6210:	7a19      	lod	Y, [S-26]
    6212:	4871      	muls	A, A, Y
    6214:	44f2      	asr	A, #2
    6216:	44f2      	asr	A, #2
    6218:	a20f      	add	A, [S-16]

0000621a <.LM90>:
  currentBlueCIE[ledIndex].Y = fix16_div(fix16_from_int(bluep*bluexyY[ledIndex].Y/1000), fix16Const10000);
    621a:	4cd8      	movs	D, A
    621c:	7225      	lod	A, [S-38]
    621e:	a0a4      	add	A, #-92
    6220:	7ae2      	lod	Y, A
    6222:	7ef0      	lod	X, [Y]
    6224:	5edf      	push	X

00006226 <.LCFI47>:
    6226:	7ef2      	lod	X, [Y+2]
    6228:	5edf      	push	X

0000622a <.LCFI48>:
    622a:	4c80      	mov	YA, D
    622c:	14bc      	call	0x5ba6 <___mulsi3>
    622e:	5c03      	dec	S, #4

00006230 <.LCFI49>:
    6230:	54ca 03e8 	pushw	#1000
    6234:	54ca 0000 	pushw	#0

00006238 <.LCFI50>:
    6238:	1516      	call	0x5c66 <___divsi3>
    623a:	5c03      	dec	S, #4

0000623c <.LBB133>:
    623c:	48ef      	asl	YA, #16

0000623e <.LBE133>:
    623e:	54ca 0000 	pushw	#0
    6242:	54ca 2710 	pushw	#10000

00006246 <.LCFI52>:
    6246:	1213      	call	0x666e <_fix16_div>
    6248:	7e2d      	lod	X, [S-46]
    624a:	22da 105e 	add	X, #4190
    624e:	5e2d      	mov	[S-46], X
    6250:	22da ff78 	add	X, #65400
    6254:	5e37      	mov	[S-56], X
    6256:	4ca7      	mov	[X], YA

00006258 <.LM93>:
  currentBlueCIE[ledIndex].Y = fix16_mul(currentBlueCIE[ledIndex].Y, fix16Const75);
    6258:	54ca 8000 	pushw	#32768
    625c:	54ca 0007 	pushw	#7

00006260 <.LCFI53>:
    6260:	131e      	call	0x689e <_fix16_mul>
    6262:	7e3b      	lod	X, [S-60]
    6264:	4ca7      	mov	[X], YA

00006266 <.LM94>:

  line_p = ((TtoCIE[i+1].bluexShift - TtoCIE[i].bluexShift)<<4)/tempShift;
    6266:	7a25      	lod	Y, [S-38]
    6268:	e010      	add	Y, #16
    626a:	72f0      	lod	A, [Y]
    626c:	5209      	mov	[S-10], A
    626e:	7a29      	lod	Y, [S-42]
    6270:	e010      	add	Y, #16
    6272:	72f0      	lod	A, [Y]
    6274:	aa09      	sub	A, [S-10]
    6276:	44a2      	asl	A, #2
    6278:	44a2      	asl	A, #2
    627a:	7eef      	lod	X, S
    627c:	20e2      	add	X, #-30
    627e:	4cf8      	movs	YA, A
    6280:	4c77      	divs	YA, [X]
    6282:	4c77      	divs	YA, [X]
    6284:	4c7f      	dadjs	YA, [X]

00006286 <.LM95>:
  bluep = TtoCIE[i].bluexShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
    6286:	7a21      	lod	Y, [S-34]
    6288:	4871      	muls	A, A, Y
    628a:	44f2      	asr	A, #2
    628c:	44f2      	asr	A, #2
    628e:	a209      	add	A, [S-10]

00006290 <.LM96>:
  currentBlueCIE[ledIndex].x = fix16_div(fix16_from_int(bluexyY[ledIndex].x+bluep), fix16Const10000);
    6290:	7a2d      	lod	Y, [S-46]
    6292:	e0a0      	add	Y, #-96
    6294:	a2f0      	add	A, [Y]
    6296:	4cf6      	ssex	YA

00006298 <.LBB135>:
    6298:	48ef      	asl	YA, #16

0000629a <.LBE135>:
    629a:	54ca 0000 	pushw	#0
    629e:	54ca 2710 	pushw	#10000

000062a2 <.LCFI54>:
    62a2:	11e5      	call	0x666e <_fix16_div>
    62a4:	7e35      	lod	X, [S-54]
    62a6:	22da ff70 	add	X, #65392
    62aa:	5e57      	mov	[S-88], X
    62ac:	4ca7      	mov	[X], YA

000062ae <.LM99>:

  line_p = ((TtoCIE[i+1].blueyShift - TtoCIE[i].blueyShift)<<4)/tempShift;
    62ae:	7a29      	lod	Y, [S-42]
    62b0:	e012      	add	Y, #18
    62b2:	72f0      	lod	A, [Y]
    62b4:	5229      	mov	[S-42], A
    62b6:	7a2d      	lod	Y, [S-46]
    62b8:	e012      	add	Y, #18
    62ba:	72f0      	lod	A, [Y]
    62bc:	aa29      	sub	A, [S-42]
    62be:	44a2      	asl	A, #2
    62c0:	44a2      	asl	A, #2
    62c2:	7eef      	lod	X, S
    62c4:	20de      	add	X, #-34
    62c6:	4cf8      	movs	YA, A
    62c8:	4c77      	divs	YA, [X]
    62ca:	4c77      	divs	YA, [X]
    62cc:	4c7f      	dadjs	YA, [X]

000062ce <.LM100>:
  bluep = TtoCIE[i].blueyShift + ((line_p * ( ledTemp - TtoCIE[i].Temperature))>>4) ;
    62ce:	7a25      	lod	Y, [S-38]
    62d0:	4871      	muls	A, A, Y
    62d2:	44f2      	asr	A, #2
    62d4:	44f2      	asr	A, #2
    62d6:	a229      	add	A, [S-42]

000062d8 <.LM101>:
  currentBlueCIE[ledIndex].y = fix16_div(fix16_from_int(bluexyY[ledIndex].y+bluep), fix16Const10000);
    62d8:	7a31      	lod	Y, [S-50]
    62da:	e0a2      	add	Y, #-94
    62dc:	a2f0      	add	A, [Y]
    62de:	4cf6      	ssex	YA

000062e0 <.LBB137>:
    62e0:	48ef      	asl	YA, #16

000062e2 <.LBE137>:
    62e2:	54ca 0000 	pushw	#0
    62e6:	54ca 2710 	pushw	#10000

000062ea <.LCFI55>:
    62ea:	11c1      	call	0x666e <_fix16_div>
    62ec:	5225      	mov	[S-38], A

000062ee <.LVL96>:
    62ee:	5a23      	mov	[S-36], Y
    62f0:	7e39      	lod	X, [S-58]
    62f2:	22da ff74 	add	X, #65396
    62f6:	4ca7      	mov	[X], YA

000062f8 <.LBB139>:
*
*@param[in] inArg1  subtractor value.
*
*@retval    Divided fix16_t value.
*/
static __inline fix16_t fix16_sub(fix16_t inArg0, fix16_t inArg1) { return (inArg0 - inArg1); }
    62f8:	724b      	lod	A, [S-76]
    62fa:	7a49      	lod	Y, [S-74]
    62fc:	7e5b      	lod	X, [S-92]
    62fe:	4c37      	sub	YA, [X]
    6300:	5231      	mov	[S-50], A
    6302:	5a2f      	mov	[S-48], Y

00006304 <.LBB143>:
    6304:	7257      	lod	A, [S-88]
    6306:	7a55      	lod	Y, [S-86]
    6308:	aa25      	sub	A, [S-38]
    630a:	fa23      	subc	Y, [S-36]
    630c:	5235      	mov	[S-54], A
    630e:	5a33      	mov	[S-52], Y

00006310 <.LBE143>:

  int32_t duty_R ,duty_G ,duty_B;

  a = fix16_sub(MxyzY->x, currentBlueCIE[ledIndex].x);
  d = fix16_sub(MxyzY->y, currentBlueCIE[ledIndex].y);
  Bm = fix16_div(currentBlueCIE[ledIndex].Y, currentBlueCIE[ledIndex].y);
    6310:	7a43      	lod	Y, [S-68]
    6312:	72f0      	lod	A, [Y]
    6314:	521d      	mov	[S-30], A
    6316:	72f2      	lod	A, [Y+2]
    6318:	521b      	mov	[S-28], A
    631a:	7e25      	lod	X, [S-38]
    631c:	5edf      	push	X

0000631e <.LCFI56>:
    631e:	7e25      	lod	X, [S-38]
    6320:	5edf      	push	X

00006322 <.LCFI57>:
    6322:	7221      	lod	A, [S-34]
    6324:	7a1f      	lod	Y, [S-32]
    6326:	11a3      	call	0x666e <_fix16_div>
    6328:	523d      	mov	[S-62], A
    632a:	5a3b      	mov	[S-60], Y

0000632c <.LM106>:

  b = fix16_sub(currentGreenCIE[ledIndex].y, MxyzY->y);
    632c:	7a41      	lod	Y, [S-66]
    632e:	4cc5      	mov	D, [Y]

00006330 <.LBB145>:
    6330:	4c80      	mov	YA, D
    6332:	aa5b      	sub	A, [S-92]
    6334:	fa59      	subc	Y, [S-90]
    6336:	522d      	mov	[S-46], A
    6338:	5a2b      	mov	[S-44], Y

0000633a <.LBB147>:
    633a:	7a53      	lod	Y, [S-84]
    633c:	72f0      	lod	A, [Y]
    633e:	5229      	mov	[S-42], A

00006340 <.LVL104>:
    6340:	72f2      	lod	A, [Y+2]
    6342:	5227      	mov	[S-40], A
    6344:	7229      	lod	A, [S-42]
    6346:	7a27      	lod	Y, [S-40]
    6348:	aa4f      	sub	A, [S-80]
    634a:	fa4d      	subc	Y, [S-78]
    634c:	5241      	mov	[S-66], A
    634e:	5a3f      	mov	[S-64], Y

00006350 <.LBE147>:
  c = fix16_sub(currentGreenCIE[ledIndex].x, MxyzY->x);
  Gm = fix16_div(currentGreenCIE[ledIndex].Y, currentGreenCIE[ledIndex].y);
    6350:	7a57      	lod	Y, [S-88]
    6352:	72f0      	lod	A, [Y]
    6354:	521d      	mov	[S-30], A
    6356:	72f2      	lod	A, [Y+2]
    6358:	521b      	mov	[S-28], A
    635a:	4c83      	push	D

0000635c <.LCFI58>:
    635c:	7221      	lod	A, [S-34]
    635e:	7a1f      	lod	Y, [S-32]
    6360:	1186      	call	0x666e <_fix16_div>
    6362:	5257      	mov	[S-88], A
    6364:	5a55      	mov	[S-86], Y

00006366 <.LBB149>:
    6366:	7e61      	lod	X, [S-98]
    6368:	4cc7      	mov	D, [X]
    636a:	4c80      	mov	YA, D
    636c:	aa53      	sub	A, [S-84]
    636e:	fa51      	subc	Y, [S-82]
    6370:	5235      	mov	[S-54], A
    6372:	5a33      	mov	[S-52], Y

00006374 <.LBE149>:

  e = fix16_sub(currentRedCIE[ledIndex].x, MxyzY->x);
  f = fix16_sub(currentRedCIE[ledIndex].y, MxyzY->y);
    6374:	7a49      	lod	Y, [S-74]
    6376:	4cc5      	mov	D, [Y]

00006378 <.LBB151>:
    6378:	4c80      	mov	YA, D
    637a:	aa5f      	sub	A, [S-96]
    637c:	fa5d      	subc	Y, [S-94]
    637e:	5249      	mov	[S-74], A

00006380 <.LVL110>:
    6380:	5a47      	mov	[S-72], Y

00006382 <.LBE151>:
  Rm = fix16_div(currentRedCIE[ledIndex].Y, currentRedCIE[ledIndex].y);
    6382:	7a59      	lod	Y, [S-90]
    6384:	72f0      	lod	A, [Y]
    6386:	521d      	mov	[S-30], A
    6388:	72f2      	lod	A, [Y+2]
    638a:	521b      	mov	[S-28], A
    638c:	4c83      	push	D

0000638e <.LCFI59>:
    638e:	7221      	lod	A, [S-34]
    6390:	7a1f      	lod	Y, [S-32]
    6392:	116d      	call	0x666e <_fix16_div>
    6394:	5257      	mov	[S-88], A
    6396:	5a55      	mov	[S-86], Y

00006398 <.LM113>:



  R_all = fix16_mul(a, b);
    6398:	7e35      	lod	X, [S-54]
    639a:	5edf      	push	X

0000639c <.LCFI60>:
    639c:	7e35      	lod	X, [S-54]
    639e:	5edf      	push	X

000063a0 <.LCFI61>:
    63a0:	7241      	lod	A, [S-66]
    63a2:	7a3f      	lod	Y, [S-64]
    63a4:	127c      	call	0x689e <_fix16_mul>
    63a6:	5235      	mov	[S-54], A
    63a8:	5a33      	mov	[S-52], Y

000063aa <.LM114>:
  B_all = fix16_mul(e, b);
    63aa:	7239      	lod	A, [S-58]
    63ac:	5c1f      	dec	S, #32

000063ae <.LCFI62>:
    63ae:	52df      	push	A

000063b0 <.LCFI63>:
    63b0:	7219      	lod	A, [S-26]
    63b2:	52df      	push	A

000063b4 <.LCFI64>:
    63b4:	7221      	lod	A, [S-34]
    63b6:	7a1f      	lod	Y, [S-32]
    63b8:	1272      	call	0x689e <_fix16_mul>
    63ba:	58ad      	mov	[S-30], YA

000063bc <.LM115>:
  G_all = fix16_mul(d, e);
    63bc:	7a21      	lod	Y, [S-34]
    63be:	5adf      	push	Y

000063c0 <.LCFI65>:
    63c0:	7a21      	lod	Y, [S-34]
    63c2:	5adf      	push	Y

000063c4 <.LCFI66>:
    63c4:	722d      	lod	A, [S-46]
    63c6:	7a2b      	lod	Y, [S-44]
    63c8:	126a      	call	0x689e <_fix16_mul>
    63ca:	5225      	mov	[S-38], A

000063cc <.LVL127>:
    63cc:	5a23      	mov	[S-36], Y

000063ce <.LM116>:
  R_all = fix16_sub(R_all, fix16_mul(c, d));
    63ce:	7e2d      	lod	X, [S-46]
    63d0:	5edf      	push	X

000063d2 <.LCFI67>:
    63d2:	7e2d      	lod	X, [S-46]
    63d4:	5edf      	push	X

000063d6 <.LCFI68>:
    63d6:	7239      	lod	A, [S-58]
    63d8:	7a37      	lod	Y, [S-56]
    63da:	1261      	call	0x689e <_fix16_mul>

000063dc <.LBB153>:
    63dc:	7eef      	lod	X, S
    63de:	20de      	add	X, #-34
    63e0:	4cc7      	mov	D, [X]
    63e2:	4c10      	sub	D, YA
    63e4:	4c87      	mov	[X], D

000063e6 <.LBE153>:
  B_all = fix16_sub(B_all, fix16_mul(c, f));
    63e6:	723d      	lod	A, [S-62]
    63e8:	52df      	push	A

000063ea <.LCFI69>:
    63ea:	723d      	lod	A, [S-62]
    63ec:	52df      	push	A

000063ee <.LCFI70>:
    63ee:	723d      	lod	A, [S-62]
    63f0:	7a3b      	lod	Y, [S-60]
    63f2:	1255      	call	0x689e <_fix16_mul>

000063f4 <.LBB155>:
    63f4:	7eef      	lod	X, S
    63f6:	20d6      	add	X, #-42
    63f8:	4cc7      	mov	D, [X]
    63fa:	4c10      	sub	D, YA
    63fc:	4c87      	mov	[X], D

000063fe <.LBE155>:
  G_all = fix16_sub(G_all, fix16_mul(f, a));
    63fe:	7231      	lod	A, [S-50]
    6400:	52df      	push	A

00006402 <.LCFI71>:
    6402:	7231      	lod	A, [S-50]
    6404:	52df      	push	A

00006406 <.LCFI72>:
    6406:	7245      	lod	A, [S-70]
    6408:	7a43      	lod	Y, [S-68]
    640a:	1249      	call	0x689e <_fix16_mul>

0000640c <.LBB157>:
    640c:	7eef      	lod	X, S
    640e:	20ce      	add	X, #-50
    6410:	4cc7      	mov	D, [X]
    6412:	4c10      	sub	D, YA
    6414:	4c87      	mov	[X], D

00006416 <.LBE157>:

  duty_r_aa = Bm;
  duty_g_aa = Rm;
  duty_b_aa = Rm;

  duty_r_aa = fix16_mul(duty_r_aa, Gm);
    6416:	7253      	lod	A, [S-84]
    6418:	52df      	push	A

0000641a <.LCFI73>:
    641a:	7253      	lod	A, [S-84]
    641c:	52df      	push	A

0000641e <.LCFI74>:
    641e:	7241      	lod	A, [S-66]
    6420:	7a3f      	lod	Y, [S-64]
    6422:	123d      	call	0x689e <_fix16_mul>
    6424:	5239      	mov	[S-58], A
    6426:	5a37      	mov	[S-56], Y

00006428 <.LM123>:
  duty_g_aa = fix16_mul(duty_g_aa, Bm);
    6428:	7a41      	lod	Y, [S-66]
    642a:	5adf      	push	Y

0000642c <.LCFI75>:
    642c:	7a41      	lod	Y, [S-66]
    642e:	5adf      	push	Y

00006430 <.LCFI76>:
    6430:	7257      	lod	A, [S-88]
    6432:	7a55      	lod	Y, [S-86]
    6434:	1234      	call	0x689e <_fix16_mul>
    6436:	5241      	mov	[S-66], A

00006438 <.LVL148>:
    6438:	5a3f      	mov	[S-64], Y

0000643a <.LM124>:
  duty_b_aa = fix16_mul(duty_b_aa, Gm);
    643a:	7e5b      	lod	X, [S-92]
    643c:	5edf      	push	X

0000643e <.LCFI77>:
    643e:	7e5b      	lod	X, [S-92]
    6440:	5edf      	push	X

00006442 <.LCFI78>:
    6442:	725b      	lod	A, [S-92]
    6444:	7a59      	lod	Y, [S-90]
    6446:	122b      	call	0x689e <_fix16_mul>
    6448:	5249      	mov	[S-74], A
    644a:	5a47      	mov	[S-72], Y

0000644c <.LM125>:
  duty_r_aa = fix16_mul(duty_r_aa, R_all);
    644c:	7235      	lod	A, [S-54]
    644e:	5c1f      	dec	S, #32

00006450 <.LCFI79>:
    6450:	52df      	push	A

00006452 <.LCFI80>:
    6452:	7215      	lod	A, [S-22]
    6454:	52df      	push	A

00006456 <.LCFI81>:
    6456:	7225      	lod	A, [S-38]
    6458:	7a23      	lod	Y, [S-36]
    645a:	1221      	call	0x689e <_fix16_mul>
    645c:	5225      	mov	[S-38], A
    645e:	5a23      	mov	[S-36], Y

00006460 <.LM126>:
  duty_g_aa = fix16_mul(duty_g_aa, G_all);
    6460:	7a21      	lod	Y, [S-34]
    6462:	5adf      	push	Y

00006464 <.LCFI82>:
    6464:	7a21      	lod	Y, [S-34]
    6466:	5adf      	push	Y

00006468 <.LCFI83>:
    6468:	722d      	lod	A, [S-46]
    646a:	7a2b      	lod	Y, [S-44]
    646c:	1218      	call	0x689e <_fix16_mul>
    646e:	5225      	mov	[S-38], A

00006470 <.LVL162>:
    6470:	5a23      	mov	[S-36], Y

00006472 <.LM127>:
  duty_b_aa = fix16_mul(duty_b_aa, B_all);
    6472:	7e21      	lod	X, [S-34]
    6474:	5edf      	push	X

00006476 <.LCFI84>:
    6476:	7e21      	lod	X, [S-34]
    6478:	5edf      	push	X

0000647a <.LCFI85>:
    647a:	7235      	lod	A, [S-54]
    647c:	7a33      	lod	Y, [S-52]
    647e:	120f      	call	0x689e <_fix16_mul>
    6480:	5231      	mov	[S-50], A
    6482:	5a2f      	mov	[S-48], Y

00006484 <.LM128>:

  /*temperature protection use this(tempAdjust) parameter to control LED intensity.*/
  /*Minimum is 0, maximum is 6400, so we divide 6400.*/
  mix_Y = fix16_mul(MxyzY->Y, fix16_from_int((int32_t)inputColor->tempAdjust[ledIndex]/2));
    6484:	7a41      	lod	Y, [S-66]
    6486:	e016      	add	Y, #22
    6488:	72f0      	lod	A, [Y]
    648a:	4432      	lsr	A
    648c:	4cf2      	usex	YA

0000648e <.LBB159>:
*
*@param[in] a  int32 value wants to transfer.
*
*@retval    fix16_t value.
*/
static __inline fix16_t fix16_from_int(int32_t a)     { return a * fix16_one; }
    648e:	48ef      	asl	YA, #16

00006490 <.LBE159>:
    6490:	4ca3      	push	YA

00006492 <.LCFI86>:
    6492:	725f      	lod	A, [S-96]
    6494:	7a5d      	lod	Y, [S-94]
    6496:	1203      	call	0x689e <_fix16_mul>

00006498 <.LM131>:
  /*0.01 = 1/100, mix_Y =  mix_Y /100, for more calculating speed, we convert divide to multiply*/
  mix_Y = fix16_mul(mix_Y, F16(0.02));
    6498:	54ca 051f 	pushw	#1311
    649c:	54ca 0000 	pushw	#0

000064a0 <.LCFI87>:
    64a0:	11fe      	call	0x689e <_fix16_mul>

000064a2 <.LM132>:
  /*0.015625 = 1/64, mix_Y =  mix_Y /64, for more calculating speed, we convert divide to multiply*/
  mix_Y = fix16_mul(mix_Y, F16(0.015625));
    64a2:	54ca 0400 	pushw	#1024
    64a6:	54ca 0000 	pushw	#0

000064aa <.LCFI88>:
    64aa:	11f9      	call	0x689e <_fix16_mul>

000064ac <.LVL173>:
    64ac:	5231      	mov	[S-50], A

000064ae <.LVL174>:
    64ae:	5a2f      	mov	[S-48], Y

000064b0 <.LM133>:

  fix16_t temp = fix16_add(fix16_mul(currentRedCIE[ledIndex].Y, duty_r_aa),
    64b0:	7e5b      	lod	X, [S-92]
    64b2:	4ce7      	mov	YA, [X]
    64b4:	7e35      	lod	X, [S-54]
    64b6:	5edf      	push	X

000064b8 <.LCFI89>:
    64b8:	7e35      	lod	X, [S-54]
    64ba:	5edf      	push	X

000064bc <.LCFI90>:
    64bc:	11f0      	call	0x689e <_fix16_mul>
    64be:	5231      	mov	[S-50], A

000064c0 <.LVL179>:
    64c0:	5a2f      	mov	[S-48], Y
    64c2:	7e5d      	lod	X, [S-94]
    64c4:	4ce7      	mov	YA, [X]
    64c6:	7e3d      	lod	X, [S-62]
    64c8:	5edf      	push	X

000064ca <.LCFI91>:
    64ca:	7e3d      	lod	X, [S-62]
    64cc:	5edf      	push	X

000064ce <.LCFI92>:
    64ce:	11e7      	call	0x689e <_fix16_mul>

000064d0 <.LBB161>:
*
*@param[in] inArg1  add value.
*
*@retval    Added fix16_t value.
*/
static __inline fix16_t fix16_add(fix16_t inArg0, fix16_t inArg1) { return (inArg0 + inArg1); }
    64d0:	a235      	add	A, [S-54]

000064d2 <.LVL183>:
    64d2:	f233      	adc	Y, [S-52]
    64d4:	5235      	mov	[S-54], A
    64d6:	5a33      	mov	[S-52], Y

000064d8 <.LBE161>:
                           fix16_mul(currentGreenCIE[ledIndex].Y, duty_g_aa));

  temp = fix16_add(temp, fix16_mul(currentBlueCIE[ledIndex].Y, duty_b_aa));
    64d8:	5c1f      	dec	S, #32

000064da <.LCFI93>:
    64da:	7e33      	lod	X, [S-52]
    64dc:	4ce7      	mov	YA, [X]
    64de:	7e25      	lod	X, [S-38]
    64e0:	5edf      	push	X

000064e2 <.LCFI94>:
    64e2:	7e25      	lod	X, [S-38]
    64e4:	5edf      	push	X

000064e6 <.LCFI95>:
    64e6:	11db      	call	0x689e <_fix16_mul>

000064e8 <.LBB163>:
    64e8:	a219      	add	A, [S-26]
    64ea:	f217      	adc	Y, [S-24]

000064ec <.LBE163>:
  temp = fix16_div(mix_Y, temp);
    64ec:	4ca3      	push	YA

000064ee <.LCFI96>:
    64ee:	7221      	lod	A, [S-34]
    64f0:	7a1f      	lod	Y, [S-32]
    64f2:	10bd      	call	0x666e <_fix16_div>
    64f4:	58ad      	mov	[S-30], YA

000064f6 <.LM138>:

  duty_r_aa = fix16_mul(duty_r_aa, temp);
    64f6:	721d      	lod	A, [S-30]
    64f8:	52df      	push	A

000064fa <.LCFI97>:
    64fa:	721d      	lod	A, [S-30]
    64fc:	52df      	push	A

000064fe <.LCFI98>:
    64fe:	722d      	lod	A, [S-46]
    6500:	7a2b      	lod	Y, [S-44]
    6502:	11cd      	call	0x689e <_fix16_mul>

00006504 <.LM139>:
  duty_r_aa = fix16_mul(duty_r_aa, F16(32767));
    6504:	54ca 0000 	pushw	#0
    6508:	54ca 7fff 	pushw	#32767

0000650c <.LCFI99>:
    650c:	11c8      	call	0x689e <_fix16_mul>

0000650e <.LVL194>:
    650e:	5229      	mov	[S-42], A
    6510:	5a27      	mov	[S-40], Y

00006512 <.LM140>:
  //duty_r_aa = fix16_mul(duty_r_aa, fix16ConstPWM);
  duty_g_aa = fix16_mul(duty_g_aa, temp);
    6512:	7a25      	lod	Y, [S-38]
    6514:	5adf      	push	Y

00006516 <.LCFI100>:
    6516:	7a25      	lod	Y, [S-38]
    6518:	5adf      	push	Y

0000651a <.LCFI101>:
    651a:	7231      	lod	A, [S-50]
    651c:	7a2f      	lod	Y, [S-48]
    651e:	11bf      	call	0x689e <_fix16_mul>

00006520 <.LM141>:
  duty_g_aa = fix16_mul(duty_g_aa, F16(32767));
    6520:	54ca 0000 	pushw	#0
    6524:	54ca 7fff 	pushw	#32767

00006528 <.LCFI102>:
    6528:	11ba      	call	0x689e <_fix16_mul>

0000652a <.LVL200>:
    652a:	5235      	mov	[S-54], A
    652c:	5a33      	mov	[S-52], Y

0000652e <.LM142>:
  //duty_g_aa = fix16_mul(duty_g_aa, fix16ConstPWM);
  duty_b_aa = fix16_mul(duty_b_aa, temp);
    652e:	7e2d      	lod	X, [S-46]
    6530:	5edf      	push	X

00006532 <.LCFI103>:
    6532:	7e2d      	lod	X, [S-46]
    6534:	5edf      	push	X

00006536 <.LCFI104>:
    6536:	7241      	lod	A, [S-66]
    6538:	7a3f      	lod	Y, [S-64]
    653a:	11b1      	call	0x689e <_fix16_mul>

0000653c <.LM143>:
  duty_b_aa = fix16_mul(duty_b_aa, F16(32767));
    653c:	54ca 0000 	pushw	#0
    6540:	54ca 7fff 	pushw	#32767

00006544 <.LCFI105>:
    6544:	11ac      	call	0x689e <_fix16_mul>

00006546 <.LVL206>:
    6546:	5235      	mov	[S-54], A
    6548:	5a33      	mov	[S-52], Y

0000654a <.LBB165>:
static __inline int fix16_to_int(fix16_t a)
{
#ifdef FIXMATH_NO_ROUNDING
    return (a >> 16);
#else
        if (a >= 0)
    654a:	5c1f      	dec	S, #32

0000654c <.LCFI106>:
    654c:	58cb      	mov	D, [S-26]
    654e:	4caa 0000 	cmpu	D, #0
    6552:	1e81      	jsge	0x6556 <.LM145>
    6554:	0063      	jmp	0x661c <.L13>

00006556 <.LM145>:
                return (a + (fix16_one >> 1)) / fix16_one;
    6556:	4ce2 8000 	mov	YA, #32768
    655a:	0000 
    655c:	a219      	add	A, [S-26]
    655e:	f217      	adc	Y, [S-24]
    6560:	5a19      	mov	[S-26], Y

00006562 <.L14>:
  //duty_b_aa = fix16_mul(duty_b_aa, fix16ConstPWM);

  duty_R = fix16_to_int(duty_r_aa);
    6562:	7219      	lod	A, [S-26]
    6564:	4cf6      	ssex	YA
    6566:	58ab      	mov	[S-26], YA

00006568 <.LBB168>:
static __inline int fix16_to_int(fix16_t a)
{
#ifdef FIXMATH_NO_ROUNDING
    return (a >> 16);
#else
        if (a >= 0)
    6568:	58cd      	mov	D, [S-30]
    656a:	4caa 0000 	cmpu	D, #0
    656e:	1e81      	jsge	0x6572 <.LM148>
    6570:	0063      	jmp	0x6638 <.L15>

00006572 <.LM148>:
                return (a + (fix16_one >> 1)) / fix16_one;
    6572:	4ce2 8000 	mov	YA, #32768
    6576:	0000 

00006578 <.LVL211>:
    6578:	a21d      	add	A, [S-30]
    657a:	f21b      	adc	Y, [S-28]
    657c:	5a1d      	mov	[S-30], Y

0000657e <.L16>:
  duty_G = fix16_to_int(duty_g_aa);
    657e:	721d      	lod	A, [S-30]
    6580:	4cf6      	ssex	YA
    6582:	58ad      	mov	[S-30], YA

00006584 <.LBB171>:
static __inline int fix16_to_int(fix16_t a)
{
#ifdef FIXMATH_NO_ROUNDING
    return (a >> 16);
#else
        if (a >= 0)
    6584:	58c9      	mov	D, [S-22]
    6586:	4caa 0000 	cmpu	D, #0
    658a:	1e81      	jsge	0x658e <.LM151>
    658c:	0063      	jmp	0x6654 <.L17>

0000658e <.LM151>:
                return (a + (fix16_one >> 1)) / fix16_one;
    658e:	4ce2 8000 	mov	YA, #32768
    6592:	0000 

00006594 <.LVL214>:
    6594:	a215      	add	A, [S-22]
    6596:	f213      	adc	Y, [S-20]
    6598:	72e6      	lod	A, Y

0000659a <.L18>:
  duty_B = fix16_to_int(duty_b_aa);
    659a:	4cd8      	movs	D, A
    659c:	7a53      	lod	Y, [S-84]
    659e:	e237      	add	Y, [S-56]
    65a0:	5a15      	mov	[S-22], Y

000065a2 <.LM153>:

//  duty_R = duty_R<<1;
//  duty_G = duty_G<<1;
//  duty_B = duty_B<<1;

  outputPWM->PWM_R[ledIndex] = (uint16_t)duty_R;
    65a2:	7ee6      	lod	X, Y
    65a4:	20e8      	add	X, #-24
    65a6:	58eb      	mov	YA, [S-26]
    65a8:	4cb2 0000 	cmp	YA, #0
    65ac:	0000 
    65ae:	1e83      	jsge	0x65b6 <.L19>
    65b0:	4ce2 0000 	mov	YA, #0
    65b4:	0000 

000065b6 <.L19>:
    65b6:	52f8      	mov	[X], A

000065b8 <.LM154>:
  outputPWM->PWM_G[ledIndex] = (uint16_t)duty_G;
    65b8:	7e15      	lod	X, [S-22]
    65ba:	20f4      	add	X, #-12
    65bc:	58ed      	mov	YA, [S-30]
    65be:	4cb2 0000 	cmp	YA, #0
    65c2:	0000 
    65c4:	1e83      	jsge	0x65cc <.L20>
    65c6:	4ce2 0000 	mov	YA, #0
    65ca:	0000 

000065cc <.L20>:
    65cc:	52f8      	mov	[X], A

000065ce <.LM155>:
  outputPWM->PWM_B[ledIndex] = (uint16_t)duty_B;
    65ce:	4c80      	mov	YA, D
    65d0:	4cb2 0000 	cmp	YA, #0
    65d4:	0000 
    65d6:	1e83      	jsge	0x65de <.L21>
    65d8:	4ce2 0000 	mov	YA, #0
    65dc:	0000 

000065de <.L21>:
    65de:	7e15      	lod	X, [S-22]
    65e0:	52f8      	mov	[X], A

000065e2 <.L5>:
    65e2:	7237      	lod	A, [S-56]
    65e4:	a002      	add	A, #2
    65e6:	5237      	mov	[S-56], A

000065e8 <.LBE139>:
    outputPWM->PWM_R[index] = 0;
    outputPWM->PWM_G[index] = 0;
    outputPWM->PWM_B[index] = 0;
  }

  for (index = 0; index < RGBLEDMAX; index++)
    65e8:	ac24      	cmp	A, #36
    65ea:	1901      	je	0x65ee <.LM157>
    65ec:	040e      	jmp	0x5e0a <.L22>

000065ee <.LM157>:
    /*and current LED attributes, generate PWM*/
    __algoGetDutyRatio(index, inputColor, &targetColor, outputPWM);
  }

  return btrue;
}
    65ee:	7001      	lod	A, #1
    65f0:	5451      	ret	#82

000065f2 <.L6>:
		tempValue = (uint32_t)((inputColor->colorU[index] - 76)) * (565 - 114) / (uint32_t)(203 - 76);
		VDownLimit = 565 - (uint16_t)tempValue - 15;
	}
	else
	{
		tempValue = (uint32_t)(inputColor->colorU[index] - 203) * (517 - 114) / (uint32_t)(529 - 203);
    65f2:	7215      	lod	A, [S-22]
    65f4:	a2da ff35 	add	A, #65333
    65f8:	4822 0193 	mulu	YA, A, #403
    65fc:	54ca 0146 	pushw	#326
    6600:	54ca 0000 	pushw	#0

00006604 <.LCFI107>:
    6604:	82db 2e68 	callf	0x5cd0 <___udivsi3>

00006608 <.LVL222>:
    6608:	5c03      	dec	S, #4

0000660a <.LCFI108>:
		VDownLimit = 114 + (uint16_t)tempValue - 15;
    660a:	a063      	add	A, #99

0000660c <.LVL224>:
    660c:	0437      	jmp	0x5e7c <.L7>

0000660e <.L8>:
  targetColor->x = fix16_mul(fix16_from_int(tempu), fix16ConstM);
  targetColor->y = fix16_mul(fix16_from_int(tempv), fix16ConstM);

  templ = (uint32_t)inputColor->intensity[ledIndex]*(uint32_t)15625/(uint32_t)4000;
  if (templ < 39)
	  templ = 39;
    660e:	7c27      	lod	X, #39
    6610:	5ed8 133a 	mov	0x133a <_templ>, X
    6614:	7c00      	lod	X, #0
    6616:	5ed8 133c 	mov	0x133c <_templ+0x2>, X
    661a:	048d      	jmp	0x5f36 <.L9>

0000661c <.L13>:
        return (a - (fix16_one >> 1)) / fix16_one;
    661c:	4ce2 8000 	mov	YA, #-32768
    6620:	ffff 
    6622:	a219      	add	A, [S-26]
    6624:	f217      	adc	Y, [S-24]
    6626:	54ca 0000 	pushw	#0
    662a:	54ca 0001 	pushw	#1

0000662e <.LCFI109>:
    662e:	82db 2e33 	callf	0x5c66 <___divsi3>
    6632:	5c03      	dec	S, #4

00006634 <.LCFI110>:
    6634:	5219      	mov	[S-26], A
    6636:	0795      	jmp	0x6562 <.L14>

00006638 <.L15>:
    6638:	4ce2 8000 	mov	YA, #-32768
    663c:	ffff 

0000663e <.LVL231>:
    663e:	a21d      	add	A, [S-30]
    6640:	f21b      	adc	Y, [S-28]
    6642:	54ca 0000 	pushw	#0
    6646:	54ca 0001 	pushw	#1

0000664a <.LCFI111>:
    664a:	82db 2e33 	callf	0x5c66 <___divsi3>

0000664e <.LVL233>:
    664e:	5c03      	dec	S, #4

00006650 <.LCFI112>:
    6650:	521d      	mov	[S-30], A

00006652 <.LVL235>:
    6652:	0795      	jmp	0x657e <.L16>

00006654 <.L17>:
    6654:	4ce2 8000 	mov	YA, #-32768
    6658:	ffff 

0000665a <.LVL237>:
    665a:	a215      	add	A, [S-22]
    665c:	f213      	adc	Y, [S-20]
    665e:	54ca 0000 	pushw	#0
    6662:	54ca 0001 	pushw	#1

00006666 <.LCFI113>:
    6666:	82db 2e33 	callf	0x5c66 <___divsi3>

0000666a <.LVL239>:
    666a:	5c03      	dec	S, #4

0000666c <.LCFI114>:
    666c:	0796      	jmp	0x659a <.L18>

0000666e <_fix16_div>:
  while (!(x & 0x80000000)) { result += 1; x <<= 1; }
  return result;
}

fix16_t fix16_div(fix16_t a, fix16_t b)
{
    666e:	5835      	inc	S, #54

00006670 <.LCFI0>:
    6670:	5225      	mov	[S-38], A
    6672:	5a23      	mov	[S-36], Y

00006674 <.LM2>:
  uint32_t remainder = (a >= 0) ? a : (-a);
    6674:	58a3      	mov	[S-10], YA
    6676:	72ef      	lod	A, S

00006678 <.LVL1>:
    6678:	a0da      	add	A, #-38

0000667a <.LVL2>:
    667a:	4cf3      	swap	YA
    667c:	4cc5      	mov	D, [Y]
    667e:	4caa 0000 	cmpu	D, #0
    6682:	1e87      	jsge	0x6692 <.L2>
    6684:	4cc2 0000 	mov	D, #0
    6688:	0000 
    668a:	4c80      	mov	YA, D
    668c:	aa25      	sub	A, [S-38]
    668e:	fa23      	subc	Y, [S-36]
    6690:	58a3      	mov	[S-10], YA

00006692 <.L2>:
    6692:	58e3      	mov	YA, [S-10]
    6694:	58a1      	mov	[S-6], YA

00006696 <.LM3>:
  uint32_t divider = (b >= 0) ? b : (-b);
    6696:	723b      	lod	A, [S-60]
    6698:	7a39      	lod	Y, [S-58]
    669a:	4cc0      	mov	D, YA
    669c:	4caa 0000 	cmpu	D, #0
    66a0:	1e85      	jsge	0x66ac <.L3>
    66a2:	4ce2 0000 	mov	YA, #0
    66a6:	0000 
    66a8:	aa3b      	sub	A, [S-60]
    66aa:	fa39      	subc	Y, [S-58]

000066ac <.L3>:
    66ac:	58ad      	mov	[S-30], YA

000066ae <.LM4>:
  uint32_t quotient = 0;
  int bit_pos = 17;

  // This uses a hardware 32/32 bit division multiple times, until we have
  // computed all the bits in (a<<17)/b. Usually this takes 1-3 iterations.
  if (b == 0)
    66ae:	72ef      	lod	A, S

000066b0 <.LVL6>:
    66b0:	a0c4      	add	A, #-60

000066b2 <.LVL7>:
    66b2:	4cf3      	swap	YA
    66b4:	4cc5      	mov	D, [Y]
    66b6:	4caa 0000 	cmpu	D, #0
    66ba:	1d01      	jne	0x66be <.LM5>
    66bc:	00e4      	jmp	0x6886 <.L16>

000066be <.LM5>:
	  return fix16_minimum;

  // Kick-start the division a bit.
  // This improves speed in the worst-case scenarios where N and D are large
  // It gets a lower estimate for the result by N/(D >> 17 + 1).
  if (divider & 0xFFF00000)
    66be:	58ed      	mov	YA, [S-30]
    66c0:	7000      	lod	A, #0
    66c2:	f4f0      	and	Y, #-16
    66c4:	4cb2 0000 	cmp	YA, #0
    66c8:	0000 
    66ca:	1d01      	jne	0x66ce <.LBB6>
    66cc:	006c      	jmp	0x67a6 <.L17>

000066ce <.LBB6>:
  {
    uint32_t shifted_div = ((divider >> 17) + 1);
    66ce:	58ed      	mov	YA, [S-30]
    66d0:	48af      	lsr	YA, #16
    66d2:	48a0      	lsr	YA, #1
    66d4:	4c22 0001 	add	YA, #1
    66d8:	0000 

000066da <.LM7>:
    quotient = remainder / shifted_div;
    66da:	4ca3      	push	YA

000066dc <.LCFI1>:
    66dc:	58e5      	mov	YA, [S-14]

000066de <.LVL11>:
    66de:	82db 2e68 	callf	0x5cd0 <___udivsi3>

000066e2 <.LVL12>:
    66e2:	5c03      	dec	S, #4

000066e4 <.LCFI2>:
    66e4:	5221      	mov	[S-34], A
    66e6:	5a1f      	mov	[S-32], Y

000066e8 <.LM8>:
    remainder -= ((uint64_t)quotient * divider) >> 17;
    66e8:	7221      	lod	A, [S-34]
    66ea:	7a1f      	lod	Y, [S-32]
    66ec:	58a7      	mov	[S-18], YA
    66ee:	7800      	lod	Y, #0
    66f0:	5a0d      	mov	[S-14], Y
    66f2:	5a0b      	mov	[S-12], Y
    66f4:	58ed      	mov	YA, [S-30]
    66f6:	58ab      	mov	[S-26], YA
    66f8:	7800      	lod	Y, #0
    66fa:	5a15      	mov	[S-22], Y
    66fc:	5a13      	mov	[S-20], Y
    66fe:	7e19      	lod	X, [S-26]
    6700:	5edf      	push	X

00006702 <.LCFI3>:
    6702:	7e19      	lod	X, [S-26]
    6704:	5edf      	push	X

00006706 <.LCFI4>:
    6706:	7e19      	lod	X, [S-26]
    6708:	5edf      	push	X

0000670a <.LCFI5>:
    670a:	7e19      	lod	X, [S-26]
    670c:	5edf      	push	X

0000670e <.LCFI6>:
    670e:	7219      	lod	A, [S-26]
    6710:	52df      	push	A

00006712 <.LCFI7>:
    6712:	7219      	lod	A, [S-26]
    6714:	52df      	push	A

00006716 <.LCFI8>:
    6716:	7219      	lod	A, [S-26]
    6718:	52df      	push	A

0000671a <.LCFI9>:
    671a:	7219      	lod	A, [S-26]
    671c:	52df      	push	A

0000671e <.LCFI10>:
    671e:	7eef      	lod	X, S
    6720:	20ba      	add	X, #-70
    6722:	82db 2dea 	callf	0x5bd4 <___mlx_umuldi3>
    6726:	5c0f      	dec	S, #16

00006728 <.LCFI11>:
    6728:	54ca 0011 	pushw	#17

0000672c <.LCFI12>:
    672c:	7a37      	lod	Y, [S-56]
    672e:	5adf      	push	Y

00006730 <.LCFI13>:
    6730:	7a37      	lod	Y, [S-56]
    6732:	5adf      	push	Y

00006734 <.LCFI14>:
    6734:	7a37      	lod	Y, [S-56]
    6736:	5adf      	push	Y

00006738 <.LCFI15>:
    6738:	7a37      	lod	Y, [S-56]
    673a:	5adf      	push	Y

0000673c <.LCFI16>:
    673c:	7eef      	lod	X, S
    673e:	20c8      	add	X, #-56
    6740:	82db 2e22 	callf	0x5c44 <___mlx_lshrdi3>
    6744:	5c09      	dec	S, #10

00006746 <.LCFI17>:
    6746:	58e3      	mov	YA, [S-10]
    6748:	aa2d      	sub	A, [S-46]
    674a:	fa2b      	subc	Y, [S-44]
    674c:	58a1      	mov	[S-6], YA

0000674e <.L5>:

fix16_t fix16_div(fix16_t a, fix16_t b)
{
  uint32_t remainder = (a >= 0) ? a : (-a);
  uint32_t divider = (b >= 0) ? b : (-b);
  uint32_t quotient = 0;
    674e:	7c11      	lod	X, #17
    6750:	5e09      	mov	[S-10], X
    6752:	7c05      	lod	X, #5

00006754 <.L6>:
    quotient = remainder / shifted_div;
    remainder -= ((uint64_t)quotient * divider) >> 17;
  }

  // If the divider is divisible by 2^n, take advantage of it.
  while (!(divider & 0xF) && bit_pos >= 4)
    6754:	58ed      	mov	YA, [S-30]
    6756:	b40f      	and	A, #15
    6758:	7800      	lod	Y, #0
    675a:	4cb2 0000 	cmp	YA, #0
    675e:	0000 
    6760:	1d01      	jne	0x6764 <.L9>

00006762 <.LM11>:
    6762:	1ba4      	djnz	X, 0x67ac <.L8>

00006764 <.L9>:
  {
    divider >>= 4;
    bit_pos -= 4;
  }

  while (remainder && bit_pos >= 0)
    6764:	58c1      	mov	D, [S-6]
    6766:	4caa 0000 	cmpu	D, #0
    676a:	1903      	je	0x6772 <.L14>

0000676c <.LM13>:
    676c:	7e09      	lod	X, [S-10]
    676e:	1981      	jn	0x6772 <.L14>
    6770:	007d      	jmp	0x686c <.L19>

00006772 <.L14>:
    bit_pos--;
  }

  #ifndef FIXMATH_NO_ROUNDING
  // Quotient is always positive so rounding is easy
  quotient++;
    6772:	72ef      	lod	A, S
    6774:	a0de      	add	A, #-34
    6776:	4cf3      	swap	YA
    6778:	4cc5      	mov	D, [Y]
    677a:	4c02 0001 	add	D, #1
    677e:	0000 

00006780 <.LM15>:
  #endif

  fix16_t result = quotient >> 1;
    6780:	4c80      	mov	YA, D
    6782:	48a0      	lsr	YA, #1
    6784:	58a3      	mov	[S-10], YA

00006786 <.LM16>:

  // Figure out the sign of the result
  if ((a ^ b) & 0x80000000)
    6786:	7225      	lod	A, [S-38]

00006788 <.LVL39>:
    6788:	7a23      	lod	Y, [S-36]
    678a:	be3b      	xor	A, [S-60]
    678c:	fe39      	xor	Y, [S-58]
    678e:	4cc0      	mov	D, YA
    6790:	4caa 0000 	cmpu	D, #0
    6794:	1e86      	jsge	0x67a2 <.L1>

00006796 <.LM17>:
    #ifndef FIXMATH_NO_OVERFLOW
    if (result == fix16_minimum)
                    return fix16_overflow;
    #endif

    result = -result;
    6796:	4ce2 0000 	mov	YA, #0
    679a:	0000 
    679c:	aa09      	sub	A, [S-10]
    679e:	fa07      	subc	Y, [S-8]
    67a0:	58a3      	mov	[S-10], YA

000067a2 <.L1>:
  }

  return result;
}
    67a2:	58e3      	mov	YA, [S-10]
    67a4:	5437      	ret	#56

000067a6 <.L17>:

fix16_t fix16_div(fix16_t a, fix16_t b)
{
  uint32_t remainder = (a >= 0) ? a : (-a);
  uint32_t divider = (b >= 0) ? b : (-b);
  uint32_t quotient = 0;
    67a6:	5221      	mov	[S-34], A
    67a8:	5a1f      	mov	[S-32], Y
    67aa:	07d1      	jmp	0x674e <.L5>

000067ac <.L8>:
  }

  // If the divider is divisible by 2^n, take advantage of it.
  while (!(divider & 0xF) && bit_pos >= 4)
  {
    divider >>= 4;
    67ac:	58ed      	mov	YA, [S-30]
    67ae:	48a3      	lsr	YA, #4
    67b0:	58ad      	mov	[S-30], YA

000067b2 <.LM21>:
    bit_pos -= 4;
    67b2:	7a09      	lod	Y, [S-10]
    67b4:	e0fc      	add	Y, #-4
    67b6:	5a09      	mov	[S-10], Y

000067b8 <.LVL44>:
    67b8:	07cd      	jmp	0x6754 <.L6>

000067ba <.L10>:
 */
static uint8_t clz(uint32_t x)
{
  uint8_t result = 0;
  if (x == 0) return 32;
  while (!(x & 0xF0000000)) { result += 4; x <<= 4; }
    67ba:	6201      	lod	AL, [S-2]
    67bc:	8004      	add	AL, #4
    67be:	5cf2      	usex	A
    67c0:	5201      	mov	[S-2], A

000067c2 <.LVL46>:
    67c2:	58e7      	mov	YA, [S-18]

000067c4 <.LVL47>:
    67c4:	48e3      	asl	YA, #4
    67c6:	58a7      	mov	[S-18], YA

000067c8 <.L15>:
    67c8:	58e7      	mov	YA, [S-18]
    67ca:	7000      	lod	A, #0
    67cc:	f6da f000 	and	Y, #61440
    67d0:	58ab      	mov	[S-26], YA
    67d2:	4cc0      	mov	D, YA
    67d4:	4caa 0000 	cmpu	D, #0
    67d8:	1970      	je	0x67ba <.L10>

000067da <.L11>:
  while (!(x & 0x80000000)) { result += 1; x <<= 1; }
    67da:	58c7      	mov	D, [S-18]
    67dc:	4caa 0000 	cmpu	D, #0
    67e0:	1a81      	jsl	0x67e4 <.LVL50>
    67e2:	0049      	jmp	0x6876 <.L12>

000067e4 <.LVL50>:
    67e4:	7e09      	lod	X, [S-10]

000067e6 <.LVL51>:
    67e6:	2e01      	cmp	X, [S-2]
    67e8:	1b01      	jsle	0x67ec <.L13>
    67ea:	7e01      	lod	X, [S-2]

000067ec <.L13>:
  while (remainder && bit_pos >= 0)
  {
    // Shift remainder as much as we can without overflowing
    int shift = clz(remainder);
    if (shift > bit_pos) shift = bit_pos;
    remainder <<= shift;
    67ec:	58e1      	mov	YA, [S-6]
    67ee:	2c00      	cmp	X, #0
    67f0:	1b04      	jsle	0x67fa <.L23>
    67f2:	5edf      	push	X

000067f4 <.L24>:
    67f4:	48e0      	asl	YA, #1
    67f6:	1bfe      	djnz	X, 0x67f4 <.L24>
    67f8:	7ecf      	pop	X

000067fa <.L23>:
    67fa:	58a7      	mov	[S-18], YA

000067fc <.LM25>:
    bit_pos -= shift;
    67fc:	7a09      	lod	Y, [S-10]
    67fe:	eaee      	sub	Y, X
    6800:	5a09      	mov	[S-10], Y

00006802 <.LM26>:

    uint32_t div = remainder / divider;
    6802:	7e1d      	lod	X, [S-30]

00006804 <.LVL55>:
    6804:	5edf      	push	X

00006806 <.LCFI18>:
    6806:	7e1d      	lod	X, [S-30]
    6808:	5edf      	push	X

0000680a <.LCFI19>:
    680a:	58e9      	mov	YA, [S-22]

0000680c <.LVL58>:
    680c:	82db 2e68 	callf	0x5cd0 <___udivsi3>

00006810 <.LVL59>:
    6810:	5c03      	dec	S, #4

00006812 <.LCFI20>:
    6812:	58ab      	mov	[S-26], YA

00006814 <.LM27>:
    remainder = remainder % divider;
    6814:	721d      	lod	A, [S-30]

00006816 <.LVL62>:
    6816:	52df      	push	A

00006818 <.LCFI21>:
    6818:	721d      	lod	A, [S-30]
    681a:	52df      	push	A

0000681c <.LCFI22>:
    681c:	58e9      	mov	YA, [S-22]
    681e:	82db 2e6a 	callf	0x5cd4 <___umodsi3>
    6822:	5c03      	dec	S, #4

00006824 <.LCFI23>:
    6824:	58a7      	mov	[S-18], YA

00006826 <.LM28>:
    quotient += div << bit_pos;
    6826:	58eb      	mov	YA, [S-26]

00006828 <.LVL68>:
    6828:	7e09      	lod	X, [S-10]
    682a:	2c00      	cmp	X, #0
    682c:	1b02      	jsle	0x6832 <.L25>

0000682e <.L26>:
    682e:	48e0      	asl	YA, #1
    6830:	1bfe      	djnz	X, 0x682e <.L26>

00006832 <.L25>:
    6832:	7eef      	lod	X, S
    6834:	20de      	add	X, #-34
    6836:	4cc7      	mov	D, [X]
    6838:	4c00      	add	D, YA
    683a:	4c87      	mov	[X], D

0000683c <.LM29>:

    #ifndef FIXMATH_NO_OVERFLOW
    if (div & ~(0xFFFFFFFF >> bit_pos))
    683c:	4ce2 ffff 	mov	YA, #-1
    6840:	ffff 
    6842:	7e09      	lod	X, [S-10]
    6844:	2c00      	cmp	X, #0
    6846:	1b04      	jsle	0x6850 <.L27>
    6848:	5edf      	push	X

0000684a <.L28>:
    684a:	48a0      	lsr	YA, #1
    684c:	1bfe      	djnz	X, 0x684a <.L28>
    684e:	7ecf      	pop	X

00006850 <.L27>:
    6850:	bcff      	xor	A, #-1
    6852:	fcff      	xor	Y, #-1
    6854:	b619      	and	A, [S-26]
    6856:	f617      	and	Y, [S-24]
    6858:	4cb2 0000 	cmp	YA, #0
    685c:	0000 
    685e:	1d19      	jne	0x6892 <.L18>

00006860 <.LM30>:
                    return fix16_overflow;
    #endif

    remainder <<= 1;
    6860:	58e7      	mov	YA, [S-18]
    6862:	48e0      	asl	YA, #1
    6864:	58a1      	mov	[S-6], YA

00006866 <.LM31>:
    bit_pos--;
    6866:	20ff      	add	X, #-1

00006868 <.LVL72>:
    6868:	5e09      	mov	[S-10], X

0000686a <.LVL73>:
    686a:	077c      	jmp	0x6764 <.L9>

0000686c <.L19>:
    686c:	58e1      	mov	YA, [S-6]
    686e:	58a7      	mov	[S-18], YA

00006870 <.LM32>:
 * Performs 32-bit divisions repeatedly to reduce the remainder. For this to
 * be efficient, the processor has to have 32-bit hardware division.
 */
static uint8_t clz(uint32_t x)
{
  uint8_t result = 0;
    6870:	7000      	lod	A, #0
    6872:	5201      	mov	[S-2], A
    6874:	07a9      	jmp	0x67c8 <.L15>

00006876 <.L12>:
  if (x == 0) return 32;
  while (!(x & 0xF0000000)) { result += 4; x <<= 4; }
  while (!(x & 0x80000000)) { result += 1; x <<= 1; }
    6876:	6201      	lod	AL, [S-2]
    6878:	8001      	add	AL, #1
    687a:	5cf2      	usex	A
    687c:	5201      	mov	[S-2], A

0000687e <.LVL76>:
    687e:	58e7      	mov	YA, [S-18]

00006880 <.LVL77>:
    6880:	48e0      	asl	YA, #1
    6882:	58a7      	mov	[S-18], YA

00006884 <.LVL78>:
    6884:	07aa      	jmp	0x67da <.L11>

00006886 <.L16>:
  int bit_pos = 17;

  // This uses a hardware 32/32 bit division multiple times, until we have
  // computed all the bits in (a<<17)/b. Usually this takes 1-3 iterations.
  if (b == 0)
	  return fix16_minimum;
    6886:	7800      	lod	Y, #0
    6888:	5a09      	mov	[S-10], Y
    688a:	7ada 8000 	lod	Y, #32768
    688e:	5a07      	mov	[S-8], Y
    6890:	0788      	jmp	0x67a2 <.L1>

00006892 <.L18>:
    6892:	7c00      	lod	X, #0
    6894:	5e09      	mov	[S-10], X

00006896 <.LVL81>:
    6896:	7eda 8000 	lod	X, #32768
    689a:	5e07      	mov	[S-8], X
    689c:	0782      	jmp	0x67a2 <.L1>

0000689e <_fix16_mul>:

  return result;
}

fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
{
    689e:	5813      	inc	S, #20

000068a0 <.LCFI24>:
    68a0:	4cc0      	mov	D, YA

000068a2 <.LM36>:
  //                                      BD      16 * 16 -> 32 bit products
  //                               CB
  //                               AD
  //                              AC
  //                       |----| 64 bit product
  int32_t A = (inArg0 >> 16), C = (inArg1 >> 16);
    68a2:	48bf      	asr	YA, #16

000068a4 <.LVL83>:
    68a4:	58a6      	mov	[S-16], YA

000068a6 <.LVL84>:
    68a6:	58eb      	mov	YA, [S-26]

000068a8 <.LVL85>:
    68a8:	48bf      	asr	YA, #16
    68aa:	58a8      	mov	[S-20], YA

000068ac <.LM37>:
  uint32_t B = (inArg0 & 0xFFFF), D = (inArg1 & 0xFFFF);
    68ac:	4c80      	mov	YA, D

000068ae <.LVL87>:
    68ae:	7800      	lod	Y, #0
    68b0:	58a4      	mov	[S-12], YA

000068b2 <.LVL88>:
    68b2:	58eb      	mov	YA, [S-26]
    68b4:	7800      	lod	Y, #0
    68b6:	58a0      	mov	[S-4], YA

000068b8 <.LM38>:

  int32_t AC = A*C;
  int32_t AD_CB = A*D + C*B;
    68b8:	7a03      	lod	Y, [S-4]
    68ba:	5adf      	push	Y

000068bc <.LCFI25>:
    68bc:	7a03      	lod	Y, [S-4]
    68be:	5adf      	push	Y

000068c0 <.LCFI26>:
    68c0:	58e8      	mov	YA, [S-20]
    68c2:	82db 2dd3 	callf	0x5ba6 <___mulsi3>

000068c6 <.LVL92>:
    68c6:	5c03      	dec	S, #4

000068c8 <.LCFI27>:
    68c8:	58a2      	mov	[S-8], YA
    68ca:	7e0b      	lod	X, [S-12]
    68cc:	5edf      	push	X

000068ce <.LCFI28>:
    68ce:	7e0b      	lod	X, [S-12]
    68d0:	5edf      	push	X

000068d2 <.LCFI29>:
    68d2:	58ea      	mov	YA, [S-24]
    68d4:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    68d8:	5c03      	dec	S, #4

000068da <.LCFI30>:
    68da:	58c2      	mov	D, [S-8]
    68dc:	4c00      	add	D, YA
    68de:	5882      	mov	[S-8], D

000068e0 <.LM39>:
  uint32_t BD = B*D;
    68e0:	7203      	lod	A, [S-4]
    68e2:	52df      	push	A

000068e4 <.LCFI31>:
    68e4:	7203      	lod	A, [S-4]
    68e6:	52df      	push	A

000068e8 <.LCFI32>:
    68e8:	58e6      	mov	YA, [S-16]
    68ea:	82db 2dd3 	callf	0x5ba6 <___mulsi3>

000068ee <.LVL101>:
    68ee:	5c03      	dec	S, #4

000068f0 <.LCFI33>:
    68f0:	58a4      	mov	[S-12], YA

000068f2 <.LM40>:

  int32_t product_hi = AC + (AD_CB >> 16);
    68f2:	58e2      	mov	YA, [S-8]

000068f4 <.LVL104>:
    68f4:	48bf      	asr	YA, #16
    68f6:	58a0      	mov	[S-4], YA

000068f8 <.LM41>:
  //                              AC
  //                       |----| 64 bit product
  int32_t A = (inArg0 >> 16), C = (inArg1 >> 16);
  uint32_t B = (inArg0 & 0xFFFF), D = (inArg1 & 0xFFFF);

  int32_t AC = A*C;
    68f8:	7a13      	lod	Y, [S-20]
    68fa:	5adf      	push	Y

000068fc <.LCFI34>:
    68fc:	7a13      	lod	Y, [S-20]
    68fe:	5adf      	push	Y

00006900 <.LCFI35>:
    6900:	58e8      	mov	YA, [S-20]
    6902:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    6906:	5c03      	dec	S, #4

00006908 <.LCFI36>:
  int32_t AD_CB = A*D + C*B;
  uint32_t BD = B*D;

  int32_t product_hi = AC + (AD_CB >> 16);
    6908:	58c0      	mov	D, [S-4]
    690a:	4c00      	add	D, YA
    690c:	5880      	mov	[S-4], D

0000690e <.LM43>:

  // Handle carry from lower 32 bits to upper part of result.
  uint32_t ad_cb_temp = AD_CB << 16;
    690e:	58c2      	mov	D, [S-8]

00006910 <.LVL111>:
    6910:	48cf      	asl	D, #16

00006912 <.LM44>:
  uint32_t product_lo = BD + ad_cb_temp;
    6912:	4c80      	mov	YA, D
    6914:	a20b      	add	A, [S-12]
    6916:	f209      	adc	Y, [S-10]
    6918:	58a6      	mov	[S-16], YA

0000691a <.LM45>:
  uint32_t product_lo_tmp = product_lo;
  fix16_t result = 0;

  if (product_lo < BD)
    691a:	58c4      	mov	D, [S-12]

0000691c <.LVL114>:
    691c:	4c90      	cmp	D, YA
    691e:	1a05      	jule	0x692a <.L30>

00006920 <.LM46>:
    product_hi++;
    6920:	58c0      	mov	D, [S-4]
    6922:	4c02 0001 	add	D, #1
    6926:	0000 
    6928:	5880      	mov	[S-4], D

0000692a <.L30>:

#ifndef FIXMATH_NO_OVERFLOW
  // The upper 17 bits should all be the same (the sign).
  if (product_hi >> 31 != product_hi >> 15)
    692a:	58e0      	mov	YA, [S-4]

0000692c <.LVL116>:
    692c:	48bf      	asr	YA, #16
    692e:	48be      	asr	YA, #15
    6930:	58a2      	mov	[S-8], YA

00006932 <.LVL117>:
    6932:	58e0      	mov	YA, [S-4]
    6934:	48be      	asr	YA, #15
    6936:	58c2      	mov	D, [S-8]
    6938:	4c90      	cmp	D, YA
    693a:	1d1a      	jne	0x6970 <.L33>

0000693c <.LM48>:
  // Subtracting 0x8000 (= 0.5) and then using signed right shift
  // achieves proper rounding to result-1, except in the corner
  // case of negative numbers and lowest word = 0x8000.
  // To handle that, we also have to subtract 1 for negative numbers.
  product_lo_tmp = product_lo;
  product_lo -= 0x8000;
    693c:	4ce2 8000 	mov	YA, #-32768
    6940:	ffff 
    6942:	a20f      	add	A, [S-16]
    6944:	f20d      	adc	Y, [S-14]

00006946 <.LM49>:
  product_lo -= (uint32_t)product_hi >> 31;
    6946:	a207      	add	A, [S-8]

00006948 <.LVL119>:
    6948:	f205      	adc	Y, [S-6]

0000694a <.LM50>:
  if (product_lo > product_lo_tmp)
    694a:	58c6      	mov	D, [S-16]
    694c:	4c90      	cmp	D, YA
    694e:	1c05      	jnc	0x695a <.L32>

00006950 <.LM51>:
    product_hi--;
    6950:	58c0      	mov	D, [S-4]
    6952:	4c02 ffff 	add	D, #-1
    6956:	ffff 
    6958:	5880      	mov	[S-4], D

0000695a <.L32>:

  // Discard the lowest 16 bits. Note that this is not exactly the same
  // as dividing by 0x10000. For example if product = -1, result will
  // also be -1 and not 0. This is compensated by adding +1 to the result
  // and compensating this in turn in the rounding above.
  result = (product_hi << 16) | (product_lo >> 16);
    695a:	58c0      	mov	D, [S-4]
    695c:	48cf      	asl	D, #16
    695e:	48af      	lsr	YA, #16

00006960 <.LVL122>:
    6960:	4c83      	push	D

00006962 <.LCFI37>:
    6962:	a603      	or	A, [S-4]
    6964:	e601      	or	Y, [S-2]
    6966:	5c03      	dec	S, #4

00006968 <.LM53>:
  result += 1;
    6968:	4c22 0001 	add	YA, #1
    696c:	0000 

0000696e <.LM54>:
  return result;
    696e:	5415      	ret	#22

00006970 <.L33>:
    product_hi++;

#ifndef FIXMATH_NO_OVERFLOW
  // The upper 17 bits should all be the same (the sign).
  if (product_hi >> 31 != product_hi >> 15)
    return fix16_overflow;
    6970:	4ce2 0000 	mov	YA, #-2147483648
    6974:	8000 

00006976 <.LM56>:
  // and compensating this in turn in the rounding above.
  result = (product_hi << 16) | (product_lo >> 16);
  result += 1;
  return result;
#endif
}
    6976:	5415      	ret	#22

00006978 <_moduleAdcInit>:
/* flag to signalize new data from ADC conversion */
volatile uint16_t adcNewData = 0;

void moduleAdcInit(void)
{
  IO_SET(PORT_ADC_CTRL,ADC_EN,ADCENABLE); /* enable ADC */
    6978:	62b4      	lod	AL, io:0x34 <.Lframe0+0x16>
    697a:	8402      	or	AL, #2
    697c:	42b4      	mov	io:0x34 <.Lframe0+0x16>, AL

0000697e <.LBB216>:
 * @param[in] ctrl specifies the Sequence and Confirsion sources, Interleave, Saturate and Interrupt scheme, StandBy mode
 */
STATIC INLINE void AdcInit(uint8_t AdcDiv, void *SBase,
                           Adc_Control_t ctrl)
{
    IO_SET(PORT_ADC_CTRL, ADC_EN, 1u);
    697e:	62b4      	lod	AL, io:0x34 <.Lframe0+0x16>
    6980:	8402      	or	AL, #2
    6982:	42b4      	mov	io:0x34 <.Lframe0+0x16>, AL

00006984 <.LM4>:
    IO_SET(ADC_SAR, STOP, 1u); /* STOP the ADC from any ADC mode. */
    6984:	62d8 01a0 	lod	AL, 0x1a0 <.LASF48>
    6988:	94fc      	and	AL, #-4
    698a:	8402      	or	AL, #2
    698c:	42d8 01a0 	mov	0x1a0 <.LASF48>, AL

00006990 <.LM5>:
    IO_SET(ADC_SAR, ADC_CLK_DIV, AdcDiv);
    6990:	600f      	lod	AL, #15
    6992:	42d8 01a6 	mov	0x1a6 <.LASF68>, AL

00006996 <.LM6>:
    IO_SET(ADC_SAR, SBASE_0, (uint16_t )SBase);
    6996:	72da 1028 	lod	A, #4136
    699a:	52d8 01a2 	mov	0x1a2 <.LASF48+0x2>, A

0000699e <.LM7>:
    IO_SET(ADC_SAR, START, 0u, /* Don't impact on Start-Stop */
    699e:	72d8 01a0 	lod	A, 0x1a0 <.LASF48>
    69a2:	7ae2      	lod	Y, A
    69a4:	f6da f000 	and	Y, #61440
    69a8:	72d8 5a0e 	lod	A, 0x5a0e <.LC0>
    69ac:	b6da 0ffc 	and	A, #4092
    69b0:	a6e6      	or	A, Y
    69b2:	52d8 01a0 	mov	0x1a0 <.LASF48>, A

000069b6 <.LBB218>:
}

/** AdcStart starts the ADC from any ADC mode. */
STATIC INLINE void AdcStart(void)
{
    IO_HOST(ADC_SAR, START) = (uint16_t)1u << IO_OFFSET(ADC_SAR, START); /* START the ADC. */
    69b6:	7001      	lod	A, #1
    69b8:	52d8 01a0 	mov	0x1a0 <.LASF48>, A

000069bc <.LBE218>:
  AdcInit(ADCCLOCKDIVIDER, (void*)&adcData[0], adc_ctrl);
  /* start ADC conversion */
  AdcStart();

  /* configure ADC Interrupt*/
  Itc_Clear(ADC_SAR);
    69bc:	6020      	lod	AL, #32
    69be:	42d8 0053 	mov	0x53 <.Ldebug_line0+0x12>, AL

000069c2 <.LM10>:
  Itc_SetPrio(ADC_SAR, 3u);
    69c2:	62d8 008d 	lod	AL, 0x8d <.LASF10+0x1>
    69c6:	94fc      	and	AL, #-4
    69c8:	42d8 008d 	mov	0x8d <.LASF10+0x1>, AL

000069cc <.LM11>:
  Itc_Enable(ADC_SAR);
    69cc:	62d8 006f 	lod	AL, 0x6f <.LASF3>
    69d0:	8420      	or	AL, #32
    69d2:	42d8 006f 	mov	0x6f <.LASF3>, AL

000069d6 <.LM12>:
}
    69d6:	5401      	ret

000069d8 <_getLedAdcSampleState>:

uint8_t getLedAdcSampleState(uint16_t led_index, ESingleLedChannel led_chanel)
{
	return ledMeasEna[(ledMeasValBuf^1)][(led_index*RGBLEDCHANNELS)+led_chanel];
    69d8:	7ad8 11ce 	lod	Y, 0x11ce <_ledMeasValBuf>
    69dc:	fc01      	xor	Y, #1
    69de:	4872 0003 	muls	A, A, #3

000069e2 <.LVL3>:
    69e2:	7e03      	lod	X, [S-4]
    69e4:	22e2      	add	X, A
    69e6:	72e6      	lod	A, Y
    69e8:	487a 0014 	muls	Y, A, #20
    69ec:	e2da 1000 	add	Y, #4096
    69f0:	e2ee      	add	Y, X
    69f2:	62f0      	lod	AL, [Y]
    69f4:	5cf2      	usex	A

000069f6 <.LM15>:
}
    69f6:	5401      	ret

000069f8 <_moduleAdcLedEnable>:

void moduleAdcLedEnable(uint16_t led_index, ESingleLedChannel led_chanel, uint16_t enable)
{
    69f8:	7a05      	lod	Y, [S-6]
    69fa:	4872 0003 	muls	A, A, #3

000069fe <.LVL5>:
    69fe:	7e03      	lod	X, [S-4]
    6a00:	22e2      	add	X, A

00006a02 <.LM17>:
  if (enable == 0)
    6a02:	ec00      	cmp	Y, #0
    6a04:	1d0a      	jne	0x6a1a <.L4>

00006a06 <.LM18>:
    ledMeasEna[(ledMeasValBuf^1)][(led_index*RGBLEDCHANNELS)+led_chanel] = 0;
    6a06:	72d8 11ce 	lod	A, 0x11ce <_ledMeasValBuf>
    6a0a:	bc01      	xor	A, #1
    6a0c:	4872 0014 	muls	A, A, #20
    6a10:	a2da 1000 	add	A, #4096
    6a14:	22e2      	add	X, A
    6a16:	46f8      	mov	[X], YL
    6a18:	5401      	ret

00006a1a <.L4>:
  else
    ledMeasEna[(ledMeasValBuf^1)][(led_index*RGBLEDCHANNELS)+led_chanel] = 1;
    6a1a:	7ad8 11ce 	lod	Y, 0x11ce <_ledMeasValBuf>
    6a1e:	fc01      	xor	Y, #1
    6a20:	72e6      	lod	A, Y
    6a22:	487a 0014 	muls	Y, A, #20
    6a26:	e2da 1000 	add	Y, #4096
    6a2a:	e2ee      	add	Y, X
    6a2c:	6001      	lod	AL, #1
    6a2e:	42f0      	mov	[Y], AL

00006a30 <.LM20>:
}
    6a30:	5401      	ret

00006a32 <_moduleAdcUpdate>:
static __attribute__((always_inline)) inline
uint16_t builtin_mlx16_get_status (void)
{
    uint16_t status;

    __asm__ __volatile__ (
    6a32:	72e3      	lod	A, M

00006a34 <.LBB223>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    6a34:	08b2      	clrb	MH.2
    6a36:	08b1      	clrb	MH.1
    6a38:	08b0      	clrb	MH.0

00006a3a <.LBE223>:

void moduleAdcUpdate(void)
{
  /* ADC has to be made aware of new PWM duty-cycles -> ATOMIC operation required */
  ENTER_SECTION(ATOMIC_KEEP_MODE);
  ledMeasChgReq = 1; /* signalize to ADC to check for new Data */
    6a3a:	7801      	lod	Y, #1
    6a3c:	5ad8 11d0 	mov	0x11d0 <_ledMeasChgReq>, Y

00006a40 <.LBB226>:

 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_status (uint16_t status)
{
    __asm__ __volatile__ (
    6a40:	52e3      	mov	M, A

00006a42 <.LBE220>:
  EXIT_SECTION();
}
    6a42:	5401      	ret

00006a44 <_moduleAdcDataReady>:

uint16_t moduleAdcDataReady(void)
{
  if (adcNewData == 0)
    6a44:	7ad8 11cc 	lod	Y, 0x11cc <_adcNewData>
    6a48:	7001      	lod	A, #1
    6a4a:	ec00      	cmp	Y, #0
    6a4c:	1d01      	jne	0x6a50 <.L8>
    6a4e:	72e6      	lod	A, Y

00006a50 <.L8>:
    return 0;
  else
    return 1;
}
    6a50:	5401      	ret

00006a52 <_moduleAdcDataClear>:
static __attribute__((always_inline)) inline
uint16_t builtin_mlx16_get_status (void)
{
    uint16_t status;

    __asm__ __volatile__ (
    6a52:	72e3      	lod	A, M

00006a54 <.LBB233>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    6a54:	08b2      	clrb	MH.2
    6a56:	08b1      	clrb	MH.1
    6a58:	08b0      	clrb	MH.0

00006a5a <.LBE233>:

void moduleAdcDataClear(void)
{
  /* reset flag in atomic operation */
  ENTER_SECTION(ATOMIC_KEEP_MODE);
  adcNewData = 0;
    6a5a:	7800      	lod	Y, #0
    6a5c:	5ad8 11cc 	mov	0x11cc <_adcNewData>, Y

00006a60 <.LBB236>:

 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_status (uint16_t status)
{
    __asm__ __volatile__ (
    6a60:	52e3      	mov	M, A

00006a62 <.LBE230>:
  EXIT_SECTION();
}
    6a62:	5401      	ret

00006a64 <_moduleAdcGetTemperature>:

volatile uint16_t temperature_Cache = 0;
int16_t moduleAdcGetTemperature(void)
{
  uint16_t result = temperature_Cache;
    6a64:	72d8 11ca 	lod	A, 0x11ca <_temperature_Cache>

00006a68 <.LM38>:
  return result;
}
    6a68:	5401      	ret

00006a6a <_moduleAdcGetVs>:

volatile uint16_t input_Voltage_Cache = 0;
uint16_t moduleAdcGetVs(void)
{
  uint16_t result = input_Voltage_Cache;
    6a6a:	72d8 11c8 	lod	A, 0x11c8 <_input_Voltage_Cache>

00006a6e <.LM41>:
  return result;
}
    6a6e:	5401      	ret

00006a70 <_moduleAdcGetLedVoltage>:
}

volatile uint16_t led_voltage[NUMBOFSINGLELEDS];

void moduleAdcGetLedVoltage(SLEDVoltages *result)
{
    6a70:	5809      	inc	S, #10

00006a72 <.LCFI0>:
    6a72:	5207      	mov	[S-8], A

00006a74 <.LM43>:
  uint16_t cntLeds = 0;
  uint16_t index = 0;

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    for(index = 0; index < RGBLEDCHANNELS; index++)
    6a74:	7000      	lod	A, #0

00006a76 <.LVL16>:
    6a76:	5205      	mov	[S-6], A

00006a78 <.L13>:
    6a78:	7000      	lod	A, #0
    6a7a:	5203      	mov	[S-4], A

00006a7c <.L14>:
    6a7c:	7205      	lod	A, [S-6]
    6a7e:	a203      	add	A, [S-4]

00006a80 <.LM44>:
    {
	  result->LedVoltage[cntLeds].ledChannelData[index] =
		  calcLEDmVolt(led_voltage[cntLeds*RGBLEDCHANNELS + index]);
    6a80:	4422      	asl	A
    6a82:	7ae2      	lod	Y, A
    6a84:	e2da 133e 	add	Y, #4926
    6a88:	7af0      	lod	Y, [Y]
    6a8a:	5a01      	mov	[S-2], Y

00006a8c <.LM45>:

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    for(index = 0; index < RGBLEDCHANNELS; index++)
    {
	  result->LedVoltage[cntLeds].ledChannelData[index] =
    6a8c:	7203      	lod	A, [S-4]
    6a8e:	4422      	asl	A
    6a90:	7ae2      	lod	Y, A
    6a92:	e207      	add	Y, [S-8]
    6a94:	5a09      	mov	[S-10], Y

00006a96 <.LBB240>:
static uint16_t calcLEDmVolt(uint16_t adcval){
    uint16_t result = 0;

    /* forward_voltage [mV] = (ADC_Val * Gain(5) * ADC_Ref_Volt(2.5) / ADC_Resolution (1023)) * 1000 (mV)
     * -> 2.5 = 5/2 -> avoids float operations */
    result = adcval * GAINDIFF2;
    6a96:	7201      	lod	A, [S-2]
    6a98:	44a2      	asl	A, #2

00006a9a <.LM47>:
    result = (uint16_t)((uint32_t)((uint32_t)result * (uint32_t)5000) / (uint32_t)2046);
    6a9a:	4822 1388 	mulu	YA, A, #5000
    6a9e:	54ca 07fe 	pushw	#2046
    6aa2:	54ca 0000 	pushw	#0

00006aa6 <.LCFI1>:
    6aa6:	82db 2e68 	callf	0x5cd0 <___udivsi3>
    6aaa:	5c03      	dec	S, #4

00006aac <.LBE240>:
  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    for(index = 0; index < RGBLEDCHANNELS; index++)
    {
	  result->LedVoltage[cntLeds].ledChannelData[index] =
		  calcLEDmVolt(led_voltage[cntLeds*RGBLEDCHANNELS + index]);
    6aac:	7e09      	lod	X, [S-10]
    6aae:	52f8      	mov	[X], A

00006ab0 <.LM49>:
  uint16_t cntLeds = 0;
  uint16_t index = 0;

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    for(index = 0; index < RGBLEDCHANNELS; index++)
    6ab0:	7203      	lod	A, [S-4]
    6ab2:	a001      	add	A, #1
    6ab4:	5203      	mov	[S-4], A

00006ab6 <.LVL22>:
    6ab6:	ac03      	cmp	A, #3
    6ab8:	1d61      	jne	0x6a7c <.L14>
    6aba:	7e05      	lod	X, [S-6]
    6abc:	2003      	add	X, #3
    6abe:	5e05      	mov	[S-6], X
    6ac0:	7207      	lod	A, [S-8]

00006ac2 <.LVL23>:
    6ac2:	a006      	add	A, #6
    6ac4:	5207      	mov	[S-8], A

00006ac6 <.LM50>:
void moduleAdcGetLedVoltage(SLEDVoltages *result)
{
  uint16_t cntLeds = 0;
  uint16_t index = 0;

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    6ac6:	2c12      	cmp	X, #18
    6ac8:	1d57      	jne	0x6a78 <.L13>

00006aca <.LM51>:
    {
	  result->LedVoltage[cntLeds].ledChannelData[index] =
		  calcLEDmVolt(led_voltage[cntLeds*RGBLEDCHANNELS + index]);
    }
  }
}
    6aca:	540b      	ret	#12

00006acc <_moduleLedVoltageUpdate>:

void moduleLedVoltageUpdate(void)
{
	moduleAdcGetLedVoltage(&currentLedVoltage);
    6acc:	72da 14b8 	lod	A, #5304
    6ad0:	07cf      	jmp	0x6a70 <_moduleAdcGetLedVoltage>

00006ad2 <__ADC_SAR_INT>:
}

/* ADC interrupt */
__attribute__((interrupt)) void _ADC_SAR_INT(void) {
    6ad2:	5edf      	push	X

00006ad4 <.LCFI3>:
    6ad4:	5adf      	push	Y

00006ad6 <.LCFI4>:
    6ad6:	52df      	push	A

00006ad8 <.LCFI5>:
    6ad8:	5803      	inc	S, #4

00006ada <.LCFI6>:

    /* store actual ADC channel */
    static uint16_t currentADCchannel = 0;

    /* check if all LED channels have been measured */
    if(currentADCchannel>=NUMBOFSINGLELEDS) {
    6ada:	7ad8 11c6 	lod	Y, 0x11c6 <___currentADCchannel_3341>
    6ade:	ec11      	cmp	Y, #17
    6ae0:	1e01      	jug	0x6ae4 <.LM57>
    6ae2:	0051      	jmp	0x6b86 <.L19>

00006ae4 <.LM57>:
        /* process VS and temperature channels */
        if (currentADCchannel == NUMBOFSINGLELEDS)
          input_Voltage_Cache = adcResults[0];
    6ae4:	72d8 11d2 	lod	A, 0x11d2 <_adcResults>

00006ae8 <.LM58>:
    static uint16_t currentADCchannel = 0;

    /* check if all LED channels have been measured */
    if(currentADCchannel>=NUMBOFSINGLELEDS) {
        /* process VS and temperature channels */
        if (currentADCchannel == NUMBOFSINGLELEDS)
    6ae8:	ec12      	cmp	Y, #18
    6aea:	1901      	je	0x6aee <.LM59>
    6aec:	0043      	jmp	0x6b74 <.L20>

00006aee <.LM59>:
          input_Voltage_Cache = adcResults[0];
    6aee:	52d8 11c8 	mov	0x11c8 <_input_Voltage_Cache>, A

00006af2 <.LM60>:
            /* set flag to signalize new data from ADC */
            adcNewData = 1;
        }
        else {
            /* increase ADC channel */
            currentADCchannel++;
    6af2:	7013      	lod	A, #19
    6af4:	52d8 11c6 	mov	0x11c6 <___currentADCchannel_3341>, A

00006af8 <.L21>:
        /* increase ADC channel */
        currentADCchannel++;
    }

    /* check if differential measurement of LED is allowed */
    if(ledMeasEna[ledMeasValBuf][LEDADCINDEX[currentADCchannel]] == 1) {
    6af8:	72d8 11ce 	lod	A, 0x11ce <_ledMeasValBuf>
    6afc:	5201      	mov	[S-2], A
    6afe:	7ed8 11c6 	lod	X, 0x11c6 <___currentADCchannel_3341>
    6b02:	72ee      	lod	A, X
    6b04:	4422      	asl	A
    6b06:	5203      	mov	[S-4], A
    6b08:	7ae2      	lod	Y, A
    6b0a:	e2da 5ab8 	add	Y, #23224
    6b0e:	7201      	lod	A, [S-2]
    6b10:	4872 0014 	muls	A, A, #20
    6b14:	5201      	mov	[S-2], A
    6b16:	a2da 1000 	add	A, #4096
    6b1a:	7af0      	lod	Y, [Y]
    6b1c:	e2e2      	add	Y, A
    6b1e:	62f0      	lod	AL, [Y]
    6b20:	8c01      	cmp	AL, #1
    6b22:	1901      	je	0x6b26 <.LM62>
    6b24:	0053      	jmp	0x6bcc <.L23>

00006b26 <.LM62>:
        /* keep channel sequence */
        adcData[1] = ADCCHANNELLIST[(currentADCchannel*2)];
    6b26:	44ae      	asl	X, #2
    6b28:	22da 5ae0 	add	X, #23264
    6b2c:	72f8      	lod	A, [X]
    6b2e:	52d8 102a 	mov	0x102a <_adcData+0x2>, A

00006b32 <.LM63>:
        adcData[2] = ADCCHANNELLIST[(currentADCchannel*2)+1];
    6b32:	7203      	lod	A, [S-4]
    6b34:	4422      	asl	A
    6b36:	7ae2      	lod	Y, A
    6b38:	e2da 5ae2 	add	Y, #23266
    6b3c:	72f0      	lod	A, [Y]

00006b3e <.L26>:
    }
    else {
        /* LED measurement not allowed -> set dummy channel -> temperature */
        adcData[1] = ADCCHANNELLIST[38];
        adcData[2] = ADCCHANNELLIST[39];
    6b3e:	52d8 102c 	mov	0x102c <_adcData+0x4>, A

00006b42 <.LM65>:
    }

    /* signalize ADC to be ready for next conversion */
    IO_SET(ADC_SAR, SBASE_0, (uint16_t )(&adcData[0]));
    6b42:	72da 1028 	lod	A, #4136
    6b46:	52d8 01a2 	mov	0x1a2 <.LASF48+0x2>, A

00006b4a <.LBB242>:
    6b4a:	7001      	lod	A, #1
    6b4c:	52d8 01a0 	mov	0x1a0 <.LASF48>, A

00006b50 <.LBE242>:
    /* start ADC */
    AdcStart();

    /* check if new PWM duty-cycles are available */
    if(ledMeasChgReq == 1) {
    6b50:	72d8 11d0 	lod	A, 0x11d0 <_ledMeasChgReq>
    6b54:	ac01      	cmp	A, #1
    6b56:	1d08      	jne	0x6b68 <.L18>

00006b58 <.LM68>:
        /* reset flag */
        ledMeasChgReq = 0;
    6b58:	7000      	lod	A, #0
    6b5a:	52d8 11d0 	mov	0x11d0 <_ledMeasChgReq>, A

00006b5e <.LM69>:
        /* switch buffer to consider new LED forward voltage measurement constraints acc. PWM duty-cycle */
        ledMeasValBuf ^= 1;
    6b5e:	72d8 11ce 	lod	A, 0x11ce <_ledMeasValBuf>
    6b62:	bc01      	xor	A, #1
    6b64:	52d8 11ce 	mov	0x11ce <_ledMeasValBuf>, A

00006b68 <.L18>:
    }
}
    6b68:	5c03      	dec	S, #4
    6b6a:	72cf      	pop	A

00006b6c <.LCFI7>:
    6b6c:	7acf      	pop	Y

00006b6e <.LCFI8>:
    6b6e:	7ecf      	pop	X

00006b70 <.LCFI9>:
    6b70:	72cb      	pop	M
    6b72:	5401      	ret

00006b74 <.L20>:
    if(currentADCchannel>=NUMBOFSINGLELEDS) {
        /* process VS and temperature channels */
        if (currentADCchannel == NUMBOFSINGLELEDS)
          input_Voltage_Cache = adcResults[0];
        else
          temperature_Cache = adcResults[0];
    6b74:	52d8 11ca 	mov	0x11ca <_temperature_Cache>, A

00006b78 <.LM72>:

        /* check if all ADC channels have been measured */
        if(currentADCchannel>=(NUMBOFSINGLELEDS+1)) {
            /* reset channel */
            currentADCchannel = 0;
    6b78:	7000      	lod	A, #0
    6b7a:	52d8 11c6 	mov	0x11c6 <___currentADCchannel_3341>, A

00006b7e <.LM73>:
            /* set flag to signalize new data from ADC */
            adcNewData = 1;
    6b7e:	7001      	lod	A, #1
    6b80:	52d8 11cc 	mov	0x11cc <_adcNewData>, A
    6b84:	07b9      	jmp	0x6af8 <.L21>

00006b86 <.L19>:
            currentADCchannel++;
        }
    }
    else {
        /* process LED forward voltage channel if valid channel */
        if(ledMeasEna[ledMeasValBuf][LEDADCINDEX[currentADCchannel]] == 1) {
    6b86:	72d8 11ce 	lod	A, 0x11ce <_ledMeasValBuf>
    6b8a:	5203      	mov	[S-4], A
    6b8c:	72e6      	lod	A, Y
    6b8e:	4422      	asl	A
    6b90:	7ee2      	lod	X, A
    6b92:	22da 5ab8 	add	X, #23224
    6b96:	7ef8      	lod	X, [X]
    6b98:	5e01      	mov	[S-2], X
    6b9a:	7203      	lod	A, [S-4]
    6b9c:	4872 0014 	muls	A, A, #20
    6ba0:	5203      	mov	[S-4], A
    6ba2:	a2da 1000 	add	A, #4096
    6ba6:	a2ee      	add	A, X
    6ba8:	7ee2      	lod	X, A
    6baa:	62f8      	lod	AL, [X]
    6bac:	8c01      	cmp	AL, #1
    6bae:	1d0a      	jne	0x6bc4 <.L22>

00006bb0 <.LM75>:
            led_voltage[LEDADCINDEX[currentADCchannel]] = adcResults[0];
    6bb0:	72d8 11d2 	lod	A, 0x11d2 <_adcResults>
    6bb4:	5203      	mov	[S-4], A
    6bb6:	7201      	lod	A, [S-2]
    6bb8:	4422      	asl	A
    6bba:	7ee2      	lod	X, A
    6bbc:	22da 133e 	add	X, #4926
    6bc0:	7203      	lod	A, [S-4]
    6bc2:	52f8      	mov	[X], A

00006bc4 <.L22>:
        }
        /* increase ADC channel */
        currentADCchannel++;
    6bc4:	e001      	add	Y, #1
    6bc6:	5ad8 11c6 	mov	0x11c6 <___currentADCchannel_3341>, Y
    6bca:	0796      	jmp	0x6af8 <.L21>

00006bcc <.L23>:
        adcData[1] = ADCCHANNELLIST[(currentADCchannel*2)];
        adcData[2] = ADCCHANNELLIST[(currentADCchannel*2)+1];
    }
    else {
        /* LED measurement not allowed -> set dummy channel -> temperature */
        adcData[1] = ADCCHANNELLIST[38];
    6bcc:	72da 0184 	lod	A, #388
    6bd0:	52d8 102a 	mov	0x102a <_adcData+0x2>, A

00006bd4 <.LM78>:
        adcData[2] = ADCCHANNELLIST[39];
    6bd4:	7004      	lod	A, #4
    6bd6:	07b3      	jmp	0x6b3e <.L26>

00006bd8 <_moduleCommInit>:
};

void moduleCommInit(void)
{
  /* configure MeLiBus */
  Mel_Init((MelConfiguration_t*)&MelConfigurationDefault);
    6bd8:	72da 5b32 	lod	A, #23346
    6bdc:	82db 1a4e 	callf	0x349c <_Mel_Init>

00006be0 <.LM3>:
  Mel_ConfigureInterrupts(MelInterruptConfigurationDefault);
    6be0:	72d8 5b30 	lod	A, 0x5b30 <_MelInterruptConfigurationDefault>
    6be4:	82db 195d 	callf	0x32ba <_Mel_ConfigureInterrupts>

00006be8 <.LM4>:
#if defined (__MLX81116xAA__)
  Mel_Start();
#elif defined (__MLX81116xAC__)
  IO_SET(UART, REE, 1, TRE, 1);
    6be8:	72d8 0216 	lod	A, 0x216 <.LASF100+0xe>
    6bec:	a406      	or	A, #6
    6bee:	52d8 0216 	mov	0x216 <.LASF100+0xe>, A

00006bf2 <.LM5>:
  IO_SET(PORT_MELIBUS_CTRL, MELIBUS_EN, 1);
    6bf2:	62d8 0224 	lod	AL, 0x224 <.LASF35+0x2>
    6bf6:	8401      	or	AL, #1
    6bf8:	42d8 0224 	mov	0x224 <.LASF35+0x2>, AL

00006bfc <.LM6>:
  IO_SET(PORT_MISC2_OUT, ENABLE_TX, 1, AOUT_SUP, 0, EN_IN_AAIN, 1);
    6bfc:	72d8 0204 	lod	A, 0x204 <.LASF62+0x5>
    6c00:	b6da f300 	and	A, #62208
    6c04:	a6da 0c00 	or	A, #3072
    6c08:	52d8 0204 	mov	0x204 <.LASF62+0x5>, A

00006c0c <.LM7>:
#if defined (__MLX81116xAA__)
      /* set new node address from EEPROM */
      Mel_SetNewNAD(savedConfig.nad);
#elif defined (__MLX81116xAC__)
      /* Stop MeLiBu HW before loading new NAD */
      Mel_Stop();
    6c0c:	82db 1a3d 	callf	0x347a <_Mel_Stop>

00006c10 <.LM8>:
      /* Load new NAD */
      IO_SET(PORT_ID, ID, savedConfig.nad);
    6c10:	62d8 021a 	lod	AL, 0x21a <.LASF67+0x3>
    6c14:	94c0      	and	AL, #-64
    6c16:	86d8 1364 	or	AL, 0x1364 <_savedConfig>
    6c1a:	42d8 021a 	mov	0x21a <.LASF67+0x3>, AL

00006c1e <.LM9>:
      /* Restart MeLiBu HW after loading new NAD */
      IO_SET(UART, REE, 1, TRE, 1);
    6c1e:	72d8 0216 	lod	A, 0x216 <.LASF100+0xe>
    6c22:	a406      	or	A, #6
    6c24:	52d8 0216 	mov	0x216 <.LASF100+0xe>, A

00006c28 <.LM10>:
      IO_SET(PORT_MELIBUS_CTRL, MELIBUS_EN, 1);
    6c28:	62d8 0224 	lod	AL, 0x224 <.LASF35+0x2>
    6c2c:	8401      	or	AL, #1
    6c2e:	42d8 0224 	mov	0x224 <.LASF35+0x2>, AL

00006c32 <.LM11>:
      IO_SET(PORT_MISC2_OUT, ENABLE_TX, 1, AOUT_SUP, 0, EN_IN_AAIN, 1);
    6c32:	72d8 0204 	lod	A, 0x204 <.LASF62+0x5>
    6c36:	b6da f300 	and	A, #62208
    6c3a:	a6da 0c00 	or	A, #3072
    6c3e:	52d8 0204 	mov	0x204 <.LASF62+0x5>, A

00006c42 <.LM12>:
#endif
}
    6c42:	5401      	ret

00006c44 <_moduleCommFlagUpdated>:

bool_t moduleCommFlagUpdated(void)
{
  if (melNewData == 1)
    6c44:	7ad8 11da 	lod	Y, 0x11da <_melNewData>
    6c48:	6001      	lod	AL, #1
    6c4a:	ec01      	cmp	Y, #1
    6c4c:	1901      	je	0x6c50 <.L3>
    6c4e:	6000      	lod	AL, #0

00006c50 <.L3>:
    6c50:	5cf2      	usex	A

00006c52 <.LM15>:
    return btrue;
  else
    return bfalse;
}
    6c52:	5401      	ret

00006c54 <_moduleCommFlagClear>:
static __attribute__((always_inline)) inline
uint16_t builtin_mlx16_get_status (void)
{
    uint16_t status;

    __asm__ __volatile__ (
    6c54:	72e3      	lod	A, M

00006c56 <.LBB87>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    6c56:	08b2      	clrb	MH.2
    6c58:	08b1      	clrb	MH.1
    6c5a:	08b0      	clrb	MH.0

00006c5c <.LBE87>:

void moduleCommFlagClear(void)
{
  ENTER_SECTION(ATOMIC_KEEP_MODE);
  melNewData = 0;
    6c5c:	7800      	lod	Y, #0
    6c5e:	5ad8 11da 	mov	0x11da <_melNewData>, Y

00006c62 <.LBB90>:

 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_status (uint16_t status)
{
    __asm__ __volatile__ (
    6c62:	52e3      	mov	M, A

00006c64 <.LBE84>:
  EXIT_SECTION();
}
    6c64:	5401      	ret

00006c66 <_moduleCommGetData>:

  return result;
}

bool_t moduleCommGetData(SCommMessage *Message)
{
    6c66:	581b      	inc	S, #28

00006c68 <.LCFI0>:
    6c68:	520f      	mov	[S-16], A

00006c6a <.LM23>:
  MeLiBuKBDData_u* ptrMelBuffer;

  /* check for valid dataBuffer */
  if(IO_GET(PORT_MELIBUS_STAT,RD_BUFFER_VALID) == MELBUFFERA)
    6c6a:	72d8 0226 	lod	A, 0x226 <.LASF35+0x4>

00006c6e <.LVL7>:
    6c6e:	9401      	and	AL, #1
    6c70:	1901      	je	0x6c74 <.LM24>
    6c72:	00ef      	jmp	0x6e52 <.L28>

00006c74 <.LM24>:
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferA.rawdataword[0];
  }
  else
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferB.rawdataword[0];
    6c74:	7ada 11de 	lod	Y, #4574

00006c78 <.L49>:
  MeLiBuKBDData_u* ptrMelBuffer;

  /* check for valid dataBuffer */
  if(IO_GET(PORT_MELIBUS_STAT,RD_BUFFER_VALID) == MELBUFFERA)
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferA.rawdataword[0];
    6c78:	5a05      	mov	[S-6], Y

00006c7a <.LM26>:
  ECommFunction result = ECommFunctionNone;

  if (ptrMelBuffer == (MeLiBuKBDData_u*)0)
	  return ECommFunctionNone;

  instrCode = ptrMelBuffer->MelData.melibuID.instrExt_SubAdr;
    6c7a:	7af0      	lod	Y, [Y]

00006c7c <.LVL9>:
    6c7c:	5a15      	mov	[S-22], Y
    6c7e:	44b8      	lsr	YL, #2
    6c80:	f43f      	and	Y, #63
    6c82:	461b      	mov	[S-28], YL
    6c84:	5cf6      	usex	Y
    6c86:	7ee6      	lod	X, Y

00006c88 <.LM27>:

  if(ptrMelBuffer->MelData.melibuID.functionType == 1)
    6c88:	7a15      	lod	Y, [S-22]
    6c8a:	f6da 0100 	and	Y, #256
    6c8e:	5a09      	mov	[S-10], Y
    6c90:	1d16      	jne	0x6cbe <.L37>
    6c92:	5a11      	mov	[S-18], Y

00006c94 <.LM28>:
/* store flag for EEPROM write command */
//static volatile uint16_t eeWriteIDFlag = 0;

static ECommFunction moduleCommGetFunc(MeLiBuKBDData_u* ptrMelBuffer, SCommMessage *Message)
{
  uint8_t instrCode = 0, counter = 0;
    6c94:	5a07      	mov	[S-8], Y

00006c96 <.L14>:
  }
  else if(ptrMelBuffer->MelData.melibuID.functionType == 0)
  {
	  for (lenIndex = 0; lenIndex < 3; lenIndex++)
	  {
		  if (instrCode & (1<<lenIndex))
    6c96:	7aee      	lod	Y, X
    6c98:	7211      	lod	A, [S-18]
    6c9a:	ac00      	cmp	A, #0
    6c9c:	1b03      	jsle	0x6ca4 <.L53>
    6c9e:	42e9      	mov	Cx, AL
    6ca0:	4476      	asr	Y
    6ca2:	1ffe      	djnz	Cx, 0x6ca0 <.LASF730+0x6>

00006ca4 <.L53>:
    6ca4:	5a13      	mov	[S-20], Y
    6ca6:	f401      	and	Y, #1
    6ca8:	1904      	je	0x6cb2 <.L13>

00006caa <.LM30>:
			  counter++;
    6caa:	6207      	lod	AL, [S-8]
    6cac:	8001      	add	AL, #1

00006cae <.LVL12>:
    6cae:	5cf2      	usex	A
    6cb0:	5207      	mov	[S-8], A

00006cb2 <.L13>:
    6cb2:	7a11      	lod	Y, [S-18]
    6cb4:	e001      	add	Y, #1
    6cb6:	5a11      	mov	[S-18], Y

00006cb8 <.LM31>:
		  {}
	  }
  }
  else if(ptrMelBuffer->MelData.melibuID.functionType == 0)
  {
	  for (lenIndex = 0; lenIndex < 3; lenIndex++)
    6cb8:	ec03      	cmp	Y, #3
    6cba:	1d6d      	jne	0x6c96 <.L14>
    6cbc:	001a      	jmp	0x6cf2 <.L12>

00006cbe <.L37>:
  if (ptrMelBuffer == (MeLiBuKBDData_u*)0)
	  return ECommFunctionNone;

  instrCode = ptrMelBuffer->MelData.melibuID.instrExt_SubAdr;

  if(ptrMelBuffer->MelData.melibuID.functionType == 1)
    6cbe:	7800      	lod	Y, #0
    6cc0:	5a11      	mov	[S-18], Y

00006cc2 <.LM33>:
/* store flag for EEPROM write command */
//static volatile uint16_t eeWriteIDFlag = 0;

static ECommFunction moduleCommGetFunc(MeLiBuKBDData_u* ptrMelBuffer, SCommMessage *Message)
{
  uint8_t instrCode = 0, counter = 0;
    6cc2:	5a07      	mov	[S-8], Y
    6cc4:	7006      	lod	A, #6
    6cc6:	5217      	mov	[S-24], A

00006cc8 <.L11>:

  if(ptrMelBuffer->MelData.melibuID.functionType == 1)
  {
	  for (lenIndex = 0; lenIndex < 6; lenIndex++)
	  {
		  if (instrCode & (1<<lenIndex))
    6cc8:	7aee      	lod	Y, X
    6cca:	7211      	lod	A, [S-18]
    6ccc:	ac00      	cmp	A, #0
    6cce:	1b03      	jsle	0x6cd6 <.L55>
    6cd0:	42e9      	mov	Cx, AL
    6cd2:	4476      	asr	Y
    6cd4:	1ffe      	djnz	Cx, 0x6cd2 <.LASF713+0x3>

00006cd6 <.L55>:
    6cd6:	5a13      	mov	[S-20], Y
    6cd8:	f401      	and	Y, #1
    6cda:	1904      	je	0x6ce4 <.L10>

00006cdc <.LM35>:
			  counter++;
    6cdc:	6207      	lod	AL, [S-8]
    6cde:	8001      	add	AL, #1

00006ce0 <.LVL17>:
    6ce0:	5cf2      	usex	A
    6ce2:	5207      	mov	[S-8], A

00006ce4 <.L10>:
    6ce4:	7a11      	lod	Y, [S-18]
    6ce6:	e001      	add	Y, #1
    6ce8:	5a11      	mov	[S-18], Y

00006cea <.LM36>:

  instrCode = ptrMelBuffer->MelData.melibuID.instrExt_SubAdr;

  if(ptrMelBuffer->MelData.melibuID.functionType == 1)
  {
	  for (lenIndex = 0; lenIndex < 6; lenIndex++)
    6cea:	7217      	lod	A, [S-24]
    6cec:	a0ff      	add	A, #-1
    6cee:	5217      	mov	[S-24], A
    6cf0:	1d6b      	jne	0x6cc8 <.L11>

00006cf2 <.L12>:
		  else
		  {}
	  }
  }

  Message->msgLength = counter*6;
    6cf2:	7207      	lod	A, [S-8]
    6cf4:	4872 0006 	muls	A, A, #6
    6cf8:	7a0f      	lod	Y, [S-16]
    6cfa:	52f4      	mov	[Y+4], A

00006cfc <.LM38>:

  if (ptrMelBuffer->MelData.melibuID.functionType == 1)
    6cfc:	7a09      	lod	Y, [S-10]
    6cfe:	1919      	je	0x6d32 <.L15>

00006d00 <.LM39>:
  {
	 switch(ptrMelBuffer->MelData.protocolBuffer[1])
    6d00:	7e05      	lod	X, [S-6]
    6d02:	62fb      	lod	AL, [X+3]
    6d04:	5cf2      	usex	A
    6d06:	1905      	je	0x6d12 <.L17>
    6d08:	aeda 00aa 	cmp	A, #170
    6d0c:	190a      	je	0x6d22 <.L18>

00006d0e <.L46>:
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferB.rawdataword[0];
  }

  if (moduleCommGetFunc(ptrMelBuffer, Message) == ECommFunctionNone)
	  return bfalse;
    6d0e:	7000      	lod	A, #0
    6d10:	541d      	ret	#30

00006d12 <.L17>:
  {
	 switch(ptrMelBuffer->MelData.protocolBuffer[1])
	 {
	     case 0x00:
	     {
	    	 Message->func = ECommFunctionLedColor;
    6d12:	7001      	lod	A, #1
    6d14:	7a0f      	lod	Y, [S-16]
    6d16:	52f0      	mov	[Y], A

00006d18 <.LM42>:
			 Message->data = &ptrMelBuffer->MelData.protocolBuffer[2];
    6d18:	7a05      	lod	Y, [S-6]
    6d1a:	e004      	add	Y, #4

00006d1c <.L50>:
			  break;

			  case 0x01:
			  {
				  Message->func = ECommFunctionRequestCalData;
				  Message->data = &ptrMelBuffer->MelData.protocolBuffer[0];
    6d1c:	7e0f      	lod	X, [S-16]
    6d1e:	5afe      	mov	[X+6], Y

00006d20 <.LVL21>:
    6d20:	541d      	ret	#30

00006d22 <.L18>:
	     }
	     break;

	     case 0xAA:
	     {
	    	 Message->func = ECommFunctionCalData;
    6d22:	7003      	lod	A, #3

00006d24 <.L51>:
      {
    	  switch(ptrMelBuffer->MelData.protocolBuffer[1])
    	  {
			  case 0x00:
			  {
				  Message->func = ECommFunctionCalLed;
    6d24:	7a0f      	lod	Y, [S-16]
    6d26:	52f0      	mov	[Y], A

00006d28 <.LM46>:
				  Message->data = &ptrMelBuffer->MelData.protocolBuffer[0];
    6d28:	7205      	lod	A, [S-6]
    6d2a:	a002      	add	A, #2
    6d2c:	52f6      	mov	[Y+6], A

00006d2e <.L52>:
  }

  if (moduleCommGetFunc(ptrMelBuffer, Message) == ECommFunctionNone)
	  return bfalse;
  else
	  return btrue;
    6d2e:	7001      	lod	A, #1
    6d30:	541d      	ret	#30

00006d32 <.L15>:
	     break;
	 }
  }
  else
  {
    if(((instrCode>>3)&0x07) == 0x00)//KBD Function
    6d32:	621b      	lod	AL, [S-28]
    6d34:	44b0      	lsr	AL, #2
    6d36:	4430      	lsr	AL
    6d38:	b407      	and	A, #7
    6d3a:	1d18      	jne	0x6d6c <.L19>

00006d3c <.LM49>:
    {
      if (ptrMelBuffer->MelData.melibuID.readWrite == 0)//RT == 0 Receive
    6d3c:	7215      	lod	A, [S-22]
    6d3e:	b6da 0200 	and	A, #512
    6d42:	1d65      	jne	0x6d0e <.L46>

00006d44 <.LM50>:
      {
    	  switch(ptrMelBuffer->MelData.protocolBuffer[1])
    6d44:	7e05      	lod	X, [S-6]
    6d46:	62fb      	lod	AL, [X+3]
    6d48:	5cf2      	usex	A
    6d4a:	ac01      	cmp	A, #1
    6d4c:	1909      	je	0x6d60 <.L20>
    6d4e:	1806      	jc	0x6d5c <.L21>
    6d50:	ac02      	cmp	A, #2
    6d52:	1d5d      	jne	0x6d0e <.L46>

00006d54 <.LM51>:
			  }
			  break;

			  case 0x02:
			  {
				  Message->func = ECommFunctionRequestLedStatus;
    6d54:	7005      	lod	A, #5
    6d56:	7a0f      	lod	Y, [S-16]
    6d58:	52f0      	mov	[Y], A

00006d5a <.LVL25>:
    6d5a:	07e9      	jmp	0x6d2e <.L52>

00006d5c <.L21>:
      {
    	  switch(ptrMelBuffer->MelData.protocolBuffer[1])
    	  {
			  case 0x00:
			  {
				  Message->func = ECommFunctionCalLed;
    6d5c:	7002      	lod	A, #2
    6d5e:	07e2      	jmp	0x6d24 <.L51>

00006d60 <.L20>:
			  }
			  break;

			  case 0x01:
			  {
				  Message->func = ECommFunctionRequestCalData;
    6d60:	7c04      	lod	X, #4
    6d62:	7a0f      	lod	Y, [S-16]
    6d64:	5ef0      	mov	[Y], X

00006d66 <.LM54>:
				  Message->data = &ptrMelBuffer->MelData.protocolBuffer[0];
    6d66:	7a05      	lod	Y, [S-6]
    6d68:	e002      	add	Y, #2
    6d6a:	07d8      	jmp	0x6d1c <.L50>

00006d6c <.L19>:
    	  }
      }
    }
    else//MELEXIS Function
    {
      if (((instrCode>>3)&0x07) == 0x07)
    6d6c:	ac07      	cmp	A, #7
    6d6e:	1d4f      	jne	0x6d0e <.L46>

00006d70 <.LM56>:
      {
        /* check if enter programming mode message has been received */
        if((ptrMelBuffer->rawdataword[1]==0x00FEu) && (ptrMelBuffer->rawdataword[2]==0xDEADu) && \
    6d70:	7a05      	lod	Y, [S-6]
    6d72:	7ef2      	lod	X, [Y+2]
    6d74:	2eda 00fe 	cmp	X, #254
    6d78:	1d1e      	jne	0x6db6 <.L23>
    6d7a:	7ef4      	lod	X, [Y+4]
    6d7c:	2eda dead 	cmp	X, #57005
    6d80:	1901      	je	0x6d84 <.LASF643+0x2>
    6d82:	0056      	jmp	0x6e30 <.L35>
    6d84:	7ef6      	lod	X, [Y+6]
    6d86:	2eda beef 	cmp	X, #48879
    6d8a:	1901      	je	0x6d8e <.LM57>
    6d8c:	0051      	jmp	0x6e30 <.L35>

00006d8e <.LM57>:
           (ptrMelBuffer->rawdataword[3]==0xBEEFu))
        {
        	result = ECommFunctionEnterProgrammingMode;
			Message->func = ECommFunctionEnterProgrammingMode;
    6d8e:	7e0f      	lod	X, [S-16]
    6d90:	52f8      	mov	[X], A

00006d92 <.LM58>:

            /* EPM received -> set programming mode state and reset */
            bl_table.NAD = IO_GET(PORT_ID, ID);
    6d92:	72d8 021a 	lod	A, 0x21a <.LASF67+0x3>
    6d96:	b43f      	and	A, #63
    6d98:	52d8 17e4 	mov	0x17e4 <.LASF450+0x1>, A

00006d9c <.LM59>:
            bl_table.key = BL_TABLE_KEY;
    6d9c:	72da 4832 	lod	A, #18482
    6da0:	52d8 17e0 	mov	0x17e0 <_bl_table>, A
    6da4:	72da 0515 	lod	A, #1301
    6da8:	52d8 17e2 	mov	0x17e2 <_bl_table+0x2>, A

00006dac <.LM60>:
            MLX16_RESET_SIGNED(C_CHIP_STATE_CMD_EPM);
    6dac:	72da 3065 	lod	A, #12389
    6db0:	82db 1429 	callf	0x2852 <_MLX16_RESET_SIGNED>

00006db4 <.LVL28>:
    6db4:	07bc      	jmp	0x6d2e <.L52>

00006db6 <.L23>:
        }
        else
        {
            if(ptrMelBuffer->rawdataword[1]==0x00FCu)
    6db6:	2eda 00fc 	cmp	X, #252
    6dba:	1901      	je	0x6dbe <.LM62>
    6dbc:	0039      	jmp	0x6e30 <.L35>

00006dbe <.LM62>:
            {
            	result = ECommFunctionAutoAddressing;
            	Message->func = ECommFunctionAutoAddressing;
    6dbe:	7806      	lod	Y, #6
    6dc0:	7e0f      	lod	X, [S-16]
    6dc2:	5af8      	mov	[X], Y
    6dc4:	7a05      	lod	Y, [S-6]
    6dc6:	72f6      	lod	A, [Y+6]
    6dc8:	5201      	mov	[S-2], A
    6dca:	5cf2      	usex	A

00006dcc <.LM63>:
                /* Auto-addressing */
                eeWriteIDFlag = (uint8_t)(ptrMelBuffer->rawdataword[3]&0x00FFu);
    6dcc:	52d8 11d6 	mov	0x11d6 <_eeWriteIDFlag>, A

00006dd0 <.LM64>:

                IO_SET(PORT_DMA_TX, DMA_TX, (uint16_t)((uint16_t *)&meLiBuAATransmit[0]));
    6dd0:	72da 1032 	lod	A, #4146
    6dd4:	52d8 0220 	mov	0x220 <.LASF67+0x9>, A

00006dd8 <.LM65>:
                Mel_CmdAutoAddressing((uint8_t)(ptrMelBuffer->rawdataword[2]&0x00FFu));
    6dd8:	7af4      	lod	Y, [Y+4]
    6dda:	62e8      	lod	AL, YL
    6ddc:	5cf2      	usex	A
    6dde:	520f      	mov	[S-16], A

00006de0 <.LBB154>:

/* ----------------------------------------------------------------------------
 * handle MeLiBu auto-addressing
 */
static INLINE void Mel_CmdAutoAddressing(uint8_t slaveAddress){
    if (slaveAddress < 4u) {
    6de0:	ac03      	cmp	A, #3
    6de2:	1e0c      	jug	0x6dfc <.L25>

00006de4 <.LM67>:
        /* If slave address == 0, 1, 2, 3 -> start auto addressing sequence */
        Mel_ClearAAoutPin();
    6de4:	82db 1a91 	callf	0x3522 <_Mel_ClearAAoutPin>

00006de8 <.LM68>:
//        Mel_SetNewNAD(BL_MEL_DEFAULT_ADDRESS);
        IO_SET(PORT_ID, ID, BL_MEL_DEFAULT_ADDRESS);
    6de8:	62d8 021a 	lod	AL, 0x21a <.LASF67+0x3>
    6dec:	843f      	or	AL, #63
    6dee:	42d8 021a 	mov	0x21a <.LASF67+0x3>, AL

00006df2 <.LM69>:
        meLiBuAATransmit[1] = ((uint16_t)(BL_MEL_DEFAULT_ADDRESS)&0x00FF);
    6df2:	703f      	lod	A, #63
    6df4:	52d8 1034 	mov	0x1034 <_meLiBuAATransmit+0x2>, A

00006df8 <.L36>:
        }
        else
        {
            if(ptrMelBuffer->rawdataword[1]==0x00FCu)
            {
            	result = ECommFunctionAutoAddressing;
    6df8:	7006      	lod	A, #6
    6dfa:	001b      	jmp	0x6e32 <.L24>

00006dfc <.L25>:
        Mel_ClearAAoutPin();
//        Mel_SetNewNAD(BL_MEL_DEFAULT_ADDRESS);
        IO_SET(PORT_ID, ID, BL_MEL_DEFAULT_ADDRESS);
        meLiBuAATransmit[1] = ((uint16_t)(BL_MEL_DEFAULT_ADDRESS)&0x00FF);
    }
    else if (Mel_GetAAinStatus() != 0u) {
    6dfc:	5a0d      	mov	[S-14], Y
    6dfe:	82db 1a9a 	callf	0x3534 <_Mel_GetAAinStatus>

00006e02 <.LVL34>:
    6e02:	7a0d      	lod	Y, [S-14]
    6e04:	ac00      	cmp	A, #0
    6e06:	1978      	je	0x6df8 <.L36>
    6e08:	5cf6      	usex	Y

00006e0a <.LM72>:
        /* if AA input pin is high and (NAD >= 4)  -> Set new address */
//    	Mel_SetNewNAD(slaveAddress);
        meLiBuAATransmit[1] = ((uint16_t)(slaveAddress)&0x00FF);
    6e0a:	5ad8 1034 	mov	0x1034 <_meLiBuAATransmit+0x2>, Y

00006e0e <.LM73>:
        IO_SET(PORT_ID, ID, slaveAddress);
    6e0e:	62d8 021a 	lod	AL, 0x21a <.LASF67+0x3>
    6e12:	94c0      	and	AL, #-64
    6e14:	860f      	or	AL, [S-16]
    6e16:	42d8 021a 	mov	0x21a <.LASF67+0x3>, AL

00006e1a <.LM74>:
        savedConfig.nad = slaveAddress;
    6e1a:	660f      	lod	YL, [S-16]
    6e1c:	46d8 1364 	mov	0x1364 <_savedConfig>, YL

00006e20 <.LM75>:
	    Set_Last_Address(slaveAddress);
    6e20:	720f      	lod	A, [S-16]
    6e22:	118d      	call	0x713e <_Set_Last_Address>

00006e24 <.LM76>:
	    Auto_Addressing_Write_NAD_TO_EEPROM(slaveAddress);
    6e24:	720f      	lod	A, [S-16]
    6e26:	118e      	call	0x7144 <_Auto_Addressing_Write_NAD_TO_EEPROM>

00006e28 <.LM77>:
	    aaoutflag = 1u;
    6e28:	6001      	lod	AL, #1
    6e2a:	42d8 11d8 	mov	0x11d8 <_aaoutflag>, AL
    6e2e:	07e4      	jmp	0x6df8 <.L36>

00006e30 <.L35>:

static ECommFunction moduleCommGetFunc(MeLiBuKBDData_u* ptrMelBuffer, SCommMessage *Message)
{
  uint8_t instrCode = 0, counter = 0;
  uint8_t lenIndex = 0;
  ECommFunction result = ECommFunctionNone;
    6e30:	7209      	lod	A, [S-10]

00006e32 <.L24>:
                eeWriteIDFlag = (uint8_t)(ptrMelBuffer->rawdataword[3]&0x00FFu);

                IO_SET(PORT_DMA_TX, DMA_TX, (uint16_t)((uint16_t *)&meLiBuAATransmit[0]));
                Mel_CmdAutoAddressing((uint8_t)(ptrMelBuffer->rawdataword[2]&0x00FFu));
            }
            if(ptrMelBuffer->rawdataword[1]==0x00C0u)
    6e32:	7e05      	lod	X, [S-6]
    6e34:	7afa      	lod	Y, [X+2]
    6e36:	eeda 00c0 	cmp	Y, #192
    6e3a:	1d04      	jne	0x6e44 <.L26>

00006e3c <.LM80>:
            {
                /* sleep Mode */
            	modulePowerEnterSleep();
    6e3c:	520d      	mov	[S-14], A
    6e3e:	82db 3b3e 	callf	0x767c <_modulePowerEnterSleep>

00006e42 <.LVL39>:
    6e42:	720d      	lod	A, [S-14]

00006e44 <.L26>:
  else
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferB.rawdataword[0];
  }

  if (moduleCommGetFunc(ptrMelBuffer, Message) == ECommFunctionNone)
    6e44:	6401      	lod	YL, #1
    6e46:	ac00      	cmp	A, #0
    6e48:	1d01      	jne	0x6e4c <.L27>
    6e4a:	66e0      	lod	YL, AL

00006e4c <.L27>:
	  return bfalse;
    6e4c:	62e8      	lod	AL, YL
    6e4e:	5cf2      	usex	A
    6e50:	541d      	ret	#30

00006e52 <.L28>:
  MeLiBuKBDData_u* ptrMelBuffer;

  /* check for valid dataBuffer */
  if(IO_GET(PORT_MELIBUS_STAT,RD_BUFFER_VALID) == MELBUFFERA)
  {
      ptrMelBuffer = (MeLiBuKBDData_u*)&meLiBuBufferA.rawdataword[0];
    6e52:	7ada 1206 	lod	Y, #4614
    6e56:	0710      	jmp	0x6c78 <.L49>

00006e58 <_Get_Transmit_Lock>:
	  return btrue;
}

uint16_t Get_Transmit_Lock(void)
{
	return meLiBuLEDTransmitLock;
    6e58:	72d8 11dc 	lod	A, 0x11dc <_meLiBuLEDTransmitLock>

00006e5c <.LM86>:
}
    6e5c:	5401      	ret

00006e5e <__MFT_INT>:

/* Frame transmitted interrupt */
__attribute__((interrupt)) void  _MFT_INT(void){
    6e5e:	5edf      	push	X

00006e60 <.LCFI1>:
    6e60:	5adf      	push	Y

00006e62 <.LCFI2>:
    6e62:	52df      	push	A

00006e64 <.LCFI3>:
    6e64:	4c83      	push	D

00006e66 <.LCFI4>:
    6e66:	5801      	inc	S, #2

00006e68 <.LCFI5>:
    /* copy transmit buffer if requested */

   // uint16_t i = 0; /* local variable for loop */

    /* release buffer lock -> transmit buffer change allowed */
    meLiBuLEDTransmitLock = 0;
    6e68:	7800      	lod	Y, #0
    6e6a:	5ad8 11dc 	mov	0x11dc <_meLiBuLEDTransmitLock>, Y

00006e6e <.LM89>:
//    else {
//        /* get MeLiBu error */
//        meLiBuStateTransmit[0][2] = (IO_HOST(PORT_MELIBUS_STAT,RD_BUFFER_VALID) & (MASKMELIBUERROR));
//    }

    if(aaoutflag == 1)
    6e6e:	62d8 11d8 	lod	AL, 0x11d8 <_aaoutflag>
    6e72:	8c01      	cmp	AL, #1
    6e74:	1d19      	jne	0x6ea8 <.L58>

00006e76 <.LM90>:
    {
    	/* reset flag */
    	aaoutflag = 0;
    6e76:	46d8 11d8 	mov	0x11d8 <_aaoutflag>, YL

00006e7a <.LM91>:

    	/* Set AAOUT pin high */
    	Mel_SetAAoutPin();
    6e7a:	5a01      	mov	[S-2], Y
    6e7c:	82db 1a88 	callf	0x3510 <_Mel_SetAAoutPin>

00006e80 <.LM92>:

    	if(eeWriteIDFlag == 1)
    6e80:	72d8 11d6 	lod	A, 0x11d6 <_eeWriteIDFlag>
    6e84:	7a01      	lod	Y, [S-2]
    6e86:	ac01      	cmp	A, #1
    6e88:	1d0f      	jne	0x6ea8 <.L58>

00006e8a <.LBB162>:
static __attribute__((always_inline)) inline
uint16_t builtin_mlx16_get_status (void)
{
    uint16_t status;

    __asm__ __volatile__ (
    6e8a:	72e3      	lod	A, M

00006e8c <.LBB165>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    6e8c:	08b2      	clrb	MH.2
    6e8e:	08b1      	clrb	MH.1
    6e90:	08b0      	clrb	MH.0

00006e92 <.LBE165>:
    	{
    		ENTER_SECTION(ATOMIC_KEEP_MODE);
    		/* clear write flag */
    		eeWriteIDFlag = 0;
    6e92:	5ad8 11d6 	mov	0x11d6 <_eeWriteIDFlag>, Y

00006e96 <.LBB168>:

 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_status (uint16_t status)
{
    __asm__ __volatile__ (
    6e96:	52e3      	mov	M, A

00006e98 <.LBE162>:
    		EXIT_SECTION();

    		if (flashFlag == EFlashUpdateFree)
    6e98:	72d8 1362 	lod	A, 0x1362 <_flashFlag>
    6e9c:	1d05      	jne	0x6ea8 <.L58>

00006e9e <.LM98>:
    			flashFlag |= EFlashUpdateProcessing;
    6e9e:	72d8 1362 	lod	A, 0x1362 <_flashFlag>
    6ea2:	a401      	or	A, #1
    6ea4:	52d8 1362 	mov	0x1362 <_flashFlag>, A

00006ea8 <.L58>:
    	}
    }
}
    6ea8:	5c01      	dec	S, #2
    6eaa:	4cc3      	pop	D

00006eac <.LCFI6>:
    6eac:	72cf      	pop	A

00006eae <.LCFI7>:
    6eae:	7acf      	pop	Y

00006eb0 <.LCFI8>:
    6eb0:	7ecf      	pop	X

00006eb2 <.LCFI9>:
    6eb2:	72cb      	pop	M
    6eb4:	5401      	ret

00006eb6 <__MFR_INT>:
/* Frame received interrupt */
__attribute__((interrupt)) void  _MFR_INT(void){
    6eb6:	52df      	push	A

00006eb8 <.LCFI10>:
    /* signalize that new data have been received */
    melNewData = 1;
    6eb8:	7001      	lod	A, #1
    6eba:	52d8 11da 	mov	0x11da <_melNewData>, A

00006ebe <.LM102>:
}
    6ebe:	72cf      	pop	A

00006ec0 <.LCFI11>:
    6ec0:	72cb      	pop	M
    6ec2:	5401      	ret

00006ec4 <__MHR_INT>:

/* Header received interrupt */
__attribute__((interrupt)) void  _MHR_INT(void){
    6ec4:	52df      	push	A

00006ec6 <.LCFI12>:
    /* signalize to application that transmit buffer must not be changed */
    meLiBuLEDTransmitLock = 1;
    6ec6:	7001      	lod	A, #1
    6ec8:	52d8 11dc 	mov	0x11dc <_meLiBuLEDTransmitLock>, A

00006ecc <.LM105>:
}
    6ecc:	72cf      	pop	A

00006ece <.LCFI13>:
    6ece:	72cb      	pop	M
    6ed0:	5401      	ret

00006ed2 <__MER_INT>:

/* Frame error interrupt */
__attribute__((interrupt)) void  _MER_INT(void){
    6ed2:	52df      	push	A

00006ed4 <.LCFI14>:
    /* Melibu error handler */

    /* read 16 Bit status port and mask error flags for crc and parity */
    meLiBuStateTransmit[0] = (IO_HOST(PORT_MELIBUS_STAT,RD_BUFFER_VALID) & (MASKMELIBUERROR));
    6ed4:	72d8 0226 	lod	A, 0x226 <.LASF35+0x4>
    6ed8:	b6da 00f8 	and	A, #248
    6edc:	52d8 1038 	mov	0x1038 <_meLiBuStateTransmit>, A

00006ee0 <.LM108>:
}
    6ee0:	72cf      	pop	A

00006ee2 <.LCFI15>:
    6ee2:	72cb      	pop	M
    6ee4:	5401      	ret

00006ee6 <__TX_TIMEOUT_INT>:

/* txd time out error */
__attribute__((interrupt)) void  _TX_TIMEOUT_INT(void){
    /* provide handler here */
}
    6ee6:	72cb      	pop	M
    6ee8:	5401      	ret

00006eea <___calcEEChecksum_constprop_1>:
volatile EFlashUpdate flashFlag;

/* ----------------------------------------------------------------------------
 * calculate checksum according CRC CCITT
 */
static uint16_t calcEEChecksum(uint16_t startaddress, uint16_t length){
    6eea:	5803      	inc	S, #4

00006eec <.LCFI0>:
    6eec:	7ae2      	lod	Y, A

00006eee <.LVL1>:
    6eee:	a006      	add	A, #6

00006ef0 <.LVL2>:
    6ef0:	5203      	mov	[S-4], A

00006ef2 <.LM2>:
    uint16_t crc = 0;
    6ef2:	7000      	lod	A, #0

00006ef4 <.L2>:
    uint16_t i = 0;
    uint8_t* ptrData=(uint8_t*)startaddress;

    /* calculate checksum over provided data */
    for(i = 0; i < length; i++) {
        crc = crc_ccitt (*ptrData++, crc);
    6ef4:	7ee6      	lod	X, Y
    6ef6:	2001      	add	X, #1

00006ef8 <.LVL4>:
    6ef8:	66f0      	lod	YL, [Y]
    6efa:	5cf6      	usex	Y
    6efc:	52df      	push	A

00006efe <.LCFI1>:
    6efe:	72e6      	lod	A, Y

00006f00 <.LVL6>:
    6f00:	5e03      	mov	[S-4], X
    6f02:	82db 2db6 	callf	0x5b6c <_crc_ccitt>

00006f06 <.LVL7>:
    6f06:	7e03      	lod	X, [S-4]
    6f08:	7aee      	lod	Y, X

00006f0a <.LM4>:
    uint16_t crc = 0;
    uint16_t i = 0;
    uint8_t* ptrData=(uint8_t*)startaddress;

    /* calculate checksum over provided data */
    for(i = 0; i < length; i++) {
    6f0a:	5c01      	dec	S, #2

00006f0c <.LCFI2>:
    6f0c:	2e03      	cmp	X, [S-4]
    6f0e:	1d72      	jne	0x6ef4 <.L2>

00006f10 <.LM5>:
        crc = crc_ccitt (*ptrData++, crc);
    }

    return crc;
}
    6f10:	5405      	ret	#6

00006f12 <_moduleFlashLoad>:
  else
    return bfalse;
}

void moduleFlashLoad(void)
{
    6f12:	5803      	inc	S, #4

00006f14 <.LCFI3>:
    6f14:	7ada 0850 	lod	Y, #2128
    6f18:	7eda 00d0 	lod	X, #208
    6f1c:	5e01      	mov	[S-2], X

00006f1e <.L5>:

  uint8_t* dataPtr = (uint8_t*)EE_DYNAMIC_AREA_START_KEBODA;
  uint8_t* dataDest = (uint8_t*)&savedConfig;

  for (index = 0; index < sizeof(struct FlashContent); index++)
    *(dataDest + index) = *(dataPtr + index);
    6f1e:	7ee6      	lod	X, Y
    6f20:	22da 0b14 	add	X, #2836
    6f24:	62f0      	lod	AL, [Y]
    6f26:	42f8      	mov	[X], AL
    6f28:	e001      	add	Y, #1

00006f2a <.LM9>:
  uint16_t index = 0;

  uint8_t* dataPtr = (uint8_t*)EE_DYNAMIC_AREA_START_KEBODA;
  uint8_t* dataDest = (uint8_t*)&savedConfig;

  for (index = 0; index < sizeof(struct FlashContent); index++)
    6f2a:	7e01      	lod	X, [S-2]
    6f2c:	20ff      	add	X, #-1
    6f2e:	5e01      	mov	[S-2], X
    6f30:	1d76      	jne	0x6f1e <.L5>

00006f32 <.LM10>:
    *(dataDest + index) = *(dataPtr + index);
}
    6f32:	5405      	ret	#6

00006f34 <_moduleFlashSave>:

  moduleFlashSave();
}

void moduleFlashSave(void)
{
    6f34:	5817      	inc	S, #24

00006f36 <.LCFI4>:
    6f36:	7ada 0850 	lod	Y, #2128

00006f3a <.L12>:
    6f3a:	72e6      	lod	A, Y
    6f3c:	a2da 0b14 	add	A, #2836

00006f40 <.LVL15>:
    6f40:	520d      	mov	[S-14], A
    6f42:	5a0b      	mov	[S-12], Y
    6f44:	5209      	mov	[S-10], A
    6f46:	7c08      	lod	X, #8
    6f48:	5e07      	mov	[S-8], X
    6f4a:	7c09      	lod	X, #9
    6f4c:	5e01      	mov	[S-2], X

00006f4e <.L8>:
*@details   Our own string copy function.
*
*@retval    string address.
*/
static bool_t __memcmp(uint8_t* src1, uint8_t* src2, uint16_t len){
  while((*src1++ == *src2++) && (len != 0)){
    6f4e:	7e09      	lod	X, [S-10]
    6f50:	62de      	lod	AL, [X++]

00006f52 <.LVL17>:
    6f52:	5e09      	mov	[S-10], X
    6f54:	5cf2      	usex	A
    6f56:	520f      	mov	[S-16], A
    6f58:	7e0b      	lod	X, [S-12]

00006f5a <.LVL20>:
    6f5a:	62de      	lod	AL, [X++]
    6f5c:	5e0b      	mov	[S-12], X
    6f5e:	5cf2      	usex	A
    6f60:	5203      	mov	[S-4], A
    6f62:	720f      	lod	A, [S-16]
    6f64:	ae03      	cmp	A, [S-4]
    6f66:	1901      	je	0x6f6a <.LASF8+0x4>
    6f68:	0034      	jmp	0x6fd2 <.L9>
    6f6a:	7e01      	lod	X, [S-2]
    6f6c:	20ff      	add	X, #-1
    6f6e:	5e01      	mov	[S-2], X
    6f70:	1d2c      	jne	0x6fca <.L10>

00006f72 <.L11>:
    6f72:	e008      	add	Y, #8

00006f74 <.LBE10>:
  uint16_t index = 0;

  uint8_t* dataPtr = (uint8_t*)EE_DYNAMIC_AREA_START_KEBODA;
  uint8_t* dataDest = (uint8_t*)&savedConfig;

  for (index = 0; index < (sizeof(struct FlashContent)/8); index++)
    6f74:	eeda 0920 	cmp	Y, #2336
    6f78:	1d60      	jne	0x6f3a <.L12>

00006f7a <.LM15>:
    }
    else
    {}
  }

  if (lastAddr != savedConfig.nad)
    6f7a:	62d8 1364 	lod	AL, 0x1364 <_savedConfig>
    6f7e:	66e0      	lod	YL, AL
    6f80:	5cf6      	usex	Y
    6f82:	7ee6      	lod	X, Y
    6f84:	66d8 122e 	lod	YL, 0x122e <_lastAddr>
    6f88:	5cf6      	usex	Y
    6f8a:	eeee      	cmp	Y, X
    6f8c:	191d      	je	0x6fc8 <.L7>

00006f8e <.LM16>:
  {
    lastAddr = savedConfig.nad;
    6f8e:	42d8 122e 	mov	0x122e <_lastAddr>, AL

00006f92 <.LBB13>:

/* ----------------------------------------------------------------------------
 * write node address into EEPROM including VALIDPATTERN, ID and CRC -> 8 data bytes
 */
static INLINE void writeNADintoEEPROM(uint8_t slaveAddress){
    uint16_t eepromArray[4] = {VALIDEEPATTERN,REVISION,0,0};
    6f92:	7aef      	lod	Y, S
    6f94:	e0e8      	add	Y, #-24
    6f96:	7eda 5a10 	lod	X, #23056
    6f9a:	0ea7      	lod	C, ML.7
    6f9c:	54ce      	movsw	[Y++], [X++]
    6f9e:	54ce      	movsw	[Y++], [X++]
    6fa0:	54ce      	movsw	[Y++], [X++]
    6fa2:	54ce      	movsw	[Y++], [X++]

00006fa4 <.LM18>:

    /* write node address into RAM buffer */
    eepromArray[2] = (uint16_t)(slaveAddress&0x003Fu);
    6fa4:	b43f      	and	A, #63

00006fa6 <.LVL23>:
    6fa6:	5213      	mov	[S-20], A

00006fa8 <.LM19>:
    /* calculate CRC from RAM buffer */
    eepromArray[3] = calcEEChecksum((uint16_t)&eepromArray[0],EE_DYNAMIC_LENGTH_WO_CRC);
    6fa8:	72ef      	lod	A, S
    6faa:	a0e8      	add	A, #-24
    6fac:	179e      	call	0x6eea <___calcEEChecksum_constprop_1>
    6fae:	5211      	mov	[S-18], A

00006fb0 <.LM20>:

    /* acknowledge absolute watchdog if needed */
    moduleWDTFeed();
    6fb0:	1396      	call	0x76de <_moduleWDTFeed>

00006fb2 <.LM21>:

    /* write RAM buffer into EEPROM page */
    EEPROM_WriteWord64_blocking(EE_DYNAMIC_AREA_START, eepromArray, EE_WRITE_KEY);
    6fb2:	54ca 0007 	pushw	#7

00006fb6 <.LCFI5>:
    6fb6:	7eef      	lod	X, S
    6fb8:	20e6      	add	X, #-26
    6fba:	5edf      	push	X

00006fbc <.LCFI6>:
    6fbc:	72da 0840 	lod	A, #2112
    6fc0:	82db 116a 	callf	0x22d4 <_EEPROM_WriteWord64_blocking>

00006fc4 <.LM22>:

    /* acknowledge absolute watchdog if needed */
    moduleWDTFeed();
    6fc4:	138c      	call	0x76de <_moduleWDTFeed>
    6fc6:	5c03      	dec	S, #4

00006fc8 <.L7>:
  if (lastAddr != savedConfig.nad)
  {
    lastAddr = savedConfig.nad;
    writeNADintoEEPROM(lastAddr);
  }
}
    6fc8:	5419      	ret	#26

00006fca <.L10>:
*
*@retval    string address.
*/
static bool_t __memcmp(uint8_t* src1, uint8_t* src2, uint16_t len){
  while((*src1++ == *src2++) && (len != 0)){
    len--;
    6fca:	7207      	lod	A, [S-8]
    6fcc:	a0ff      	add	A, #-1
    6fce:	5207      	mov	[S-8], A

00006fd0 <.LVL29>:
    6fd0:	07be      	jmp	0x6f4e <.L8>

00006fd2 <.L9>:
  }

  if (len == 0)
    6fd2:	7207      	lod	A, [S-8]
    6fd4:	194e      	je	0x6f72 <.L11>

00006fd6 <.LM26>:

  for (index = 0; index < (sizeof(struct FlashContent)/8); index++)
  {
    if (__memcmp(dataDest + index*8, dataPtr + index*8, 8) != btrue)
    {
      moduleWDTFeed();
    6fd6:	5a05      	mov	[S-6], Y
    6fd8:	1382      	call	0x76de <_moduleWDTFeed>

00006fda <.LM27>:
      EEPROM_WriteWord64_blocking((uint16_t)(dataPtr + index*8), (uint16_t*)((uint16_t)dataDest + index*8), EE_WRITE_KEY);
    6fda:	54ca 0007 	pushw	#7

00006fde <.LCFI8>:
    6fde:	7e0f      	lod	X, [S-16]
    6fe0:	5edf      	push	X

00006fe2 <.LCFI9>:
    6fe2:	7a09      	lod	Y, [S-10]
    6fe4:	72e6      	lod	A, Y
    6fe6:	82db 116a 	callf	0x22d4 <_EEPROM_WriteWord64_blocking>

00006fea <.LM28>:
      moduleWDTFeed();
    6fea:	1379      	call	0x76de <_moduleWDTFeed>
    6fec:	5c03      	dec	S, #4

00006fee <.LCFI10>:
    6fee:	7a05      	lod	Y, [S-6]
    6ff0:	07c0      	jmp	0x6f72 <.L11>

00006ff2 <_moduleFlashInit>:

#define CURRENTSWVERSION 196
#define CURRENTHWVERSION   8

void moduleFlashInit(void)
{
    6ff2:	5807      	inc	S, #8

00006ff4 <.LCFI11>:
  uint16_t index = 0;

  moduleFlashLoad();
    6ff4:	178e      	call	0x6f12 <_moduleFlashLoad>

00006ff6 <.LM31>:

  if (savedConfig.magicNO != D_MAGIC_NUMBER)
    6ff6:	72d8 142c 	lod	A, 0x142c <.LASF632+0xc>
    6ffa:	aeda b0da 	cmp	A, #45274
    6ffe:	1d01      	jne	0x7002 <.LM32>
    7000:	0088      	jmp	0x7112 <.L19>

00007002 <.LM32>:
  {
    savedConfig.magicNO = D_MAGIC_NUMBER;
    7002:	72da b0da 	lod	A, #45274
    7006:	52d8 142c 	mov	0x142c <.LASF632+0xc>, A

0000700a <.LM33>:
    savedConfig.nad = 63;
    700a:	72da 013f 	lod	A, #319
    700e:	52d8 1364 	mov	0x1364 <_savedConfig>, A

00007012 <.LM34>:
    savedConfig.LedNumber = 1;
    savedConfig.SWVersion = CURRENTSWVERSION;//v196
    7012:	72da 00c4 	lod	A, #196
    7016:	52d8 142e 	mov	0x142e <.LASF633>, A

0000701a <.LM35>:
    savedConfig.HWVersion = CURRENTHWVERSION;//H08
    701a:	7008      	lod	A, #8
    701c:	52d8 1430 	mov	0x1430 <.LASF633+0x2>, A
    7020:	7ada 1366 	lod	Y, #4966
    7024:	5a01      	mov	[S-2], Y
    7026:	7eda 1408 	lod	X, #5128
    702a:	5e03      	mov	[S-4], X

0000702c <.LM36>:

    for (index = 0; index < RGBLEDMAX; index++)
    702c:	7000      	lod	A, #0
    702e:	5205      	mov	[S-6], A

00007030 <.LM37>:
    {
      savedConfig.redx[index] = 6071;
      savedConfig.redy[index] = 2499;
      savedConfig.redY[index] = 19680;
    7030:	4cc2 4ce0 	mov	D, #19680
    7034:	0000 
    7036:	7c06      	lod	X, #6
    7038:	5e07      	mov	[S-8], X

0000703a <.L20>:
    savedConfig.SWVersion = CURRENTSWVERSION;//v196
    savedConfig.HWVersion = CURRENTHWVERSION;//H08

    for (index = 0; index < RGBLEDMAX; index++)
    {
      savedConfig.redx[index] = 6071;
    703a:	72da 17b7 	lod	A, #6071
    703e:	7a01      	lod	Y, [S-2]
    7040:	52d6      	mov	[Y++], A
    7042:	5a01      	mov	[S-2], Y

00007044 <.LM39>:
      savedConfig.redy[index] = 2499;
    7044:	e00a      	add	Y, #10
    7046:	72da 09c3 	lod	A, #2499
    704a:	52f0      	mov	[Y], A
    704c:	7205      	lod	A, [S-6]
    704e:	44a2      	asl	A, #2
    7050:	a2da 1364 	add	A, #4964

00007054 <.LM40>:
      savedConfig.redY[index] = 19680;
    7054:	7ae2      	lod	Y, A
    7056:	e01a      	add	Y, #26
    7058:	4c85      	mov	[Y], D

0000705a <.LM41>:
      savedConfig.greenx[index] = 1652;
    705a:	7a01      	lod	Y, [S-2]
    705c:	e02e      	add	Y, #46
    705e:	7eda 0674 	lod	X, #1652
    7062:	5ef0      	mov	[Y], X

00007064 <.LM42>:
      savedConfig.greeny[index] = 6936;
    7064:	7a01      	lod	Y, [S-2]
    7066:	e03a      	add	Y, #58
    7068:	7eda 1b18 	lod	X, #6936
    706c:	5ef0      	mov	[Y], X

0000706e <.LM43>:
      savedConfig.greenY[index] = 29106;
    706e:	7ae2      	lod	Y, A
    7070:	e04a      	add	Y, #74
    7072:	7eda 71b2 	lod	X, #29106
    7076:	5ef0      	mov	[Y], X
    7078:	7c00      	lod	X, #0
    707a:	5ef2      	mov	[Y+2], X

0000707c <.LM44>:
      savedConfig.bluex[index] = 1545;
    707c:	7a01      	lod	Y, [S-2]
    707e:	e05e      	add	Y, #94
    7080:	7eda 0609 	lod	X, #1545
    7084:	5ef0      	mov	[Y], X

00007086 <.LM45>:
      savedConfig.bluey[index] = 246;
    7086:	7a01      	lod	Y, [S-2]
    7088:	e06a      	add	Y, #106
    708a:	7eda 00f6 	lod	X, #246
    708e:	5ef0      	mov	[Y], X

00007090 <.LM46>:
      savedConfig.blueY[index] = 1968;
    7090:	a07a      	add	A, #122
    7092:	7ee2      	lod	X, A
    7094:	7ada 07b0 	lod	Y, #1968
    7098:	5af8      	mov	[X], Y
    709a:	7800      	lod	Y, #0
    709c:	5afa      	mov	[X+2], Y
    709e:	7205      	lod	A, [S-6]
    70a0:	a2da 1364 	add	A, #4964

000070a4 <.LM47>:

      savedConfig.RCapCompensate[index] = 2;
    70a4:	7ee2      	lod	X, A
    70a6:	22da 0092 	add	X, #146
    70aa:	6402      	lod	YL, #2
    70ac:	46f8      	mov	[X], YL

000070ae <.LM48>:
      savedConfig.GCapCompensate[index] = 1;
    70ae:	2006      	add	X, #6
    70b0:	6401      	lod	YL, #1
    70b2:	46f8      	mov	[X], YL

000070b4 <.LM49>:
      savedConfig.BCapCompensate[index] = 4;
    70b4:	a2da 009e 	add	A, #158
    70b8:	6404      	lod	YL, #4
    70ba:	7ee2      	lod	X, A
    70bc:	46f8      	mov	[X], YL

000070be <.LM50>:

      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[1] = 1745;
    70be:	72da 06d1 	lod	A, #1745
    70c2:	7a03      	lod	Y, [S-4]
    70c4:	52f2      	mov	[Y+2], A

000070c6 <.LM51>:
      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[0] = 2758;
    70c6:	72da 0ac6 	lod	A, #2758
    70ca:	52f0      	mov	[Y], A

000070cc <.LM52>:
      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[2] = 2599;
    70cc:	72da 0a27 	lod	A, #2599
    70d0:	52f4      	mov	[Y+4], A

000070d2 <.LM53>:
    savedConfig.nad = 63;
    savedConfig.LedNumber = 1;
    savedConfig.SWVersion = CURRENTSWVERSION;//v196
    savedConfig.HWVersion = CURRENTHWVERSION;//H08

    for (index = 0; index < RGBLEDMAX; index++)
    70d2:	7205      	lod	A, [S-6]
    70d4:	a001      	add	A, #1
    70d6:	5205      	mov	[S-6], A

000070d8 <.LVL38>:
    70d8:	e006      	add	Y, #6
    70da:	5a03      	mov	[S-4], Y
    70dc:	7a07      	lod	Y, [S-8]
    70de:	e0ff      	add	Y, #-1
    70e0:	5a07      	mov	[S-8], Y
    70e2:	1901      	je	0x70e6 <.L21>
    70e4:	07aa      	jmp	0x703a <.L20>

000070e6 <.L21>:
  }
  else
  {}

  /* check EEPROM for valid dynamic content like node address */
  if((EE_DYN_VALID == VALIDEEPATTERN) && (EE_DYN_REV == REVISION) &&          \
    70e6:	72d8 0840 	lod	A, 0x840 <__ledsect_end>
    70ea:	aeda a55a 	cmp	A, #42330
    70ee:	1d23      	jne	0x7136 <.L25>

000070f0 <.LM55>:
    70f0:	72d8 0842 	lod	A, 0x842 <.LASF183+0x1>
    70f4:	ac01      	cmp	A, #1
    70f6:	1d1f      	jne	0x7136 <.L25>

000070f8 <.LM56>:
     (EE_DYN_CRC == calcEEChecksum(EE_DYNAMIC_AREA_START,EE_DYNAMIC_LENGTH_WO_CRC)))
    70f8:	72da 0840 	lod	A, #2112
    70fc:	16f6      	call	0x6eea <___calcEEChecksum_constprop_1>
    70fe:	7ad8 0846 	lod	Y, 0x846 <.LASF183+0x5>

00007102 <.LM57>:
  }
  else
  {}

  /* check EEPROM for valid dynamic content like node address */
  if((EE_DYN_VALID == VALIDEEPATTERN) && (EE_DYN_REV == REVISION) &&          \
    7102:	aee6      	cmp	A, Y
    7104:	1d18      	jne	0x7136 <.L25>

00007106 <.LM58>:
     (EE_DYN_CRC == calcEEChecksum(EE_DYNAMIC_AREA_START,EE_DYNAMIC_LENGTH_WO_CRC)))
  {
    lastAddr = EE_DYN_NAD;
    7106:	72d8 0844 	lod	A, 0x844 <.LASF183+0x3>

0000710a <.L32>:
  }
  else
  {
      /* no valid EEPROM data */
    /*force to re-write nad address*/
    lastAddr = savedConfig.nad + 1;
    710a:	42d8 122e 	mov	0x122e <_lastAddr>, AL

0000710e <.LM60>:
  }

  moduleFlashSave();
    710e:	1712      	call	0x6f34 <_moduleFlashSave>

00007110 <.LM61>:
}
    7110:	5409      	ret	#10

00007112 <.L19>:
    7112:	72d8 1430 	lod	A, 0x1430 <.LASF633+0x2>

00007116 <.LM62>:
      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[1] = 1745;
      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[0] = 2758;
      savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[2] = 2599;
    }
  }
  else if((savedConfig.SWVersion != CURRENTSWVERSION)||(savedConfig.HWVersion != CURRENTHWVERSION))
    7116:	7ad8 142e 	lod	Y, 0x142e <.LASF633>
    711a:	eeda 00c4 	cmp	Y, #196
    711e:	1d06      	jne	0x712c <.L22>

00007120 <.L31>:
  {
    if(savedConfig.SWVersion != CURRENTSWVERSION)
    {
	  savedConfig.SWVersion = CURRENTSWVERSION;
    }
    if(savedConfig.HWVersion != CURRENTHWVERSION)
    7120:	ac08      	cmp	A, #8
    7122:	1961      	je	0x70e6 <.L21>

00007124 <.LM64>:
    {
	  savedConfig.HWVersion = CURRENTHWVERSION;
    7124:	7008      	lod	A, #8
    7126:	52d8 1430 	mov	0x1430 <.LASF633+0x2>, A
    712a:	07dd      	jmp	0x70e6 <.L21>

0000712c <.L22>:
  }
  else if((savedConfig.SWVersion != CURRENTSWVERSION)||(savedConfig.HWVersion != CURRENTHWVERSION))
  {
    if(savedConfig.SWVersion != CURRENTSWVERSION)
    {
	  savedConfig.SWVersion = CURRENTSWVERSION;
    712c:	7ada 00c4 	lod	Y, #196
    7130:	5ad8 142e 	mov	0x142e <.LASF633>, Y
    7134:	07f5      	jmp	0x7120 <.L31>

00007136 <.L25>:
  }
  else
  {
      /* no valid EEPROM data */
    /*force to re-write nad address*/
    lastAddr = savedConfig.nad + 1;
    7136:	62d8 1364 	lod	AL, 0x1364 <_savedConfig>
    713a:	8001      	add	AL, #1
    713c:	07e6      	jmp	0x710a <.L32>

0000713e <_Set_Last_Address>:
  }
}

void Set_Last_Address(uint8_t slaveAddress)
{
	lastAddr = slaveAddress;
    713e:	42d8 122e 	mov	0x122e <_lastAddr>, AL

00007142 <.LM69>:
}
    7142:	5401      	ret

00007144 <_Auto_Addressing_Write_NAD_TO_EEPROM>:

void Auto_Addressing_Write_NAD_TO_EEPROM(uint8_t slaveAddress)
{
    7144:	5807      	inc	S, #8

00007146 <.LBB16>:

/* ----------------------------------------------------------------------------
 * write node address into EEPROM including VALIDPATTERN, ID and CRC -> 8 data bytes
 */
static INLINE void writeNADintoEEPROM(uint8_t slaveAddress){
    uint16_t eepromArray[4] = {VALIDEEPATTERN,REVISION,0,0};
    7146:	7aef      	lod	Y, S
    7148:	e0f8      	add	Y, #-8
    714a:	7eda 5a10 	lod	X, #23056
    714e:	0ea7      	lod	C, ML.7
    7150:	54ce      	movsw	[Y++], [X++]
    7152:	54ce      	movsw	[Y++], [X++]
    7154:	54ce      	movsw	[Y++], [X++]
    7156:	54ce      	movsw	[Y++], [X++]

00007158 <.LM72>:

    /* write node address into RAM buffer */
    eepromArray[2] = (uint16_t)(slaveAddress&0x003Fu);
    7158:	b43f      	and	A, #63

0000715a <.LVL47>:
    715a:	5203      	mov	[S-4], A

0000715c <.LM73>:
    /* calculate CRC from RAM buffer */
    eepromArray[3] = calcEEChecksum((uint16_t)&eepromArray[0],EE_DYNAMIC_LENGTH_WO_CRC);
    715c:	72ef      	lod	A, S
    715e:	a0f8      	add	A, #-8
    7160:	16c4      	call	0x6eea <___calcEEChecksum_constprop_1>
    7162:	5201      	mov	[S-2], A

00007164 <.LM74>:

    /* acknowledge absolute watchdog if needed */
    moduleWDTFeed();
    7164:	12bc      	call	0x76de <_moduleWDTFeed>

00007166 <.LM75>:

    /* write RAM buffer into EEPROM page */
    EEPROM_WriteWord64_blocking(EE_DYNAMIC_AREA_START, eepromArray, EE_WRITE_KEY);
    7166:	54ca 0007 	pushw	#7

0000716a <.LCFI13>:
    716a:	7aef      	lod	Y, S
    716c:	e0f6      	add	Y, #-10
    716e:	5adf      	push	Y

00007170 <.LCFI14>:
    7170:	72da 0840 	lod	A, #2112
    7174:	82db 116a 	callf	0x22d4 <_EEPROM_WriteWord64_blocking>

00007178 <.LM76>:

    /* acknowledge absolute watchdog if needed */
    moduleWDTFeed();
    7178:	12b2      	call	0x76de <_moduleWDTFeed>

0000717a <.LBE16>:

void Auto_Addressing_Write_NAD_TO_EEPROM(uint8_t slaveAddress)
{
	/* write node address into eeprom */
	writeNADintoEEPROM(slaveAddress);
}
    717a:	540d      	ret	#14

0000717c <_modulePwmInit>:
//static SLEDPwmSet currentPwm;

void modulePwmInit(void)
{
  /* configure diagnostic current source */
  IO_SET(PORT_LC_DISPU_DIAG,LCDIAG_SEL,MAXLCDIAGCURRENT); /* max current */
    717c:	72d8 023a 	lod	A, 0x23a <.LASF31+0xb>
    7180:	a6da 7000 	or	A, #28672
    7184:	52d8 023a 	mov	0x23a <.LASF31+0xb>, A

00007188 <.LM3>:

  /* configure current sources LC0-LC8 to 60mA */
  IO_SET(PORT_LC_SEL1,LC0_SEL,LCCURRENT40MA);
    7188:	62d8 0228 	lod	AL, 0x228 <.LASF35+0x6>
    718c:	94f0      	and	AL, #-16
    718e:	8407      	or	AL, #7
    7190:	42d8 0228 	mov	0x228 <.LASF35+0x6>, AL

00007194 <.LM4>:
  IO_SET(PORT_LC_SEL1,LC1_SEL,LCCURRENT40MA);
    7194:	62d8 0228 	lod	AL, 0x228 <.LASF35+0x6>
    7198:	940f      	and	AL, #15
    719a:	8470      	or	AL, #112
    719c:	42d8 0228 	mov	0x228 <.LASF35+0x6>, AL

000071a0 <.LM5>:
  IO_SET(PORT_LC_SEL1,LC2_SEL,LCCURRENT50MA);
    71a0:	72d8 0228 	lod	A, 0x228 <.LASF35+0x6>
    71a4:	b6da f0ff 	and	A, #61695
    71a8:	a6da 0d00 	or	A, #3328
    71ac:	52d8 0228 	mov	0x228 <.LASF35+0x6>, A

000071b0 <.LM6>:
  IO_SET(PORT_LC_SEL1,LC3_SEL,LCCURRENT40MA);
    71b0:	72d8 0228 	lod	A, 0x228 <.LASF35+0x6>
    71b4:	b6da 0fff 	and	A, #4095
    71b8:	a6da 7000 	or	A, #28672
    71bc:	52d8 0228 	mov	0x228 <.LASF35+0x6>, A

000071c0 <.LM7>:
  IO_SET(PORT_LC_SEL2,LC4_SEL,LCCURRENT40MA);
    71c0:	62d8 022a 	lod	AL, 0x22a <.LASF21+0x1>
    71c4:	94f0      	and	AL, #-16
    71c6:	8407      	or	AL, #7
    71c8:	42d8 022a 	mov	0x22a <.LASF21+0x1>, AL

000071cc <.LM8>:
  IO_SET(PORT_LC_SEL2,LC5_SEL,LCCURRENT50MA);
    71cc:	62d8 022a 	lod	AL, 0x22a <.LASF21+0x1>
    71d0:	940f      	and	AL, #15
    71d2:	84d0      	or	AL, #-48
    71d4:	42d8 022a 	mov	0x22a <.LASF21+0x1>, AL

000071d8 <.LM9>:
  IO_SET(PORT_LC_SEL2,LC6_SEL,LCCURRENT40MA);
    71d8:	72d8 022a 	lod	A, 0x22a <.LASF21+0x1>
    71dc:	b6da f0ff 	and	A, #61695
    71e0:	a6da 0700 	or	A, #1792
    71e4:	52d8 022a 	mov	0x22a <.LASF21+0x1>, A

000071e8 <.LM10>:
  IO_SET(PORT_LC_SEL2,LC7_SEL,LCCURRENT40MA);
    71e8:	72d8 022a 	lod	A, 0x22a <.LASF21+0x1>
    71ec:	b6da 0fff 	and	A, #4095
    71f0:	a6da 7000 	or	A, #28672
    71f4:	52d8 022a 	mov	0x22a <.LASF21+0x1>, A

000071f8 <.LM11>:
  IO_SET(PORT_LC_SEL3,LC8_SEL,LCCURRENT50MA);
    71f8:	62d8 022c 	lod	AL, 0x22c <.LASF21+0x3>
    71fc:	94f0      	and	AL, #-16
    71fe:	840d      	or	AL, #13
    7200:	42d8 022c 	mov	0x22c <.LASF21+0x3>, AL

00007204 <.LM12>:

  IO_SET(PORT_SELP_LC,SELP_LC,DISAPWM_HSWLC0_HSWLC1_HSWLC2); /* disable PWM on HSWLC0,HSWLC1 and HSWLC2 */
    7204:	72da 0e00 	lod	A, #3584
    7208:	52d8 023e 	mov	0x23e <.LASF31+0xf>, A

0000720c <.LM13>:

  IO_SET(PORT_LC_DISPU_DIAG,LC_DISPU,0x0FFF); /* disable pull-up resistors on LCx and HSWLCx */
    720c:	72d8 023a 	lod	A, 0x23a <.LASF31+0xb>
    7210:	a6da 0fff 	or	A, #4095
    7214:	52d8 023a 	mov	0x23a <.LASF31+0xb>, A

00007218 <.LBB974>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm1_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE1, PSCLM, ((DIV_)-1) & 0x0Fu,
    7218:	72d8 013a 	lod	A, 0x13a <.LASF104+0x3>
    721c:	b6da 0080 	and	A, #128
    7220:	a40c      	or	A, #12
    7222:	52d8 013a 	mov	0x13a <.LASF104+0x3>, A

00007226 <.LM15>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE1, CMP, CMP_);
    7226:	72da 7e40 	lod	A, #32320
    722a:	52d8 0132 	mov	0x132 <.LASF101+0x73>, A

0000722e <.LM16>:
    IO_SET(PWM_SLAVE1, LT, LT_);
    722e:	72da 7fff 	lod	A, #32767
    7232:	52d8 0136 	mov	0x136 <.LASF101+0x77>, A

00007236 <.LM17>:
    IO_SET(PWM_SLAVE1, HT, HT_);
    7236:	7000      	lod	A, #0
    7238:	52d8 0134 	mov	0x134 <.LASF101+0x75>, A

0000723c <.LBB976>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm2_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE2, PSCLM, ((DIV_)-1) & 0x0Fu,
    723c:	7ad8 0144 	lod	Y, 0x144 <.LASF104+0xd>
    7240:	f6da 0080 	and	Y, #128
    7244:	e40c      	or	Y, #12
    7246:	5ad8 0144 	mov	0x144 <.LASF104+0xd>, Y

0000724a <.LM19>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE2, CMP, CMP_);
    724a:	52d8 013c 	mov	0x13c <.LASF104+0x5>, A

0000724e <.LM20>:
    IO_SET(PWM_SLAVE2, LT, LT_);
    724e:	7ada 4000 	lod	Y, #16384
    7252:	5ad8 0140 	mov	0x140 <.LASF104+0x9>, Y

00007256 <.LM21>:
    IO_SET(PWM_SLAVE2, HT, HT_);
    7256:	52d8 013e 	mov	0x13e <.LASF104+0x7>, A

0000725a <.LBB978>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm3_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE3, PSCLM, ((DIV_)-1) & 0x0Fu,
    725a:	7ed8 014e 	lod	X, 0x14e <.LASF49+0x5>
    725e:	36da 0080 	and	X, #128
    7262:	240c      	or	X, #12
    7264:	5ed8 014e 	mov	0x14e <.LASF49+0x5>, X

00007268 <.LM23>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE3, CMP, CMP_);
    7268:	52d8 0146 	mov	0x146 <.LASF104+0xf>, A

0000726c <.LM24>:
    IO_SET(PWM_SLAVE3, LT, LT_);
    726c:	5ad8 014a 	mov	0x14a <.LASF49+0x1>, Y

00007270 <.LM25>:
    IO_SET(PWM_SLAVE3, HT, HT_);
    7270:	52d8 0148 	mov	0x148 <.LASF60>, A

00007274 <.LBB980>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm4_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE4, PSCLM, ((DIV_)-1) & 0x0Fu,
    7274:	7ed8 0158 	lod	X, 0x158 <.LASF97+0x2>
    7278:	36da 0080 	and	X, #128
    727c:	240c      	or	X, #12
    727e:	5ed8 0158 	mov	0x158 <.LASF97+0x2>, X

00007282 <.LM27>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE4, CMP, CMP_);
    7282:	52d8 0150 	mov	0x150 <.LASF49+0x7>, A

00007286 <.LM28>:
    IO_SET(PWM_SLAVE4, LT, LT_);
    7286:	5ad8 0154 	mov	0x154 <.LASF49+0xb>, Y

0000728a <.LM29>:
    IO_SET(PWM_SLAVE4, HT, HT_);
    728a:	52d8 0152 	mov	0x152 <.LASF49+0x9>, A

0000728e <.LBB982>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm5_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE5, PSCLM, ((DIV_)-1) & 0x0Fu,
    728e:	7ed8 0162 	lod	X, 0x162 <.LASF25+0x2>
    7292:	36da 0080 	and	X, #128
    7296:	240c      	or	X, #12
    7298:	5ed8 0162 	mov	0x162 <.LASF25+0x2>, X

0000729c <.LM31>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE5, CMP, CMP_);
    729c:	52d8 015a 	mov	0x15a <.LASF97+0x4>, A

000072a0 <.LM32>:
    IO_SET(PWM_SLAVE5, LT, LT_);
    72a0:	5ad8 015e 	mov	0x15e <.LASF97+0x8>, Y

000072a4 <.LM33>:
    IO_SET(PWM_SLAVE5, HT, HT_);
    72a4:	52d8 015c 	mov	0x15c <.LASF97+0x6>, A

000072a8 <.LBB984>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm6_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE6, PSCLM, ((DIV_)-1) & 0x0Fu,
    72a8:	7ed8 016c 	lod	X, 0x16c <.LASF70+0x5>
    72ac:	36da 0080 	and	X, #128
    72b0:	240c      	or	X, #12
    72b2:	5ed8 016c 	mov	0x16c <.LASF70+0x5>, X

000072b6 <.LM35>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE6, CMP, CMP_);
    72b6:	52d8 0164 	mov	0x164 <.LASF25+0x4>, A

000072ba <.LM36>:
    IO_SET(PWM_SLAVE6, LT, LT_);
    72ba:	5ad8 0168 	mov	0x168 <.LASF70+0x1>, Y

000072be <.LM37>:
    IO_SET(PWM_SLAVE6, HT, HT_);
    72be:	52d8 0166 	mov	0x166 <.LASF25+0x6>, A

000072c2 <.LBB986>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm7_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE7, PSCLM, ((DIV_)-1) & 0x0Fu,
    72c2:	7ed8 0176 	lod	X, 0x176 <.LASF30+0x9>
    72c6:	36da 0080 	and	X, #128
    72ca:	240c      	or	X, #12
    72cc:	5ed8 0176 	mov	0x176 <.LASF30+0x9>, X

000072d0 <.LM39>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE7, CMP, CMP_);
    72d0:	52d8 016e 	mov	0x16e <.LASF30+0x1>, A

000072d4 <.LM40>:
    IO_SET(PWM_SLAVE7, LT, LT_);
    72d4:	5ad8 0172 	mov	0x172 <.LASF30+0x5>, Y

000072d8 <.LM41>:
    IO_SET(PWM_SLAVE7, HT, HT_);
    72d8:	52d8 0170 	mov	0x170 <.LASF30+0x3>, A

000072dc <.LBB988>:
 * @param[in] InvertPolarityIDLE_ POL polarity invertion in the IDLE state. 1 inverts the POL
 */
STATIC INLINE void pwm8_init(uint8_t DIV_, uint8_t DIVN_, uint16_t LT_, uint16_t HT_,
                             uint16_t CMP_, pwmMode_t MODE_, pwmPolarity_t POL_, uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_SLAVE8, PSCLM, ((DIV_)-1) & 0x0Fu,
    72dc:	7ed8 0180 	lod	X, 0x180 <.LASF26+0x6>
    72e0:	36da 0080 	and	X, #128
    72e4:	240c      	or	X, #12
    72e6:	5ed8 0180 	mov	0x180 <.LASF26+0x6>, X

000072ea <.LM43>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 1u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_SLAVE8, CMP, CMP_);
    72ea:	52d8 0178 	mov	0x178 <.LASF30+0xb>, A

000072ee <.LM44>:
    IO_SET(PWM_SLAVE8, LT, LT_);
    72ee:	5ad8 017c 	mov	0x17c <.LASF26+0x2>, Y

000072f2 <.LM45>:
    IO_SET(PWM_SLAVE8, HT, HT_);
    72f2:	52d8 017a 	mov	0x17a <.LASF26>, A

000072f6 <.LBB990>:
                                    uint16_t CMP_,
                                    pwmMode_t MODE_,
                                    pwmPolarity_t POL_,
                                    uint8_t InvertPolarityIDLE_)
{
    IO_SET(PWM_MASTER1, PSCLM, ((DIV_)-1) & 0x0Fu,
    72f6:	7ed8 0130 	lod	X, 0x130 <.LASF101+0x71>
    72fa:	36da 0080 	and	X, #128
    72fe:	2408      	or	X, #8
    7300:	5ed8 0130 	mov	0x130 <.LASF101+0x71>, X

00007304 <.LM47>:
           POL, POL_,
           MODE, MODE_,
           SLAVE, 0u,
           START, 0u,
           STOP,  0u);
    IO_SET(PWM_MASTER1, PER, PERIOD_);
    7304:	7eda 7fff 	lod	X, #32767
    7308:	5ed8 012e 	mov	0x12e <.LASF101+0x6f>, X

0000730c <.LM48>:
    IO_SET(PWM_MASTER1, CMP, CMP_);
    730c:	7eda 7e00 	lod	X, #32256
    7310:	5ed8 0128 	mov	0x128 <.LASF101+0x69>, X

00007314 <.LM49>:
    IO_SET(PWM_MASTER1, LT, LT_);
    7314:	5ad8 012c 	mov	0x12c <.LASF101+0x6d>, Y

00007318 <.LM50>:
    IO_SET(PWM_MASTER1, HT, HT_);
    7318:	52d8 012a 	mov	0x12a <.LASF101+0x6b>, A

0000731c <.LBB992>:
#define PWM1_MASTER_ENABLE pwm1_master_enable

/** pwm1_master_enable starts the PWM channel */
STATIC INLINE void pwm1_master_enable(void)
{
    IO_HOST(PWM_MASTER1, START) = 1u<<IO_OFFSET(PWM_MASTER1, START);
    731c:	7001      	lod	A, #1
    731e:	52d8 0130 	mov	0x130 <.LASF101+0x71>, A

00007322 <.LBB994>:
#if defined (IO_PWM_SLAVE1__START_GET)
#define PWM1_ENABLE pwm1_enable

STATIC INLINE void pwm1_enable(void)
{
    IO_HOST(PWM_SLAVE1, START) = 1u<<IO_OFFSET(PWM_SLAVE1, START);
    7322:	52d8 013a 	mov	0x13a <.LASF104+0x3>, A

00007326 <.LBB996>:
#if defined (IO_PWM_SLAVE2__START_GET)
#define PWM2_ENABLE pwm2_enable

STATIC INLINE void pwm2_enable(void)
{
    IO_HOST(PWM_SLAVE2, START) = 1u<<IO_OFFSET(PWM_SLAVE2, START);
    7326:	52d8 0144 	mov	0x144 <.LASF104+0xd>, A

0000732a <.LBB998>:
#if defined (IO_PWM_SLAVE3__START_GET)
#define PWM3_ENABLE pwm3_enable

STATIC INLINE void pwm3_enable(void)
{
    IO_HOST(PWM_SLAVE3, START) = 1u<<IO_OFFSET(PWM_SLAVE3, START);
    732a:	52d8 014e 	mov	0x14e <.LASF49+0x5>, A

0000732e <.LBB1000>:
#if defined (IO_PWM_SLAVE4__START_GET)
#define PWM4_ENABLE pwm4_enable

STATIC INLINE void pwm4_enable(void)
{
    IO_HOST(PWM_SLAVE4, START) = 1u<<IO_OFFSET(PWM_SLAVE4, START);
    732e:	52d8 0158 	mov	0x158 <.LASF97+0x2>, A

00007332 <.LBB1002>:
#if defined (IO_PWM_SLAVE5__START_GET)
#define PWM5_ENABLE pwm5_enable

STATIC INLINE void pwm5_enable(void)
{
    IO_HOST(PWM_SLAVE5, START) = 1u<<IO_OFFSET(PWM_SLAVE5, START);
    7332:	52d8 0162 	mov	0x162 <.LASF25+0x2>, A

00007336 <.LBB1004>:
#if defined (IO_PWM_SLAVE6__START_GET)
#define PWM6_ENABLE pwm6_enable

STATIC INLINE void pwm6_enable(void)
{
    IO_HOST(PWM_SLAVE6, START) = 1u<<IO_OFFSET(PWM_SLAVE6, START);
    7336:	52d8 016c 	mov	0x16c <.LASF70+0x5>, A

0000733a <.LBB1006>:
#if defined (IO_PWM_SLAVE7__START_GET)
#define PWM7_ENABLE pwm7_enable

STATIC INLINE void pwm7_enable(void)
{
    IO_HOST(PWM_SLAVE7, START) = 1u<<IO_OFFSET(PWM_SLAVE7, START);
    733a:	52d8 0176 	mov	0x176 <.LASF30+0x9>, A

0000733e <.LBB1008>:
#if defined (IO_PWM_SLAVE8__START_GET)
#define PWM8_ENABLE pwm8_enable

STATIC INLINE void pwm8_enable(void)
{
    IO_HOST(PWM_SLAVE8, START) = 1u<<IO_OFFSET(PWM_SLAVE8, START);
    733e:	52d8 0180 	mov	0x180 <.LASF26+0x6>, A

00007342 <.LBE1008>:
  PWM6_ENABLE();
  PWM7_ENABLE();
  PWM8_ENABLE();

  /* configure PWM Interrupts*/
  Itc_Clear(PWM_MASTER1_CMP);
    7342:	42d8 0052 	mov	0x52 <.Ldebug_line0+0x11>, AL

00007346 <.LM61>:
  Itc_SetPrio(PWM_MASTER1_CMP, 3u);
    7346:	62d8 0089 	lod	AL, 0x89 <.LASF0+0x7>
    734a:	943f      	and	AL, #63
    734c:	42d8 0089 	mov	0x89 <.LASF0+0x7>, AL

00007350 <.LM62>:
  Itc_Enable(PWM_MASTER1_CMP);
    7350:	62d8 006e 	lod	AL, 0x6e <__data_size+0x10>
    7354:	8401      	or	AL, #1
    7356:	42d8 006e 	mov	0x6e <__data_size+0x10>, AL

0000735a <.LM63>:
}
    735a:	5401      	ret

0000735c <_modulePwmLedSpecialMask>:

static volatile uint8_t ledMask = 0;
void modulePwmLedSpecialMask(uint8_t mask)
{
  ledMask = mask;
    735c:	42d8 122f 	mov	0x122f <_ledMask>, AL

00007360 <.LM66>:
}
    7360:	5401      	ret

00007362 <_modulePwmSet>:
    16, 15, 17,/*5*/
};

SLEDPwmSet pwmParam;
void modulePwmSet(SPWMParams *ouputPwm)
{
    7362:	5813      	inc	S, #20

00007364 <.LCFI0>:
  uint16_t cntLeds = 0;
  uint16_t index = 0;
  uint16_t temp = 0;
//  SLEDPwmSet pwmParam;

  if ((ledMask & 0xFC) == 0x0)
    7364:	66d8 122f 	lod	YL, 0x122f <_ledMask>
    7368:	f6da 00fc 	and	Y, #252
    736c:	1901      	je	0x7370 <.LCFI0+0xc>
    736e:	00c4      	jmp	0x74f8 <.L4>
    7370:	520b      	mov	[S-12], A
    7372:	7ada 5b3e 	lod	Y, #23358
    7376:	5a03      	mov	[S-4], Y
    7378:	7eda 1364 	lod	X, #4964
    737c:	5e09      	mov	[S-10], X
    737e:	7c06      	lod	X, #6
    7380:	5e0d      	mov	[S-14], X

00007382 <.L11>:
  {
    for (index = 0; index < RGBLEDMAX; index++)
    {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = (ouputPwm->PWM_R[index] == 0)?0:(ouputPwm->PWM_R[index]+savedConfig.RCapCompensate[index]);
    7382:	7a0b      	lod	Y, [S-12]
    7384:	72d6      	lod	A, [Y++]
    7386:	5a0b      	mov	[S-12], Y
    7388:	5211      	mov	[S-18], A
    738a:	1908      	je	0x739c <.L5>

0000738c <.LM70>:
    738c:	7209      	lod	A, [S-10]
    738e:	a2da 0092 	add	A, #146
    7392:	7ee2      	lod	X, A
    7394:	62f8      	lod	AL, [X]
    7396:	5cf2      	usex	A
    7398:	a211      	add	A, [S-18]
    739a:	5211      	mov	[S-18], A

0000739c <.L5>:

  if ((ledMask & 0xFC) == 0x0)
  {
    for (index = 0; index < RGBLEDMAX; index++)
    {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
    739c:	7a03      	lod	Y, [S-4]
    739e:	72f0      	lod	A, [Y]
    73a0:	520f      	mov	[S-16], A

000073a2 <.LM72>:
                        = (ouputPwm->PWM_R[index] == 0)?0:(ouputPwm->PWM_R[index]+savedConfig.RCapCompensate[index]);
    73a2:	4422      	asl	A
    73a4:	a2da 1434 	add	A, #5172
    73a8:	7e11      	lod	X, [S-18]
    73aa:	7ae2      	lod	Y, A
    73ac:	5ef0      	mov	[Y], X

000073ae <.LM73>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = (ouputPwm->PWM_G[index] == 0)?0:(ouputPwm->PWM_G[index]+savedConfig.GCapCompensate[index]);
    73ae:	7e0b      	lod	X, [S-12]
    73b0:	200a      	add	X, #10
    73b2:	7ef8      	lod	X, [X]
    73b4:	5e13      	mov	[S-20], X
    73b6:	1908      	je	0x73c8 <.L6>

000073b8 <.LM74>:
    73b8:	7209      	lod	A, [S-10]
    73ba:	a2da 0098 	add	A, #152
    73be:	7ee2      	lod	X, A
    73c0:	62f8      	lod	AL, [X]
    73c2:	5cf2      	usex	A
    73c4:	a213      	add	A, [S-20]
    73c6:	5213      	mov	[S-20], A

000073c8 <.L6>:
  {
    for (index = 0; index < RGBLEDMAX; index++)
    {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = (ouputPwm->PWM_R[index] == 0)?0:(ouputPwm->PWM_R[index]+savedConfig.RCapCompensate[index]);
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
    73c8:	7a03      	lod	Y, [S-4]
    73ca:	72f2      	lod	A, [Y+2]
    73cc:	5211      	mov	[S-18], A

000073ce <.LM76>:
                        = (ouputPwm->PWM_G[index] == 0)?0:(ouputPwm->PWM_G[index]+savedConfig.GCapCompensate[index]);
    73ce:	4422      	asl	A
    73d0:	a2da 1434 	add	A, #5172
    73d4:	7e13      	lod	X, [S-20]
    73d6:	7ae2      	lod	Y, A
    73d8:	5ef0      	mov	[Y], X

000073da <.LM77>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = (ouputPwm->PWM_B[index] == 0)?0:(ouputPwm->PWM_B[index]+savedConfig.BCapCompensate[index]);
    73da:	7e0b      	lod	X, [S-12]
    73dc:	2016      	add	X, #22
    73de:	7ef8      	lod	X, [X]
    73e0:	5e05      	mov	[S-6], X
    73e2:	1908      	je	0x73f4 <.L7>

000073e4 <.LM78>:
    73e4:	7209      	lod	A, [S-10]
    73e6:	a2da 009e 	add	A, #158
    73ea:	7ee2      	lod	X, A
    73ec:	62f8      	lod	AL, [X]
    73ee:	5cf2      	usex	A
    73f0:	a205      	add	A, [S-6]
    73f2:	5205      	mov	[S-6], A

000073f4 <.L7>:
    {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = (ouputPwm->PWM_R[index] == 0)?0:(ouputPwm->PWM_R[index]+savedConfig.RCapCompensate[index]);
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = (ouputPwm->PWM_G[index] == 0)?0:(ouputPwm->PWM_G[index]+savedConfig.GCapCompensate[index]);
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
    73f4:	7a03      	lod	Y, [S-4]
    73f6:	72f4      	lod	A, [Y+4]
    73f8:	5213      	mov	[S-20], A

000073fa <.LM80>:
                        = (ouputPwm->PWM_B[index] == 0)?0:(ouputPwm->PWM_B[index]+savedConfig.BCapCompensate[index]);
    73fa:	4422      	asl	A
    73fc:	a2da 1434 	add	A, #5172
    7400:	7e05      	lod	X, [S-6]
    7402:	7ae2      	lod	Y, A
    7404:	5ef0      	mov	[Y], X

00007406 <.LM81>:

        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]];
    7406:	720f      	lod	A, [S-16]
    7408:	4422      	asl	A
    740a:	7ee2      	lod	X, A
    740c:	22da 1434 	add	X, #5172
    7410:	7ef8      	lod	X, [X]
    7412:	5e0f      	mov	[S-16], X
    7414:	2c00      	cmp	X, #0
    7416:	1e83      	jsge	0x741e <.L8>
    7418:	7eda 7fff 	lod	X, #32767
    741c:	5e0f      	mov	[S-16], X

0000741e <.L8>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = (ouputPwm->PWM_G[index] == 0)?0:(ouputPwm->PWM_G[index]+savedConfig.GCapCompensate[index]);
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = (ouputPwm->PWM_B[index] == 0)?0:(ouputPwm->PWM_B[index]+savedConfig.BCapCompensate[index]);

        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]] =
    741e:	a2da 1434 	add	A, #5172
    7422:	7a0f      	lod	Y, [S-16]
    7424:	7ee2      	lod	X, A
    7426:	5af8      	mov	[X], Y

00007428 <.LM83>:
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]];
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]];
    7428:	7211      	lod	A, [S-18]
    742a:	4422      	asl	A
    742c:	7ee2      	lod	X, A
    742e:	22da 1434 	add	X, #5172
    7432:	7ef8      	lod	X, [X]
    7434:	5e0f      	mov	[S-16], X
    7436:	2c00      	cmp	X, #0
    7438:	1e83      	jsge	0x7440 <.L9>
    743a:	7ada 7fff 	lod	Y, #32767
    743e:	5a0f      	mov	[S-16], Y

00007440 <.L9>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = (ouputPwm->PWM_B[index] == 0)?0:(ouputPwm->PWM_B[index]+savedConfig.BCapCompensate[index]);

        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]];
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]] =
    7440:	a2da 1434 	add	A, #5172
    7444:	7e0f      	lod	X, [S-16]
    7446:	7ae2      	lod	Y, A
    7448:	5ef0      	mov	[Y], X

0000744a <.LM85>:
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]];
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]];
    744a:	7213      	lod	A, [S-20]
    744c:	4422      	asl	A
    744e:	7ee2      	lod	X, A
    7450:	22da 1434 	add	X, #5172
    7454:	7ef8      	lod	X, [X]
    7456:	5e0f      	mov	[S-16], X
    7458:	2c00      	cmp	X, #0
    745a:	1e83      	jsge	0x7462 <.L10>
    745c:	7eda 7fff 	lod	X, #32767
    7460:	5e0f      	mov	[S-16], X

00007462 <.L10>:

        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]];
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]] =
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]];
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]] =
    7462:	a2da 1434 	add	A, #5172
    7466:	7a0f      	lod	Y, [S-16]
    7468:	7ee2      	lod	X, A
    746a:	5af8      	mov	[X], Y
    746c:	7a03      	lod	Y, [S-4]
    746e:	e006      	add	Y, #6
    7470:	5a03      	mov	[S-4], Y
    7472:	7e09      	lod	X, [S-10]
    7474:	2001      	add	X, #1
    7476:	5e09      	mov	[S-10], X

00007478 <.LM87>:
  uint16_t temp = 0;
//  SLEDPwmSet pwmParam;

  if ((ledMask & 0xFC) == 0x0)
  {
    for (index = 0; index < RGBLEDMAX; index++)
    7478:	720d      	lod	A, [S-14]
    747a:	a0ff      	add	A, #-1
    747c:	520d      	mov	[S-14], A
    747e:	1901      	je	0x7482 <.L12>
    7480:	0780      	jmp	0x7382 <.L11>

00007482 <.L12>:
  }

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    /* scale and set PWM duty-cycle for single RGB-LED */
    for(index = 0; index < RGBLEDCHANNELS; index++)
    7482:	7000      	lod	A, #0
    7484:	5209      	mov	[S-10], A

00007486 <.L22>:
    7486:	7209      	lod	A, [S-10]
    7488:	4872 0003 	muls	A, A, #3
    748c:	520f      	mov	[S-16], A
    748e:	7209      	lod	A, [S-10]
    7490:	4872 0006 	muls	A, A, #6
    7494:	7ae2      	lod	Y, A
    7496:	e2da 1434 	add	Y, #5172
    749a:	5a0d      	mov	[S-14], Y
    749c:	7800      	lod	Y, #0

0000749e <.L21>:
    {
      temp = pwmParam.LedRGB[cntLeds*RGBLEDCHANNELS + index];
    749e:	7e0d      	lod	X, [S-14]
    74a0:	72de      	lod	A, [X++]
    74a2:	5e0d      	mov	[S-14], X
    74a4:	520b      	mov	[S-12], A

000074a6 <.LM90>:
//			  temp = (temp == 0)?0:(temp + 6);//Blue
//		  }
//	  }
      /* scale to PWMMAXPER period and round */

      pwmDuty[(validPmwDuty^1)][(cntLeds*RGBLEDCHANNELS + index)] = temp;
    74a6:	72d8 1232 	lod	A, 0x1232 <_validPmwDuty>

000074aa <.LVL20>:
    74aa:	bc01      	xor	A, #1
    74ac:	4872 0012 	muls	A, A, #18
    74b0:	7e0f      	lod	X, [S-16]

000074b2 <.LVL21>:
    74b2:	22e6      	add	X, Y
    74b4:	a2ee      	add	A, X
    74b6:	4422      	asl	A
    74b8:	7ee2      	lod	X, A
    74ba:	22da 1234 	add	X, #4660
    74be:	720b      	lod	A, [S-12]
    74c0:	52f8      	mov	[X], A

000074c2 <.LM91>:

      /* check if LED forward voltage can be measured */
      if (temp >= T_MINON) {
    74c2:	1d01      	jne	0x74c6 <.LM92>
    74c4:	0086      	jmp	0x75d2 <.L19>

000074c6 <.LM92>:
          /* signalize that channel can be measured */
          moduleAdcLedEnable(cntLeds, index, 1);
    74c6:	54ca 0001 	pushw	#1

000074ca <.L42>:
      }
      else {
          /* signalize that channel cannot be measured */
          moduleAdcLedEnable(cntLeds, index, 0);
    74ca:	5adf      	push	Y

000074cc <.LCFI2>:
    74cc:	720d      	lod	A, [S-14]

000074ce <.LVL23>:
    74ce:	5a0b      	mov	[S-12], Y
    74d0:	82db 34fc 	callf	0x69f8 <_moduleAdcLedEnable>

000074d4 <.LVL24>:
    74d4:	5c03      	dec	S, #4

000074d6 <.LCFI3>:
    74d6:	7a07      	lod	Y, [S-8]

000074d8 <.LM94>:
  }

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
  {
    /* scale and set PWM duty-cycle for single RGB-LED */
    for(index = 0; index < RGBLEDCHANNELS; index++)
    74d8:	e001      	add	Y, #1

000074da <.LVL25>:
    74da:	ec03      	cmp	Y, #3
    74dc:	1d60      	jne	0x749e <.L21>

000074de <.LM95>:
                        = 0;
      }
    }
  }

  for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    74de:	7209      	lod	A, [S-10]
    74e0:	a001      	add	A, #1
    74e2:	5209      	mov	[S-10], A

000074e4 <.LVL26>:
    74e4:	ac06      	cmp	A, #6
    74e6:	1d4f      	jne	0x7486 <.L22>

000074e8 <.LM96>:
//	  pwmDuty[(validPmwDuty^1)][(cntLeds*RGBLEDCHANNELS + 2)] = temp;
//	  moduleAdcLedEnable(cntLeds, 2, 1);
  }

  /* signalize new PWM duty-cycle values are available */
  validPmwDuty ^= 1;
    74e8:	72d8 1232 	lod	A, 0x1232 <_validPmwDuty>

000074ec <.LVL27>:
    74ec:	bc01      	xor	A, #1
    74ee:	52d8 1232 	mov	0x1232 <_validPmwDuty>, A

000074f2 <.LM97>:
  moduleAdcUpdate();
    74f2:	82db 3519 	callf	0x6a32 <_moduleAdcUpdate>

000074f6 <.LM98>:
}
    74f6:	5415      	ret	#22

000074f8 <.L4>:
    74f8:	7ada 5b3e 	lod	Y, #23358
    74fc:	5a13      	mov	[S-20], Y

000074fe <.LM99>:
  uint16_t cntLeds = 0;
  uint16_t index = 0;
  uint16_t temp = 0;
//  SLEDPwmSet pwmParam;

  if ((ledMask & 0xFC) == 0x0)
    74fe:	7c02      	lod	X, #2
    7500:	5e09      	mov	[S-10], X
    7502:	7c06      	lod	X, #6
    7504:	5e0b      	mov	[S-12], X

00007506 <.L18>:
  }
  else
  {
    for (index = 0; index < RGBLEDMAX; index++)
    {
      if (ledMask&(0x1<<(index+2)))
    7506:	66d8 122f 	lod	YL, 0x122f <_ledMask>
    750a:	5cf6      	usex	Y
    750c:	7e13      	lod	X, [S-20]
    750e:	72f8      	lod	A, [X]
    7510:	5201      	mov	[S-2], A
    7512:	72fa      	lod	A, [X+2]
    7514:	520f      	mov	[S-16], A
    7516:	72fc      	lod	A, [X+4]
    7518:	520d      	mov	[S-14], A
    751a:	7e09      	lod	X, [S-10]
    751c:	2c00      	cmp	X, #0
    751e:	1b02      	jsle	0x7524 <.L43>

00007520 <.L44>:
    7520:	4476      	asr	Y
    7522:	1bfe      	djnz	X, 0x7520 <.L44>

00007524 <.L43>:
    7524:	f401      	and	Y, #1
    7526:	5a11      	mov	[S-18], Y
    7528:	7201      	lod	A, [S-2]
    752a:	4422      	asl	A
    752c:	ec00      	cmp	Y, #0
    752e:	1d01      	jne	0x7532 <.LM101>
    7530:	003e      	jmp	0x75ae <.L13>

00007532 <.LM101>:
      {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = ((ledMask&0x3)==0x00)?32000:0;
    7532:	66d8 122f 	lod	YL, 0x122f <_ledMask>
    7536:	f403      	and	Y, #3
    7538:	1d32      	jne	0x759e <.L24>
    753a:	7ada 7d00 	lod	Y, #32000

0000753e <.L41>:
    753e:	5a11      	mov	[S-18], Y
    7540:	a2da 1434 	add	A, #5172
    7544:	7a11      	lod	Y, [S-18]
    7546:	7ee2      	lod	X, A
    7548:	5af8      	mov	[X], Y

0000754a <.LM102>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = ((ledMask&0x3)==0x01)?32000:0;
    754a:	62d8 122f 	lod	AL, 0x122f <_ledMask>
    754e:	9403      	and	AL, #3
    7550:	8c01      	cmp	AL, #1
    7552:	1d27      	jne	0x75a2 <.L25>
    7554:	72da 7d00 	lod	A, #32000
    7558:	5211      	mov	[S-18], A

0000755a <.L15>:
    755a:	720f      	lod	A, [S-16]
    755c:	4422      	asl	A
    755e:	7ae2      	lod	Y, A
    7560:	e2da 1434 	add	Y, #5172
    7564:	7211      	lod	A, [S-18]
    7566:	52f0      	mov	[Y], A

00007568 <.LM103>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = ((ledMask&0x3)==0x02)?32000:0;
    7568:	62d8 122f 	lod	AL, 0x122f <_ledMask>
    756c:	9403      	and	AL, #3
    756e:	8c02      	cmp	AL, #2
    7570:	1d1b      	jne	0x75a8 <.L26>
    7572:	7ada 7d00 	lod	Y, #32000
    7576:	5a0f      	mov	[S-16], Y

00007578 <.L16>:
    7578:	720d      	lod	A, [S-14]
    757a:	4422      	asl	A
    757c:	7ae2      	lod	Y, A
    757e:	e2da 1434 	add	Y, #5172
    7582:	720f      	lod	A, [S-16]
    7584:	52f0      	mov	[Y], A

00007586 <.L17>:
    7586:	7209      	lod	A, [S-10]
    7588:	a001      	add	A, #1
    758a:	5209      	mov	[S-10], A
    758c:	7a13      	lod	Y, [S-20]
    758e:	e006      	add	Y, #6
    7590:	5a13      	mov	[S-20], Y

00007592 <.LM105>:
        		pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]>32767?32767:pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]];
    }
  }
  else
  {
    for (index = 0; index < RGBLEDMAX; index++)
    7592:	7e0b      	lod	X, [S-12]
    7594:	20ff      	add	X, #-1
    7596:	5e0b      	mov	[S-12], X
    7598:	1901      	je	0x759c <.LM105+0xa>
    759a:	07b5      	jmp	0x7506 <.L18>
    759c:	0772      	jmp	0x7482 <.L12>

0000759e <.L24>:
    {
      if (ledMask&(0x1<<(index+2)))
      {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = ((ledMask&0x3)==0x00)?32000:0;
    759e:	7800      	lod	Y, #0
    75a0:	07ce      	jmp	0x753e <.L41>

000075a2 <.L25>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = ((ledMask&0x3)==0x01)?32000:0;
    75a2:	7800      	lod	Y, #0
    75a4:	5a11      	mov	[S-18], Y
    75a6:	07d9      	jmp	0x755a <.L15>

000075a8 <.L26>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = ((ledMask&0x3)==0x02)?32000:0;
    75a8:	7000      	lod	A, #0
    75aa:	520f      	mov	[S-16], A
    75ac:	07e5      	jmp	0x7578 <.L16>

000075ae <.L13>:
      }
      else
      {
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]
                        = 0;
    75ae:	a2da 1434 	add	A, #5172
    75b2:	7a11      	lod	Y, [S-18]
    75b4:	7ee2      	lod	X, A
    75b6:	5af8      	mov	[X], Y

000075b8 <.LM110>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]
                        = 0;
    75b8:	720f      	lod	A, [S-16]
    75ba:	4422      	asl	A
    75bc:	a2da 1434 	add	A, #5172
    75c0:	7ee2      	lod	X, A
    75c2:	5af8      	mov	[X], Y

000075c4 <.LM111>:
        pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]
                        = 0;
    75c4:	720d      	lod	A, [S-14]
    75c6:	4422      	asl	A
    75c8:	a2da 1434 	add	A, #5172
    75cc:	7ee2      	lod	X, A
    75ce:	5af8      	mov	[X], Y
    75d0:	07da      	jmp	0x7586 <.L17>

000075d2 <.L19>:
          /* signalize that channel can be measured */
          moduleAdcLedEnable(cntLeds, index, 1);
      }
      else {
          /* signalize that channel cannot be measured */
          moduleAdcLedEnable(cntLeds, index, 0);
    75d2:	7e0b      	lod	X, [S-12]
    75d4:	5edf      	push	X

000075d6 <.LCFI4>:
    75d6:	0779      	jmp	0x74ca <.L42>

000075d8 <__PWM_MASTER1_CMP_INT>:
//    0x0015,/*HS0_HS2_LC1*/
//    0x002A,/*HS1_LC0_LC2*/
//};

/* PWM1 Master compare interrupt */
__attribute__((interrupt)) void  _PWM_MASTER1_CMP_INT(void){
    75d8:	5edf      	push	X

000075da <.LCFI5>:
    75da:	5adf      	push	Y

000075dc <.LCFI6>:
    75dc:	52df      	push	A

000075de <.LCFI7>:
    75de:	5805      	inc	S, #6

000075e0 <.LCFI8>:
    uint16_t* ptrIO = (uint16_t*)PORTADDRESSPWM1MASTERHT;
    /* loop variable */
    uint16_t temp = 0;

    /* check current PWM state -> currently driven RGB-LEDs */
    if(pwmstat == 0) {
    75e0:	72d8 1230 	lod	A, 0x1230 <_pwmstat>
    75e4:	1d2a      	jne	0x763a <.L46>

000075e6 <.LM115>:
        /* set new high side switches */
//        IO_SET(PORT_HSW_OUT,HSW_OUT,SWITCHON_HSWLC1_HSW0_2); /* HS1_LC0_LC2 */
        IO_SET(PORT_HSW_OUT,HSW_OUT,0x0015); /* HS1_LC0_LC2 */
    75e6:	6415      	lod	YL, #21
    75e8:	46d8 0240 	mov	0x240 <.LASF20+0x1>, YL

000075ec <.LM116>:

        /* set new PWM duty-cycles for next 3 RGB-LEDs */
        for(temp = 0; temp < PWM_CHANNELS; temp++) {
    75ec:	5203      	mov	[S-4], A
    75ee:	7c09      	lod	X, #9

000075f0 <.L47>:
//            ptrIO[(temp*PORTADDRESSPWMHTGAP)] = 0;
            ptrIO[((temp*PORTADDRESSPWMHTGAP)+1)] = (0x7FFF - pwmDuty[validPmwDuty][temp])/2;
    75f0:	72d8 1232 	lod	A, 0x1232 <_validPmwDuty>
    75f4:	4872 0012 	muls	A, A, #18
    75f8:	a203      	add	A, [S-4]
    75fa:	4422      	asl	A
    75fc:	7ae2      	lod	Y, A
    75fe:	e2da 1234 	add	Y, #4660
    7602:	7af0      	lod	Y, [Y]
    7604:	5a01      	mov	[S-2], Y
    7606:	7203      	lod	A, [S-4]
    7608:	4872 000a 	muls	A, A, #10
    760c:	7ae2      	lod	Y, A
    760e:	e2da 012c 	add	Y, #300
    7612:	72da 7fff 	lod	A, #32767
    7616:	aa01      	sub	A, [S-2]
    7618:	4432      	lsr	A
    761a:	52f0      	mov	[Y], A

0000761c <.LM118>:
        /* set new high side switches */
//        IO_SET(PORT_HSW_OUT,HSW_OUT,SWITCHON_HSWLC1_HSW0_2); /* HS1_LC0_LC2 */
        IO_SET(PORT_HSW_OUT,HSW_OUT,0x0015); /* HS1_LC0_LC2 */

        /* set new PWM duty-cycles for next 3 RGB-LEDs */
        for(temp = 0; temp < PWM_CHANNELS; temp++) {
    761c:	7203      	lod	A, [S-4]
    761e:	a001      	add	A, #1
    7620:	5203      	mov	[S-4], A

00007622 <.LVL40>:
    7622:	1be6      	djnz	X, 0x75f0 <.L47>

00007624 <.L48>:
            ptrIO[((temp*PORTADDRESSPWMHTGAP)+1)] = (0x7FFF - pwmDuty[validPmwDuty][temp+PWM_CHANNELS])/2;
        }
    }

    /* signalize that driven RGB-LEDs has changed */
    pwmstat ^= 1;
    7624:	72d8 1230 	lod	A, 0x1230 <_pwmstat>
    7628:	bc01      	xor	A, #1
    762a:	52d8 1230 	mov	0x1230 <_pwmstat>, A

0000762e <.LM120>:
}
    762e:	5c05      	dec	S, #6
    7630:	72cf      	pop	A

00007632 <.LCFI9>:
    7632:	7acf      	pop	Y

00007634 <.LCFI10>:
    7634:	7ecf      	pop	X

00007636 <.LCFI11>:
    7636:	72cb      	pop	M
    7638:	5401      	ret

0000763a <.L46>:
        }
    }
    else {
        /* set new high side switches */
//        IO_SET(PORT_HSW_OUT,HSW_OUT,SWITCHON_HSWLC0_2_HSW1); /* HS0_HS2_LC1 */
        IO_SET(PORT_HSW_OUT,HSW_OUT,0x002A); /* HS0_HS2_LC1 */
    763a:	602a      	lod	AL, #42
    763c:	42d8 0240 	mov	0x240 <.LASF20+0x1>, AL
    7640:	7009      	lod	A, #9
    7642:	5201      	mov	[S-2], A
    7644:	7ee2      	lod	X, A

00007646 <.L49>:
//
//        /* set new PWM duty-cycles for next 3 RGB-LEDs */
        for(temp = 0; temp < PWM_CHANNELS; temp++) {
//            ptrIO[(temp*PORTADDRESSPWMHTGAP)] = 0;
            ptrIO[((temp*PORTADDRESSPWMHTGAP)+1)] = (0x7FFF - pwmDuty[validPmwDuty][temp+PWM_CHANNELS])/2;
    7646:	72d8 1232 	lod	A, 0x1232 <_validPmwDuty>
    764a:	4872 0012 	muls	A, A, #18
    764e:	a201      	add	A, [S-2]
    7650:	4422      	asl	A
    7652:	a2da 1234 	add	A, #4660
    7656:	7ae2      	lod	Y, A
    7658:	72f0      	lod	A, [Y]
    765a:	5203      	mov	[S-4], A
    765c:	7201      	lod	A, [S-2]
    765e:	4872 000a 	muls	A, A, #10
    7662:	7ae2      	lod	Y, A
    7664:	e2da 00d2 	add	Y, #210
    7668:	72da 7fff 	lod	A, #32767
    766c:	aa03      	sub	A, [S-4]
    766e:	4432      	lsr	A
    7670:	52f0      	mov	[Y], A
    7672:	7201      	lod	A, [S-2]
    7674:	a001      	add	A, #1
    7676:	5201      	mov	[S-2], A

00007678 <.LM123>:
        /* set new high side switches */
//        IO_SET(PORT_HSW_OUT,HSW_OUT,SWITCHON_HSWLC0_2_HSW1); /* HS0_HS2_LC1 */
        IO_SET(PORT_HSW_OUT,HSW_OUT,0x002A); /* HS0_HS2_LC1 */
//
//        /* set new PWM duty-cycles for next 3 RGB-LEDs */
        for(temp = 0; temp < PWM_CHANNELS; temp++) {
    7678:	1be6      	djnz	X, 0x7646 <.L49>
    767a:	07d4      	jmp	0x7624 <.L48>

0000767c <_modulePowerEnterSleep>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    767c:	08b2      	clrb	MH.2
    767e:	08b1      	clrb	MH.1
    7680:	08b0      	clrb	MH.0

00007682 <.LBE82>:
#include <flash_defines.h>

void modulePowerEnterSleep(void)
{
  builtin_mlx16_disable_interrupts();       /* Disable the interrupts */
  if (IO_GET(ADC_SAR, STOP)!=1) { /* If ADC is not stopped, we need to stop it first */
    7682:	72d8 01a0 	lod	A, 0x1a0 <.LASF48>
    7686:	9402      	and	AL, #2
    7688:	1d0d      	jne	0x76a4 <.L2>

0000768a <.LM4>:
      IO_SET(ADC_SAR, STOP, 1);
    768a:	62d8 01a0 	lod	AL, 0x1a0 <.LASF48>
    768e:	94fc      	and	AL, #-4
    7690:	8402      	or	AL, #2
    7692:	42d8 01a0 	mov	0x1a0 <.LASF48>, AL

00007696 <.LM5>:
      DELAY(2);  /* Make sure we will have the ADC HW reaction */
    7696:	7c02      	lod	X, #2

00007698 <L0>:
    7698:	1bff      	djnz	X, 0x7698 <L0>

0000769a <.L3>:
      while (IO_GET(ADC_SAR, ABORTED )==0u) {
    769a:	72d8 01a4 	lod	A, 0x1a4 <.LASF48+0x4>
    769e:	b6da 1000 	and	A, #4096
    76a2:	197b      	je	0x769a <.L3>

000076a4 <.L2>:
          /* Wait for the ADC will be aborted after the STOP command */
      }
  }
  IO_SET (PORT_MELIBUS_CTRL, MELIBUS_EN, 0u);
    76a4:	62d8 0224 	lod	AL, 0x224 <.LASF35+0x2>
    76a8:	94fe      	and	AL, #-2
    76aa:	42d8 0224 	mov	0x224 <.LASF35+0x2>, AL

000076ae <.LBB84>:
		"adc %[acc], #0" : [acc]"=r"(result) : "0"(result));
	return result;
}
static __attribute__((always_inline)) inline uint16_t IO_AWD__WIN_OPEN_GET (void) {
	register uint16_t result = 0u;
	asm volatile (
    76ae:	7000      	lod	A, #0
    76b0:	0f7f      	lod	C, io:0x0f.7
    76b2:	b000      	adc	A, #0

000076b4 <.LBE86>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (0 != IO_GET(AWD, WIN_OPEN)) {
    76b4:	ac00      	cmp	A, #0
    76b6:	1901      	je	0x76ba <.L5>

000076b8 <.LM10>:
        IO_SET(AWD, ACK, 1);
    76b8:	0b76      	setb	io:0x0e.6

000076ba <.L5>:
  WDG_conditionalAwdRefresh(); /* refresh the timers if they're used */
  while ( IO_GET(EEPROM_FLASH, EE_BUSY) != 0u ) {};
    76ba:	72d8 01c0 	lod	A, 0x1c0 <.LASF47+0x4>
    76be:	ac00      	cmp	A, #0
    76c0:	1afc      	jsl	0x76ba <.L5>

000076c2 <.L6>:
  while (( IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM ) ||/* Wait till FlASH is stopping program/erase */
    76c2:	72d8 01b6 	lod	A, 0x1b6 <.LASF46>
    76c6:	940f      	and	AL, #15
    76c8:	8c04      	cmp	AL, #4
    76ca:	197b      	je	0x76c2 <.L6>

000076cc <.LM13>:
         ( IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE ) ) {};
    76cc:	72d8 01b6 	lod	A, 0x1b6 <.LASF46>

000076d0 <.LM14>:
      }
  }
  IO_SET (PORT_MELIBUS_CTRL, MELIBUS_EN, 0u);
  WDG_conditionalAwdRefresh(); /* refresh the timers if they're used */
  while ( IO_GET(EEPROM_FLASH, EE_BUSY) != 0u ) {};
  while (( IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_PAGE_PROGRAM ) ||/* Wait till FlASH is stopping program/erase */
    76d0:	940f      	and	AL, #15
    76d2:	8c03      	cmp	AL, #3
    76d4:	1976      	je	0x76c2 <.L6>

000076d6 <.LM15>:
         ( IO_GET(EEPROM_FLASH, FL_STATUS) == FLASH_STATUS_SECTOR_ERASE ) ) {};

  __asm__ ("HALT\n\t" :::);
    76d6:	42c9      	halt

000076d8 <.LM16>:
}
    76d8:	5401      	ret

000076da <_moduleWDTInit>:
#include <lib_wdg.h>

void moduleWDTInit(void)
{
  //use absolute watch-dog, it will be activated at POR.
}
    76da:	5401      	ret

000076dc <_moduleWDTStart>:
    76dc:	5401      	ret

000076de <_moduleWDTFeed>:
    76de:	7000      	lod	A, #0
    76e0:	0f7f      	lod	C, io:0x0f.7
    76e2:	b000      	adc	A, #0

000076e4 <.LBE46>:
}

/** WDG_conditionalAwdRefresh acknowledges the AWD timer if its window is opened */
STATIC INLINE void WDG_conditionalAwdRefresh(void)
{
    if (0 != IO_GET(AWD, WIN_OPEN)) {
    76e4:	ac00      	cmp	A, #0
    76e6:	1901      	je	0x76ea <.L3>

000076e8 <.LM6>:
        IO_SET(AWD, ACK, 1);
    76e8:	0b76      	setb	io:0x0e.6

000076ea <.L3>:
}

void moduleWDTFeed(void)
{
  WDG_conditionalAwdRefresh();
}
    76ea:	5401      	ret

000076ec <_moduleTempratureInit>:

void moduleTempratureInit(void)
{
  uint16_t index;

  currentMcuTemp = 25;
    76ec:	7019      	lod	A, #25
    76ee:	52d8 105a 	mov	0x105a <_currentMcuTemp>, A

000076f2 <.LM3>:

  for(index  = 0; index < RGBLEDMAX; index++)
    currentLedTemp[index] = 25*DTEMP_MULTIPLIED_RATIO;
    76f2:	72da 00fa 	lod	A, #250
    76f6:	52d8 127c 	mov	0x127c <_currentLedTemp>, A
    76fa:	52d8 127e 	mov	0x127e <_currentLedTemp+0x2>, A
    76fe:	52d8 1280 	mov	0x1280 <_currentLedTemp+0x4>, A
    7702:	52d8 1282 	mov	0x1282 <_currentLedTemp+0x6>, A
    7706:	52d8 1284 	mov	0x1284 <_currentLedTemp+0x8>, A
    770a:	52d8 1286 	mov	0x1286 <_currentLedTemp+0xa>, A

0000770e <.LM4>:
}
    770e:	5401      	ret

00007710 <_moduleTempratureUpdate>:
extern SLEDPwmSet pwmParam;
extern const uint16_t LEDCHANNELMAP[RGBLEDMAX*RGBLEDCHANNELS];
uint8_t flag_led_temperature_calculate_first_time = 1;
uint8_t flag_mcu_temperature_calculate_first_time = 1;
void moduleTempratureUpdate(SLEDVoltages *LedVoltage)
{
    7710:	5817      	inc	S, #24

00007712 <.LCFI0>:
    7712:	520d      	mov	[S-14], A

00007714 <.LM6>:
  uint16_t index;
  int16_t currentMcuAdc = 0;

  currentMcuAdc = moduleAdcGetTemperature();
    7714:	82db 3532 	callf	0x6a64 <_moduleAdcGetTemperature>

00007718 <.LBB4>:
 * convert ADC value into degree Celsius for internal temperature sensor
 */
static int16_t calcTemperature(uint16_t adcval){
    int16_t result = 0;

    if(adcval>EE_OTEMP_CAL) {
    7718:	7ada 09b4 	lod	Y, #2484
    771c:	7ef0      	lod	X, [Y]
    771e:	aeee      	cmp	A, X
    7720:	1e01      	jug	0x7724 <.LM8>
    7722:	00d3      	jmp	0x78ca <.L3>

00007724 <.LM8>:
        /* negative temperature gradient needed */
        result = (int16_t)((int16_t)((int16_t)(adcval-EE_OTEMP_CAL)*(int16_t)(EE_GAIN_TEMP_LOW_CAL))/TEMPGRADSCALE);
    7724:	aaee      	sub	A, X

00007726 <.LVL10>:
    7726:	7ada 09b8 	lod	Y, #2488
    772a:	66f0      	lod	YL, [Y]
    772c:	5ce6      	ssex	Y
    772e:	4879      	muls	Y, A, Y
    7730:	4446      	rl	Y
    7732:	f6da ff01 	and	Y, #65281
    7736:	7ae8      	swap	Y

00007738 <.LM9>:
        result = (int16_t)(EE_TEMP_MID - result);
    7738:	7eda 09b6 	lod	X, #2486
    773c:	62f8      	lod	AL, [X]
    773e:	5ce2      	ssex	A
    7740:	7ee2      	lod	X, A
    7742:	2ae6      	sub	X, Y

00007744 <.L4>:
  uint16_t index;
  int16_t currentMcuAdc = 0;

  currentMcuAdc = moduleAdcGetTemperature();

  currentMcuTemp = calcTemperature(currentMcuAdc);
    7744:	5ed8 105a 	mov	0x105a <_currentMcuTemp>, X

00007748 <.LM11>:

  if(flag_mcu_temperature_calculate_first_time == 1)
    7748:	62d8 104a 	lod	AL, 0x104a <_flag_mcu_temperature_calculate_first_time>
    774c:	8c01      	cmp	AL, #1
    774e:	1901      	je	0x7752 <.LM12>
    7750:	00ce      	jmp	0x78ee <.L5>

00007752 <.LM12>:
  {
	  lastcurrentMcuTemp = currentMcuTemp;
    7752:	5ed8 1058 	mov	0x1058 <_lastcurrentMcuTemp>, X

00007756 <.LM13>:
	  flag_mcu_temperature_calculate_first_time = 0;
    7756:	6400      	lod	YL, #0
    7758:	46d8 104a 	mov	0x104a <_flag_mcu_temperature_calculate_first_time>, YL

0000775c <.L6>:
//			  blueLedTemp[index] = (blueLedTemp[index] < (-400))?(-400):blueLedTemp[index];
//		  }
//
//		  currentLedTemp[index] = (redLedTemp[index] + greenLedTemp[index] + blueLedTemp[index])/3;

	  currentLedTemp[index] = currentMcuTemp -
    775c:	7ad8 105a 	lod	Y, 0x105a <_currentMcuTemp>
    7760:	5a15      	mov	[S-22], Y
    7762:	7000      	lod	A, #0
    7764:	520b      	mov	[S-12], A

00007766 <.L7>:
    7766:	720b      	lod	A, [S-12]
    7768:	4872 0006 	muls	A, A, #6
    776c:	7ae2      	lod	Y, A
    776e:	e2da 5b3e 	add	Y, #23358
    7772:	5a0f      	mov	[S-16], Y

00007774 <.LM15>:
		  (((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[1]))*40/1000*176*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[0]))*40/1000*200*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[2]))*50/1000*205*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]/1000/32767);
	  currentLedTemp[index] = currentLedTemp[index]*9/10;
	  currentLedTemp[index] = currentLedTemp[index]*DTEMP_MULTIPLIED_RATIO;
    7774:	720b      	lod	A, [S-12]
    7776:	4422      	asl	A
    7778:	7ee2      	lod	X, A
    777a:	22da 127c 	add	X, #4732
    777e:	5e17      	mov	[S-24], X

00007780 <.LM16>:
//		  }
//
//		  currentLedTemp[index] = (redLedTemp[index] + greenLedTemp[index] + blueLedTemp[index])/3;

	  currentLedTemp[index] = currentMcuTemp -
		  (((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[1]))*40/1000*176*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]/1000/32767 +
    7780:	72da 1388 	lod	A, #5000
    7784:	7a0d      	lod	Y, [S-14]
    7786:	aaf2      	sub	A, [Y+2]
    7788:	4cf6      	ssex	YA
    778a:	54ca 0019 	pushw	#25
    778e:	54ca 0000 	pushw	#0

00007792 <.LCFI1>:
    7792:	82db 2e33 	callf	0x5c66 <___divsi3>
    7796:	5c03      	dec	S, #4

00007798 <.LCFI2>:
    7798:	54ca 00b0 	pushw	#176
    779c:	54ca 0000 	pushw	#0

000077a0 <.LCFI3>:
    77a0:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    77a4:	5c03      	dec	S, #4

000077a6 <.LCFI4>:
    77a6:	58a8      	mov	[S-20], YA
    77a8:	7e0f      	lod	X, [S-16]
    77aa:	7ef8      	lod	X, [X]
    77ac:	72ee      	lod	A, X
    77ae:	4422      	asl	A
    77b0:	7ee2      	lod	X, A
    77b2:	22da 1434 	add	X, #5172
    77b6:	4ccf      	movu	D, [X]
    77b8:	4c83      	push	D

000077ba <.LCFI5>:
    77ba:	58ea      	mov	YA, [S-24]
    77bc:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    77c0:	5c03      	dec	S, #4

000077c2 <.LCFI6>:
    77c2:	54ca fc18 	pushw	#64536
    77c6:	54ca 01f3 	pushw	#499

000077ca <.LCFI7>:
    77ca:	82db 2e33 	callf	0x5c66 <___divsi3>
    77ce:	5c03      	dec	S, #4

000077d0 <.LCFI8>:
    77d0:	58a8      	mov	[S-20], YA

000077d2 <.LM17>:
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[0]))*40/1000*200*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]/1000/32767 +
    77d2:	72da 1388 	lod	A, #5000
    77d6:	7a0d      	lod	Y, [S-14]
    77d8:	aaf0      	sub	A, [Y]
    77da:	4cf6      	ssex	YA
    77dc:	54ca 0019 	pushw	#25
    77e0:	54ca 0000 	pushw	#0

000077e4 <.LCFI9>:
    77e4:	82db 2e33 	callf	0x5c66 <___divsi3>
    77e8:	5c03      	dec	S, #4

000077ea <.LCFI10>:
    77ea:	54ca 00c8 	pushw	#200
    77ee:	54ca 0000 	pushw	#0

000077f2 <.LCFI11>:
    77f2:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    77f6:	5c03      	dec	S, #4

000077f8 <.LCFI12>:
    77f8:	58a0      	mov	[S-4], YA
    77fa:	7e0f      	lod	X, [S-16]
    77fc:	7efa      	lod	X, [X+2]
    77fe:	72ee      	lod	A, X
    7800:	4422      	asl	A
    7802:	7ee2      	lod	X, A
    7804:	22da 1434 	add	X, #5172
    7808:	4ccf      	movu	D, [X]
    780a:	4c83      	push	D

0000780c <.LCFI13>:
    780c:	58e2      	mov	YA, [S-8]
    780e:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    7812:	5c03      	dec	S, #4

00007814 <.LCFI14>:
    7814:	54ca fc18 	pushw	#64536
    7818:	54ca 01f3 	pushw	#499

0000781c <.LCFI15>:
    781c:	82db 2e33 	callf	0x5c66 <___divsi3>
    7820:	5c03      	dec	S, #4

00007822 <.LCFI16>:
//			  blueLedTemp[index] = (blueLedTemp[index] < (-400))?(-400):blueLedTemp[index];
//		  }
//
//		  currentLedTemp[index] = (redLedTemp[index] + greenLedTemp[index] + blueLedTemp[index])/3;

	  currentLedTemp[index] = currentMcuTemp -
    7822:	a213      	add	A, [S-20]
    7824:	7a15      	lod	Y, [S-22]
    7826:	eae2      	sub	Y, A
    7828:	5a13      	mov	[S-20], Y

0000782a <.LM19>:
		  (((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[1]))*40/1000*176*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[0]))*40/1000*200*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[2]))*50/1000*205*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]/1000/32767);
    782a:	72da 1388 	lod	A, #5000
    782e:	7e0d      	lod	X, [S-14]
    7830:	aafc      	sub	A, [X+4]
    7832:	4cf6      	ssex	YA
    7834:	54ca 0014 	pushw	#20
    7838:	54ca 0000 	pushw	#0

0000783c <.LCFI17>:
    783c:	82db 2e33 	callf	0x5c66 <___divsi3>
    7840:	5c03      	dec	S, #4

00007842 <.LCFI18>:
    7842:	54ca 00cd 	pushw	#205
    7846:	54ca 0000 	pushw	#0

0000784a <.LCFI19>:
    784a:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    784e:	5c03      	dec	S, #4

00007850 <.LCFI20>:
    7850:	58a0      	mov	[S-4], YA
    7852:	7e0f      	lod	X, [S-16]
    7854:	7afc      	lod	Y, [X+4]
    7856:	72e6      	lod	A, Y
    7858:	4422      	asl	A
    785a:	7ee2      	lod	X, A
    785c:	22da 1434 	add	X, #5172
    7860:	4ccf      	movu	D, [X]
    7862:	4c83      	push	D

00007864 <.LCFI21>:
    7864:	58e2      	mov	YA, [S-8]
    7866:	82db 2dd3 	callf	0x5ba6 <___mulsi3>
    786a:	5c03      	dec	S, #4

0000786c <.LCFI22>:
    786c:	54ca fc18 	pushw	#64536
    7870:	54ca 01f3 	pushw	#499

00007874 <.LCFI23>:
    7874:	82db 2e33 	callf	0x5c66 <___divsi3>
    7878:	5c03      	dec	S, #4

0000787a <.LCFI24>:
//			  blueLedTemp[index] = (blueLedTemp[index] < (-400))?(-400):blueLedTemp[index];
//		  }
//
//		  currentLedTemp[index] = (redLedTemp[index] + greenLedTemp[index] + blueLedTemp[index])/3;

	  currentLedTemp[index] = currentMcuTemp -
    787a:	7e13      	lod	X, [S-20]
    787c:	2ae2      	sub	X, A
    787e:	72ee      	lod	A, X

00007880 <.LM21>:
		  (((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[1]))*40/1000*176*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 0]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[0]))*40/1000*200*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 1]]/1000/32767 +
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[2]))*50/1000*205*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]/1000/32767);
	  currentLedTemp[index] = currentLedTemp[index]*9/10;
    7880:	4872 0009 	muls	A, A, #9
    7884:	4cf8      	movs	YA, A
    7886:	4c72 000a 	divs	YA, #10
    788a:	4c72 000a 	divs	YA, #10
    788e:	4c7a 000a 	dadjs	YA, #10

00007892 <.LM22>:
	  currentLedTemp[index] = currentLedTemp[index]*DTEMP_MULTIPLIED_RATIO;
    7892:	4872 000a 	muls	A, A, #10
    7896:	7a17      	lod	Y, [S-24]
    7898:	52f0      	mov	[Y], A

0000789a <.LM23>:
  {
	  currentMcuTemp = (lastcurrentMcuTemp*4 + currentMcuTemp*3)/7;
	  lastcurrentMcuTemp = currentMcuTemp;
  }

  for (index = 0; index < RGBLEDMAX; index++)
    789a:	720b      	lod	A, [S-12]
    789c:	a001      	add	A, #1
    789e:	520b      	mov	[S-12], A

000078a0 <.LVL50>:
    78a0:	7a0d      	lod	Y, [S-14]
    78a2:	e006      	add	Y, #6
    78a4:	5a0d      	mov	[S-14], Y
    78a6:	ac06      	cmp	A, #6
    78a8:	1901      	je	0x78ac <.LM24>
    78aa:	075d      	jmp	0x7766 <.L7>

000078ac <.LM24>:
		   ((int32_t)(5000 - LedVoltage->LedVoltage[index].ledChannelData[2]))*50/1000*205*pwmParam.LedRGB[LEDCHANNELMAP[index*RGBLEDCHANNELS + 2]]/1000/32767);
	  currentLedTemp[index] = currentLedTemp[index]*9/10;
	  currentLedTemp[index] = currentLedTemp[index]*DTEMP_MULTIPLIED_RATIO;
//	  }
  }
  if(flag_led_temperature_calculate_first_time == 1)
    78ac:	62d8 104b 	lod	AL, 0x104b <_flag_led_temperature_calculate_first_time>

000078b0 <.LVL51>:
    78b0:	8c01      	cmp	AL, #1
    78b2:	1d31      	jne	0x7916 <.L10>
    78b4:	7ada 104c 	lod	Y, #4172
    78b8:	7eda 127c 	lod	X, #4732
    78bc:	54e6      	mov	Cx, #6
    78be:	54ce      	movsw	[Y++], [X++]
    78c0:	1ffe      	djnz	Cx, 0x78be <.LVL51+0xe>

000078c2 <.LM25>:
  {
	  for (index = 0; index < RGBLEDMAX; index++)
	  {
		  lastcurrentLedTemp[index] = currentLedTemp[index];
	  }
	  flag_led_temperature_calculate_first_time = 0;
    78c2:	6400      	lod	YL, #0
    78c4:	46d8 104b 	mov	0x104b <_flag_led_temperature_calculate_first_time>, YL
    78c8:	5419      	ret	#26

000078ca <.L3>:
        result = (int16_t)((int16_t)((int16_t)(adcval-EE_OTEMP_CAL)*(int16_t)(EE_GAIN_TEMP_LOW_CAL))/TEMPGRADSCALE);
        result = (int16_t)(EE_TEMP_MID - result);
    }
    else {
        /* positive temperature gradient needed */
        result = (int16_t)((int16_t)((int16_t)(EE_OTEMP_CAL-adcval)*(int16_t)(EE_GAIN_TEMP_HIGH_CAL))/TEMPGRADSCALE);
    78ca:	2ae2      	sub	X, A
    78cc:	7ada 09b9 	lod	Y, #2489
    78d0:	66f0      	lod	YL, [Y]
    78d2:	5ce6      	ssex	Y
    78d4:	72ee      	lod	A, X

000078d6 <.LVL53>:
    78d6:	4879      	muls	Y, A, Y
    78d8:	4446      	rl	Y
    78da:	f6da ff01 	and	Y, #65281
    78de:	7ae8      	swap	Y
    78e0:	7ee6      	lod	X, Y

000078e2 <.LM27>:
        result = (int16_t)(result + EE_TEMP_MID);
    78e2:	7ada 09b6 	lod	Y, #2486

000078e6 <.LVL55>:
    78e6:	62f0      	lod	AL, [Y]
    78e8:	5ce2      	ssex	A
    78ea:	22e2      	add	X, A
    78ec:	072b      	jmp	0x7744 <.L4>

000078ee <.L5>:
	  lastcurrentMcuTemp = currentMcuTemp;
	  flag_mcu_temperature_calculate_first_time = 0;
  }
  else
  {
	  currentMcuTemp = (lastcurrentMcuTemp*4 + currentMcuTemp*3)/7;
    78ee:	7ad8 1058 	lod	Y, 0x1058 <_lastcurrentMcuTemp>
    78f2:	44a6      	asl	Y, #2
    78f4:	72ee      	lod	A, X
    78f6:	4872 0003 	muls	A, A, #3
    78fa:	520b      	mov	[S-12], A
    78fc:	a2e6      	add	A, Y
    78fe:	4cf8      	movs	YA, A
    7900:	4c72 0007 	divs	YA, #7
    7904:	4c72 0007 	divs	YA, #7
    7908:	4c7a 0007 	dadjs	YA, #7
    790c:	52d8 105a 	mov	0x105a <_currentMcuTemp>, A

00007910 <.LM29>:
	  lastcurrentMcuTemp = currentMcuTemp;
    7910:	52d8 1058 	mov	0x1058 <_lastcurrentMcuTemp>, A
    7914:	0723      	jmp	0x775c <.L6>

00007916 <.L10>:
    7916:	7c00      	lod	X, #0

00007918 <.L8>:
    7918:	7aee      	lod	Y, X
    791a:	e2da 104c 	add	Y, #4172
    791e:	5a0f      	mov	[S-16], Y
    7920:	7aee      	lod	Y, X
    7922:	e2da 127c 	add	Y, #4732
    7926:	5a0d      	mov	[S-14], Y

00007928 <.LM30>:
  }
  else
  {
	  for (index = 0; index < RGBLEDMAX; index++)
	  {
		  currentLedTemp[index] = (lastcurrentLedTemp[index]*4 + currentLedTemp[index]*3)/7;
    7928:	7a0f      	lod	Y, [S-16]
    792a:	72f0      	lod	A, [Y]
    792c:	44a2      	asl	A, #2
    792e:	5213      	mov	[S-20], A
    7930:	7a0d      	lod	Y, [S-14]
    7932:	72f0      	lod	A, [Y]
    7934:	487a 0003 	muls	Y, A, #3
    7938:	7213      	lod	A, [S-20]
    793a:	a2e6      	add	A, Y
    793c:	4cf8      	movs	YA, A
    793e:	4c72 0007 	divs	YA, #7
    7942:	4c72 0007 	divs	YA, #7
    7946:	4c7a 0007 	dadjs	YA, #7
    794a:	7a0d      	lod	Y, [S-14]
    794c:	52f0      	mov	[Y], A

0000794e <.LM31>:
		  lastcurrentLedTemp[index] = currentLedTemp[index];
    794e:	7a0f      	lod	Y, [S-16]
    7950:	52f0      	mov	[Y], A
    7952:	2002      	add	X, #2

00007954 <.LM32>:
	  }
	  flag_led_temperature_calculate_first_time = 0;
  }
  else
  {
	  for (index = 0; index < RGBLEDMAX; index++)
    7954:	720b      	lod	A, [S-12]
    7956:	a0ff      	add	A, #-1
    7958:	520b      	mov	[S-12], A
    795a:	1d5e      	jne	0x7918 <.L8>

0000795c <.LM33>:
	  {
		  currentLedTemp[index] = (lastcurrentLedTemp[index]*4 + currentLedTemp[index]*3)/7;
		  lastcurrentLedTemp[index] = currentLedTemp[index];
	  }
  }
}
    795c:	5419      	ret	#26

0000795e <_moduleTempratureGetMcu>:

int16_t moduleTempratureGetMcu(void)
{
  return currentMcuTemp;
}
    795e:	72d8 105a 	lod	A, 0x105a <_currentMcuTemp>
    7962:	5401      	ret

00007964 <_moduleTempratureGetLed>:
int16_t moduleTempratureGetLed(uint16_t ledNum)
{
  if (ledNum >= RGBLEDMAX)
    ledNum  = RGBLEDMAX-1;

  return currentLedTemp[ledNum];
    7964:	ac05      	cmp	A, #5
    7966:	1a01      	jule	0x796a <.L15>
    7968:	7005      	lod	A, #5

0000796a <.L15>:
    796a:	4422      	asl	A
    796c:	7ae2      	lod	Y, A
    796e:	e2da 127c 	add	Y, #4732
    7972:	72f0      	lod	A, [Y]

00007974 <.LM38>:
}
    7974:	5401      	ret

00007976 <_moduleBatteryUpdate>:
    return result;
}

void moduleBatteryUpdate(void)
{
  uint16_t tempValue = moduleAdcGetVs();
    7976:	82db 3535 	callf	0x6a6a <_moduleAdcGetVs>

0000797a <.LBB4>:
static uint16_t calcVSmVolt(uint16_t adcval){
    uint16_t result = 0;

    /* VS_Voltage [mV] = (ADC_Val * 14 * ADC_Ref_Volt(2.5) / ADC_Resolution (1023)) * 1000 (mV)
     * -> 2.5 = 5/2 -> avoids float operations */
    result = adcval * 14;//ADCVSDIVIDER = 14
    797a:	4872 000e 	muls	A, A, #14

0000797e <.LM10>:
    result = (uint16_t)((uint32_t)((uint32_t)result * (uint32_t)5000) / (uint32_t)2046);
    797e:	4822 1388 	mulu	YA, A, #5000

00007982 <.LVL2>:
    7982:	54ca 07fe 	pushw	#2046
    7986:	54ca 0000 	pushw	#0

0000798a <.LCFI0>:
    798a:	82db 2e68 	callf	0x5cd0 <___udivsi3>
    798e:	5c03      	dec	S, #4

00007990 <.LCFI1>:
    7990:	52d8 105c 	mov	0x105c <_currentVoltage>, A

00007994 <.LBE4>:
void moduleBatteryUpdate(void)
{
  uint16_t tempValue = moduleAdcGetVs();

  currentVoltage = calcVSmVolt(tempValue);
}
    7994:	5401      	ret

00007996 <_system_Init>:
#include <atomic.h>

SColorParams currentColorSets;

void system_Init(void)
{
    7996:	5809      	inc	S, #10

00007998 <.LCFI0>:
  uint16_t index;

  /*Initialize watch dog*/
  moduleWDTInit();
    7998:	16a0      	call	0x76da <_moduleWDTInit>

0000799a <.LM3>:
  moduleWDTStart();
    799a:	16a0      	call	0x76dc <_moduleWDTStart>

0000799c <.LM4>:
  moduleWDTFeed();
    799c:	16a0      	call	0x76de <_moduleWDTFeed>

0000799e <.LM5>:
  /*Initialize flash*/
  moduleFlashInit();
    799e:	82db 37f9 	callf	0x6ff2 <_moduleFlashInit>

000079a2 <.LM6>:
  /*Initialize ADC*/
  moduleAdcInit();
    79a2:	82db 34bc 	callf	0x6978 <_moduleAdcInit>

000079a6 <.LM7>:
  /*Initialize PWM*/
  modulePwmInit();
    79a6:	82db 38be 	callf	0x717c <_modulePwmInit>

000079aa <.LM8>:
  /*Initialize communication*/
  moduleCommInit();
    79aa:	82db 35ec 	callf	0x6bd8 <_moduleCommInit>

000079ae <.LM9>:
  /*Initialize Temprature*/
  moduleTempratureInit();
    79ae:	169e      	call	0x76ec <_moduleTempratureInit>

000079b0 <.LM10>:

  /*Initialize System Status*/
  systemStatusInit();
    79b0:	10f6      	call	0x7b9e <_systemStatusInit>

000079b2 <.LM11>:
  /*Initialize System Control*/
  systemControlInit();
    79b2:	1113      	call	0x7bda <_systemControlInit>

000079b4 <.LM12>:

  /*Initialize Algorithm*/
  for (index = 0; index < RGBLEDMAX; index++)
    79b4:	7000      	lod	A, #0
    79b6:	5209      	mov	[S-10], A

000079b8 <.L2>:
    79b8:	7209      	lod	A, [S-10]
    79ba:	44a2      	asl	A, #2
    79bc:	a2da 1364 	add	A, #4964
    79c0:	5203      	mov	[S-4], A
    79c2:	7209      	lod	A, [S-10]
    79c4:	4422      	asl	A
    79c6:	7ae2      	lod	Y, A
    79c8:	e2da 1364 	add	Y, #4964
    79cc:	5a01      	mov	[S-2], Y

000079ce <.LM13>:
  {
    algoUpdateRedCIE(index, savedConfig.redx[index], savedConfig.redy[index], savedConfig.redY[index]);
    79ce:	7a03      	lod	Y, [S-4]
    79d0:	e01a      	add	Y, #26
    79d2:	7ef0      	lod	X, [Y]
    79d4:	5edf      	push	X

000079d6 <.LCFI1>:
    79d6:	7ef2      	lod	X, [Y+2]
    79d8:	5edf      	push	X

000079da <.LCFI2>:
    79da:	7205      	lod	A, [S-6]
    79dc:	a00e      	add	A, #14
    79de:	7ae2      	lod	Y, A
    79e0:	72f0      	lod	A, [Y]
    79e2:	52df      	push	A

000079e4 <.LCFI3>:
    79e4:	7e07      	lod	X, [S-8]
    79e6:	72fa      	lod	A, [X+2]
    79e8:	52df      	push	A

000079ea <.LCFI4>:
    79ea:	7211      	lod	A, [S-18]
    79ec:	82db 2eab 	callf	0x5d56 <_algoUpdateRedCIE>

000079f0 <.LM14>:
    algoUpdateGreenCIE(index, savedConfig.greenx[index], savedConfig.greeny[index], savedConfig.greenY[index]);
    79f0:	720b      	lod	A, [S-12]
    79f2:	a04a      	add	A, #74
    79f4:	7ee2      	lod	X, A
    79f6:	7af8      	lod	Y, [X]
    79f8:	5adf      	push	Y

000079fa <.LCFI5>:
    79fa:	7afa      	lod	Y, [X+2]
    79fc:	5adf      	push	Y

000079fe <.LCFI6>:
    79fe:	720d      	lod	A, [S-14]
    7a00:	a03e      	add	A, #62
    7a02:	7ae2      	lod	Y, A
    7a04:	72f0      	lod	A, [Y]
    7a06:	52df      	push	A

00007a08 <.LCFI7>:
    7a08:	720f      	lod	A, [S-16]
    7a0a:	a032      	add	A, #50
    7a0c:	7ee2      	lod	X, A
    7a0e:	72f8      	lod	A, [X]
    7a10:	52df      	push	A

00007a12 <.LCFI8>:
    7a12:	7219      	lod	A, [S-26]
    7a14:	82db 2ec2 	callf	0x5d84 <_algoUpdateGreenCIE>

00007a18 <.LM15>:
    algoUpdateBlueCIE(index, savedConfig.bluex[index], savedConfig.bluey[index], savedConfig.blueY[index]);
    7a18:	7e13      	lod	X, [S-20]
    7a1a:	207a      	add	X, #122
    7a1c:	72f8      	lod	A, [X]
    7a1e:	52df      	push	A

00007a20 <.LCFI9>:
    7a20:	72fa      	lod	A, [X+2]
    7a22:	52df      	push	A

00007a24 <.LCFI10>:
    7a24:	7e15      	lod	X, [S-22]
    7a26:	206e      	add	X, #110
    7a28:	72f8      	lod	A, [X]
    7a2a:	52df      	push	A

00007a2c <.LCFI11>:
    7a2c:	7a17      	lod	Y, [S-24]
    7a2e:	e062      	add	Y, #98
    7a30:	72f0      	lod	A, [Y]
    7a32:	52df      	push	A

00007a34 <.LCFI12>:
    7a34:	7221      	lod	A, [S-34]
    7a36:	82db 2ed9 	callf	0x5db2 <_algoUpdateBlueCIE>

00007a3a <.LM16>:
  systemStatusInit();
  /*Initialize System Control*/
  systemControlInit();

  /*Initialize Algorithm*/
  for (index = 0; index < RGBLEDMAX; index++)
    7a3a:	7a21      	lod	Y, [S-34]
    7a3c:	e001      	add	Y, #1
    7a3e:	5a21      	mov	[S-34], Y

00007a40 <.LVL26>:
    7a40:	5c17      	dec	S, #24

00007a42 <.LCFI13>:
    7a42:	ec06      	cmp	Y, #6
    7a44:	1901      	je	0x7a48 <.LCFI13+0x6>
    7a46:	07b8      	jmp	0x79b8 <.L2>
    7a48:	7ada 1494 	lod	Y, #5268
    7a4c:	6000      	lod	AL, #0
    7a4e:	54ec      	mov	Cx, #12
    7a50:	42d6      	mov	[Y++], AL
    7a52:	1ffe      	djnz	Cx, 0x7a50 <.LCFI13+0xe>

00007a54 <.LVL28>:
    7a54:	7ada 147c 	lod	Y, #5244
    7a58:	54ec      	mov	Cx, #12
    7a5a:	42d6      	mov	[Y++], AL
    7a5c:	1ffe      	djnz	Cx, 0x7a5a <.LVL28+0x6>
    7a5e:	7ada 1488 	lod	Y, #5256
    7a62:	54ec      	mov	Cx, #12
    7a64:	42d6      	mov	[Y++], AL
    7a66:	1ffe      	djnz	Cx, 0x7a64 <.LVL28+0x10>
    7a68:	7ada 14a0 	lod	Y, #5280
    7a6c:	54ec      	mov	Cx, #12
    7a6e:	42d6      	mov	[Y++], AL
    7a70:	1ffe      	djnz	Cx, 0x7a6e <.LVL28+0x1a>
    7a72:	7ada 14ac 	lod	Y, #5292
    7a76:	54ec      	mov	Cx, #12
    7a78:	42d6      	mov	[Y++], AL
    7a7a:	1ffe      	djnz	Cx, 0x7a78 <.LVL28+0x24>

00007a7c <.LM17>:
    currentColorSets.colorV[index] = 0;
    currentColorSets.ledTemprature[index] = 0;
    currentColorSets.tempAdjust[index] = 0;
  }

}
    7a7c:	540b      	ret	#12

00007a7e <_system_Main_Loop>:

SPWMParams ouputPwm;
void system_Main_Loop(void)
{
    7a7e:	5811      	inc	S, #18

00007a80 <.LCFI14>:
  uint16_t ledIndex;
  //SLEDPwmSet pwmParam;
  SCommMessage message;

  moduleWDTFeed();
    7a80:	162e      	call	0x76de <_moduleWDTFeed>

00007a82 <.LM20>:

  systemStatusUpdate();
    7a82:	1090      	call	0x7ba4 <_systemStatusUpdate>

00007a84 <.LM21>:

  if (flashFlag == EFlashUpdateProcessing)
    7a84:	72d8 1362 	lod	A, 0x1362 <_flashFlag>
    7a88:	ac01      	cmp	A, #1
    7a8a:	1901      	je	0x7a8e <.LBB17>
    7a8c:	0054      	jmp	0x7b36 <.L10>

00007a8e <.LBB17>:
static __attribute__((always_inline)) inline
uint16_t builtin_mlx16_get_status (void)
{
    uint16_t status;

    __asm__ __volatile__ (
    7a8e:	7ae3      	lod	Y, M

00007a90 <.LBB20>:
    implementing them manually.
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_disable_interrupts(void)
{
    __asm__ __volatile__ (
    7a90:	08b2      	clrb	MH.2
    7a92:	08b1      	clrb	MH.1
    7a94:	08b0      	clrb	MH.0

00007a96 <.LBE20>:
  {
    ENTER_SECTION(ATOMIC_KEEP_MODE);
    flashFlag = EFlashUpdateFree;
    7a96:	7000      	lod	A, #0
    7a98:	52d8 1362 	mov	0x1362 <_flashFlag>, A

00007a9c <.LBB23>:

 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_status (uint16_t status)
{
    __asm__ __volatile__ (
    7a9c:	5ae3      	mov	M, Y

00007a9e <.LBE17>:
    EXIT_SECTION();

    /*update LED R/G/B light attributes*/
    for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    7a9e:	5209      	mov	[S-10], A

00007aa0 <.L11>:
    7aa0:	7209      	lod	A, [S-10]
    7aa2:	44a2      	asl	A, #2
    7aa4:	a2da 1364 	add	A, #4964
    7aa8:	5203      	mov	[S-4], A
    7aaa:	7209      	lod	A, [S-10]
    7aac:	4422      	asl	A
    7aae:	7ae2      	lod	Y, A
    7ab0:	e2da 1364 	add	Y, #4964
    7ab4:	5a01      	mov	[S-2], Y

00007ab6 <.LM27>:
    {
      algoUpdateRedCIE(ledIndex, savedConfig.redx[ledIndex], savedConfig.redy[ledIndex], savedConfig.redY[ledIndex]);
    7ab6:	7a03      	lod	Y, [S-4]
    7ab8:	e01a      	add	Y, #26
    7aba:	7ef0      	lod	X, [Y]
    7abc:	5edf      	push	X

00007abe <.LCFI15>:
    7abe:	7ef2      	lod	X, [Y+2]
    7ac0:	5edf      	push	X

00007ac2 <.LCFI16>:
    7ac2:	7205      	lod	A, [S-6]
    7ac4:	a00e      	add	A, #14
    7ac6:	7ae2      	lod	Y, A
    7ac8:	72f0      	lod	A, [Y]
    7aca:	52df      	push	A

00007acc <.LCFI17>:
    7acc:	7e07      	lod	X, [S-8]
    7ace:	72fa      	lod	A, [X+2]
    7ad0:	52df      	push	A

00007ad2 <.LCFI18>:
    7ad2:	7211      	lod	A, [S-18]
    7ad4:	82db 2eab 	callf	0x5d56 <_algoUpdateRedCIE>

00007ad8 <.LM28>:
      algoUpdateGreenCIE(ledIndex, savedConfig.greenx[ledIndex], savedConfig.greeny[ledIndex], savedConfig.greenY[ledIndex]);
    7ad8:	720b      	lod	A, [S-12]
    7ada:	a04a      	add	A, #74
    7adc:	7ee2      	lod	X, A
    7ade:	7af8      	lod	Y, [X]
    7ae0:	5adf      	push	Y

00007ae2 <.LCFI19>:
    7ae2:	7afa      	lod	Y, [X+2]
    7ae4:	5adf      	push	Y

00007ae6 <.LCFI20>:
    7ae6:	720d      	lod	A, [S-14]
    7ae8:	a03e      	add	A, #62
    7aea:	7ae2      	lod	Y, A
    7aec:	72f0      	lod	A, [Y]
    7aee:	52df      	push	A

00007af0 <.LCFI21>:
    7af0:	720f      	lod	A, [S-16]
    7af2:	a032      	add	A, #50
    7af4:	7ee2      	lod	X, A
    7af6:	72f8      	lod	A, [X]
    7af8:	52df      	push	A

00007afa <.LCFI22>:
    7afa:	7219      	lod	A, [S-26]
    7afc:	82db 2ec2 	callf	0x5d84 <_algoUpdateGreenCIE>

00007b00 <.LM29>:
      algoUpdateBlueCIE(ledIndex, savedConfig.bluex[ledIndex], savedConfig.bluey[ledIndex], savedConfig.blueY[ledIndex]);
    7b00:	7e13      	lod	X, [S-20]
    7b02:	207a      	add	X, #122
    7b04:	72f8      	lod	A, [X]
    7b06:	52df      	push	A

00007b08 <.LCFI23>:
    7b08:	72fa      	lod	A, [X+2]
    7b0a:	52df      	push	A

00007b0c <.LCFI24>:
    7b0c:	7e15      	lod	X, [S-22]
    7b0e:	206e      	add	X, #110
    7b10:	72f8      	lod	A, [X]
    7b12:	52df      	push	A

00007b14 <.LCFI25>:
    7b14:	7a17      	lod	Y, [S-24]
    7b16:	e062      	add	Y, #98
    7b18:	72f0      	lod	A, [Y]
    7b1a:	52df      	push	A

00007b1c <.LCFI26>:
    7b1c:	7221      	lod	A, [S-34]
    7b1e:	82db 2ed9 	callf	0x5db2 <_algoUpdateBlueCIE>

00007b22 <.LM30>:
    ENTER_SECTION(ATOMIC_KEEP_MODE);
    flashFlag = EFlashUpdateFree;
    EXIT_SECTION();

    /*update LED R/G/B light attributes*/
    for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    7b22:	7a21      	lod	Y, [S-34]
    7b24:	e001      	add	Y, #1
    7b26:	5a21      	mov	[S-34], Y

00007b28 <.LVL50>:
    7b28:	5c17      	dec	S, #24

00007b2a <.LCFI27>:
    7b2a:	ec06      	cmp	Y, #6
    7b2c:	1901      	je	0x7b30 <.LM31>
    7b2e:	07b8      	jmp	0x7aa0 <.L11>

00007b30 <.LM31>:
    {
      algoUpdateRedCIE(ledIndex, savedConfig.redx[ledIndex], savedConfig.redy[ledIndex], savedConfig.redY[ledIndex]);
      algoUpdateGreenCIE(ledIndex, savedConfig.greenx[ledIndex], savedConfig.greeny[ledIndex], savedConfig.greenY[ledIndex]);
      algoUpdateBlueCIE(ledIndex, savedConfig.bluex[ledIndex], savedConfig.bluey[ledIndex], savedConfig.blueY[ledIndex]);
    }
    moduleFlashSave();
    7b30:	82db 379a 	callf	0x6f34 <_moduleFlashSave>
    7b34:	5413      	ret	#20

00007b36 <.L10>:
  }
  else
  {
    /* check if new Melibu data has been received */
    if ((moduleCommFlagUpdated() == btrue) && (moduleCommGetData(&message) == btrue))
    7b36:	82db 3622 	callf	0x6c44 <_moduleCommFlagUpdated>
    7b3a:	ac01      	cmp	A, #1
    7b3c:	1d0e      	jne	0x7b5a <.L14>

00007b3e <.LM33>:
    7b3e:	72ef      	lod	A, S
    7b40:	a0ee      	add	A, #-18
    7b42:	82db 3633 	callf	0x6c66 <_moduleCommGetData>
    7b46:	ac01      	cmp	A, #1
    7b48:	1d08      	jne	0x7b5a <.L14>

00007b4a <.LM34>:
    {
      moduleCommFlagClear();
    7b4a:	82db 362a 	callf	0x6c54 <_moduleCommFlagClear>

00007b4e <.LM35>:

      systemProtocolControl(&message, &currentColorSets);
    7b4e:	54ca 147c 	pushw	#5244

00007b52 <.LCFI28>:
    7b52:	72ef      	lod	A, S
    7b54:	a0ec      	add	A, #-20
    7b56:	11bd      	call	0x7ed2 <_systemProtocolControl>
    7b58:	5c01      	dec	S, #2

00007b5a <.L14>:
    ENTER_SECTION(ATOMIC_KEEP_MODE);
    flashFlag = EFlashUpdateFree;
    EXIT_SECTION();

    /*update LED R/G/B light attributes*/
    for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    7b5a:	7000      	lod	A, #0
    7b5c:	5201      	mov	[S-2], A

00007b5e <.L16>:

//	  systemProtocolControl(&message, &currentColorSets);

    for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    {
      currentColorSets.ledTemprature[ledIndex] = moduleTempratureGetLed(ledIndex);
    7b5e:	7201      	lod	A, [S-2]
    7b60:	1701      	call	0x7964 <_moduleTempratureGetLed>
    7b62:	5209      	mov	[S-10], A
    7b64:	7201      	lod	A, [S-2]
    7b66:	4422      	asl	A
    7b68:	a2da 147c 	add	A, #5244
    7b6c:	7ae2      	lod	Y, A
    7b6e:	e024      	add	Y, #36
    7b70:	7e09      	lod	X, [S-10]
    7b72:	5ef0      	mov	[Y], X

00007b74 <.LM38>:
      currentColorSets.tempAdjust[ledIndex] = 100 << DINTENSITY_TEMP_ADJUST_SHIFT_LEVEL;
    7b74:	a030      	add	A, #48
    7b76:	7ada 1900 	lod	Y, #6400
    7b7a:	7ee2      	lod	X, A
    7b7c:	5af8      	mov	[X], Y

00007b7e <.LM39>:
      systemProtocolControl(&message, &currentColorSets);
    }

//	  systemProtocolControl(&message, &currentColorSets);

    for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    7b7e:	7201      	lod	A, [S-2]
    7b80:	a001      	add	A, #1
    7b82:	5201      	mov	[S-2], A

00007b84 <.LVL60>:
    7b84:	ac06      	cmp	A, #6
    7b86:	1d6b      	jne	0x7b5e <.L16>

00007b88 <.LM40>:
    {
      currentColorSets.ledTemprature[ledIndex] = moduleTempratureGetLed(ledIndex);
      currentColorSets.tempAdjust[ledIndex] = 100 << DINTENSITY_TEMP_ADJUST_SHIFT_LEVEL;
    }

    algoGetPWMOutput(&currentColorSets, &ouputPwm);
    7b88:	54ca 1458 	pushw	#5208

00007b8c <.LCFI30>:
    7b8c:	72da 147c 	lod	A, #5244

00007b90 <.LVL61>:
    7b90:	82db 2ef0 	callf	0x5de0 <_algoGetPWMOutput>

00007b94 <.LM41>:

    modulePwmSet(&ouputPwm);
    7b94:	72da 1458 	lod	A, #5208
    7b98:	82db 39b1 	callf	0x7362 <_modulePwmSet>

00007b9c <.LCFI31>:
  }
}
    7b9c:	5415      	ret	#22

00007b9e <_systemStatusInit>:

#define LOOP_CNT_GET_TEMPERATURE 300

void systemStatusInit(void)
{
	LedVoltageInit(&currentLedVoltage);
    7b9e:	72da 14b8 	lod	A, #5304
    7ba2:	001c      	jmp	0x7bdc <_LedVoltageInit>

00007ba4 <_systemStatusUpdate>:

void systemStatusUpdate(void)
{
  static uint16_t Main_Loop_Cnt = 0;

  if (moduleAdcDataReady() == 1)
    7ba4:	82db 3522 	callf	0x6a44 <_moduleAdcDataReady>
    7ba8:	ac01      	cmp	A, #1
    7baa:	1d16      	jne	0x7bd8 <.L2>

00007bac <.LM6>:
  {
    moduleAdcDataClear();
    7bac:	82db 3529 	callf	0x6a52 <_moduleAdcDataClear>

00007bb0 <.LM7>:

    moduleBatteryUpdate();
    7bb0:	16e2      	call	0x7976 <_moduleBatteryUpdate>

00007bb2 <.LM8>:
    moduleLedVoltageUpdate();
    7bb2:	82db 3566 	callf	0x6acc <_moduleLedVoltageUpdate>

00007bb6 <.LM9>:
    if(Main_Loop_Cnt == LOOP_CNT_GET_TEMPERATURE)
    7bb6:	72d8 1288 	lod	A, 0x1288 <___Main_Loop_Cnt_1528>
    7bba:	aeda 012c 	cmp	A, #300
    7bbe:	1d06      	jne	0x7bcc <.L4>

00007bc0 <.LM10>:
	{
		moduleTempratureUpdate(&currentLedVoltage);
    7bc0:	72da 14b8 	lod	A, #5304
    7bc4:	15a5      	call	0x7710 <_moduleTempratureUpdate>

00007bc6 <.LM11>:
		Main_Loop_Cnt = 0;
    7bc6:	7000      	lod	A, #0
    7bc8:	52d8 1288 	mov	0x1288 <___Main_Loop_Cnt_1528>, A

00007bcc <.L4>:
	}

    slaveStatusBufferUpdate();
    7bcc:	1037      	call	0x7c3c <_slaveStatusBufferUpdate>

00007bce <.LM13>:

    Main_Loop_Cnt++;
    7bce:	72d8 1288 	lod	A, 0x1288 <___Main_Loop_Cnt_1528>
    7bd2:	a001      	add	A, #1
    7bd4:	52d8 1288 	mov	0x1288 <___Main_Loop_Cnt_1528>, A

00007bd8 <.L2>:
  }
  else
  {}
}
    7bd8:	5401      	ret

00007bda <_systemControlInit>:
}SLedColorData_t;

void systemControlInit(void)
{

}
    7bda:	5401      	ret

00007bdc <_LedVoltageInit>:

uint8_t shortCutState = 0;
uint8_t openState = 0;

void LedVoltageInit(SLEDVoltages *LedVoltage)
{
    7bdc:	7ae2      	lod	Y, A
    7bde:	7c06      	lod	X, #6

00007be0 <.L3>:
	uint16_t cntLeds = 0;

	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
	{
		LedVoltage->LedVoltage[cntLeds].ledChannelData[1]  = 1745;
    7be0:	72da 06d1 	lod	A, #1745
    7be4:	52f2      	mov	[Y+2], A

00007be6 <.LM5>:
		LedVoltage->LedVoltage[cntLeds].ledChannelData[0]  = 2758;
    7be6:	72da 0ac6 	lod	A, #2758
    7bea:	52f0      	mov	[Y], A

00007bec <.LM6>:
		LedVoltage->LedVoltage[cntLeds].ledChannelData[2]  = 2599;
    7bec:	72da 0a27 	lod	A, #2599
    7bf0:	52f4      	mov	[Y+4], A
    7bf2:	e006      	add	Y, #6

00007bf4 <.LM7>:

void LedVoltageInit(SLEDVoltages *LedVoltage)
{
	uint16_t cntLeds = 0;

	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    7bf4:	1bf5      	djnz	X, 0x7be0 <.L3>

00007bf6 <.LM8>:
	{
		LedVoltage->LedVoltage[cntLeds].ledChannelData[1]  = 1745;
		LedVoltage->LedVoltage[cntLeds].ledChannelData[0]  = 2758;
		LedVoltage->LedVoltage[cntLeds].ledChannelData[2]  = 2599;
	}
}
    7bf6:	5401      	ret

00007bf8 <_ShortCutCntInit>:

void ShortCutCntInit(void)
{
    7bf8:	7ada 12bc 	lod	Y, #4796
    7bfc:	6000      	lod	AL, #0
    7bfe:	54ec      	mov	Cx, #12
    7c00:	42d6      	mov	[Y++], AL
    7c02:	1ffe      	djnz	Cx, 0x7c00 <_ShortCutCntInit+0x8>
    7c04:	7ada 12a4 	lod	Y, #4772
    7c08:	54ec      	mov	Cx, #12
    7c0a:	42d6      	mov	[Y++], AL
    7c0c:	1ffe      	djnz	Cx, 0x7c0a <_ShortCutCntInit+0x12>
    7c0e:	7ada 128c 	lod	Y, #4748
    7c12:	54ec      	mov	Cx, #12
    7c14:	42d6      	mov	[Y++], AL
    7c16:	1ffe      	djnz	Cx, 0x7c14 <_ShortCutCntInit+0x1c>

00007c18 <.LM10>:
	{
		cntredLedShortCut[cntLeds] = 0;
		cntgreenLedShortCut[cntLeds] = 0;
		cntblueLedShortCut[cntLeds] = 0;
	}
}
    7c18:	5401      	ret

00007c1a <_OpenCntInit>:

void OpenCntInit(void)
{
    7c1a:	7ada 12c8 	lod	Y, #4808
    7c1e:	6000      	lod	AL, #0
    7c20:	54ec      	mov	Cx, #12
    7c22:	42d6      	mov	[Y++], AL
    7c24:	1ffe      	djnz	Cx, 0x7c22 <_OpenCntInit+0x8>
    7c26:	7ada 12b0 	lod	Y, #4784
    7c2a:	54ec      	mov	Cx, #12
    7c2c:	42d6      	mov	[Y++], AL
    7c2e:	1ffe      	djnz	Cx, 0x7c2c <_OpenCntInit+0x12>
    7c30:	7ada 1298 	lod	Y, #4760
    7c34:	54ec      	mov	Cx, #12
    7c36:	42d6      	mov	[Y++], AL
    7c38:	1ffe      	djnz	Cx, 0x7c36 <_OpenCntInit+0x1c>

00007c3a <.LM12>:
	{
		cntredLedOpen[cntLeds] = 0;
		cntgreenLedOpen[cntLeds] = 0;
		cntblueLedOpen[cntLeds] = 0;
	}
}
    7c3a:	5401      	ret

00007c3c <_slaveStatusBufferUpdate>:

void slaveStatusBufferUpdate(void)
{
    7c3c:	5809      	inc	S, #10

00007c3e <.LCFI0>:
	uint16_t cntLeds = 0;
	uint8_t i = 0;

	txData[0] = 0x00;//status circuit ram rom nvrm
    7c3e:	6000      	lod	AL, #0
    7c40:	42d8 12d4 	mov	0x12d4 <_txData>, AL

00007c44 <.LM15>:
	txData[1] = 0x00;
    7c44:	42d8 12d5 	mov	0x12d5 <_txData+0x1>, AL

00007c48 <.LM16>:
	txData[2] = 0x00;
    7c48:	42d8 12d6 	mov	0x12d6 <_txData+0x2>, AL

00007c4c <.LM17>:
	txData[3] = 0x00;
    7c4c:	42d8 12d7 	mov	0x12d7 <_txData+0x3>, AL

00007c50 <.LM18>:
	txData[4] = 0x00;
    7c50:	42d8 12d8 	mov	0x12d8 <_txData+0x4>, AL

00007c54 <.LM19>:
	txData[5] = 0x00;
    7c54:	42d8 12d9 	mov	0x12d9 <_txData+0x5>, AL

00007c58 <.LM20>:
	txData[6] = 0x00;
    7c58:	42d8 12da 	mov	0x12da <_txData+0x6>, AL

00007c5c <.LM21>:

	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    7c5c:	7000      	lod	A, #0
    7c5e:	5209      	mov	[S-10], A

00007c60 <.L35>:
	{
		//No detection when the led is turned off
		if((getLedAdcSampleState(cntLeds, 1) == 0)&&(shortCutState == 0)&&(openState == 0))
    7c60:	54ca 0001 	pushw	#1

00007c64 <.LCFI1>:
    7c64:	720b      	lod	A, [S-12]
    7c66:	82db 34ec 	callf	0x69d8 <_getLedAdcSampleState>
    7c6a:	7a0b      	lod	Y, [S-12]
    7c6c:	e001      	add	Y, #1
    7c6e:	5a09      	mov	[S-10], Y
    7c70:	5c01      	dec	S, #2

00007c72 <.LCFI2>:
    7c72:	ac00      	cmp	A, #0
    7c74:	1d2e      	jne	0x7cd2 <.L14>

00007c76 <.LM23>:
    7c76:	62d8 128b 	lod	AL, 0x128b <_shortCutState>
    7c7a:	1d2b      	jne	0x7cd2 <.L14>

00007c7c <.LM24>:
    7c7c:	62d8 128a 	lod	AL, 0x128a <_openState>
    7c80:	1d28      	jne	0x7cd2 <.L14>

00007c82 <.LM25>:
		{
			txData[cntLeds + 1] = (LED_NORMAL<<0);
    7c82:	7a07      	lod	Y, [S-8]
    7c84:	e2da 12d4 	add	Y, #4820
    7c88:	42f0      	mov	[Y], AL

00007c8a <.L15>:
				txData[cntLeds + 1] = (LED_NORMAL<<0);
			}
		}

		//No detection when the led is turned off
		if((getLedAdcSampleState(cntLeds, 0) == 0)&&(shortCutState == 0)&&(openState == 0))
    7c8a:	54ca 0000 	pushw	#0

00007c8e <.LCFI3>:
    7c8e:	720b      	lod	A, [S-12]
    7c90:	82db 34ec 	callf	0x69d8 <_getLedAdcSampleState>
    7c94:	5c01      	dec	S, #2

00007c96 <.LCFI4>:
    7c96:	ac00      	cmp	A, #0
    7c98:	1d07      	jne	0x7ca8 <.L21>

00007c9a <.LM27>:
    7c9a:	62d8 128b 	lod	AL, 0x128b <_shortCutState>
    7c9e:	1d04      	jne	0x7ca8 <.L21>

00007ca0 <.LM28>:
    7ca0:	62d8 128a 	lod	AL, 0x128a <_openState>
    7ca4:	1d01      	jne	0x7ca8 <.L21>
    7ca6:	0061      	jmp	0x7d6a <.L22>

00007ca8 <.L21>:
			txData[cntLeds + 1] |= (LED_NORMAL<<2);
		}
		else
		{
			//green led voltage
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[0] > GREEN_OPEN_VOL)
    7ca8:	7207      	lod	A, [S-8]
    7caa:	487a 0006 	muls	Y, A, #6
    7cae:	e2da 14b2 	add	Y, #5298
    7cb2:	7af0      	lod	Y, [Y]
    7cb4:	4422      	asl	A
    7cb6:	eeda 1194 	cmp	Y, #4500
    7cba:	1f01      	jsg	0x7cbe <.L21+0x16>
    7cbc:	0079      	jmp	0x7db0 <.L23>
    7cbe:	7ae2      	lod	Y, A
    7cc0:	e2da 12ae 	add	Y, #4782

00007cc4 <.LM30>:
			{
				cntgreenLedOpen[cntLeds]++;
    7cc4:	72f0      	lod	A, [Y]
    7cc6:	a001      	add	A, #1

00007cc8 <.LM31>:
				if(cntgreenLedOpen[cntLeds] >= ERRORCNT)
    7cc8:	ac13      	cmp	A, #19
    7cca:	1a01      	jule	0x7cce <.L43>
    7ccc:	0043      	jmp	0x7d54 <.L24>

00007cce <.L43>:
					openState = 1;
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[0] < GREEN_SHORTCUT_VOL)
			{
				cntgreenLedShortCut[cntLeds]++;
    7cce:	52f0      	mov	[Y], A
    7cd0:	004c      	jmp	0x7d6a <.L22>

00007cd2 <.L14>:
			txData[cntLeds + 1] = (LED_NORMAL<<0);
		}
		else
		{
			//red led voltage
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[1] > RED_OPEN_VOL)
    7cd2:	7207      	lod	A, [S-8]
    7cd4:	487a 0006 	muls	Y, A, #6
    7cd8:	e2da 14b4 	add	Y, #5300
    7cdc:	7af0      	lod	Y, [Y]
    7cde:	4422      	asl	A
    7ce0:	eeda 1194 	cmp	Y, #4500
    7ce4:	1b13      	jsle	0x7d0c <.L16>
    7ce6:	7ae2      	lod	Y, A
    7ce8:	e2da 12c6 	add	Y, #4806

00007cec <.LM34>:
			{
				cntredLedOpen[cntLeds]++;
    7cec:	72f0      	lod	A, [Y]
    7cee:	a001      	add	A, #1

00007cf0 <.LM35>:
				if(cntredLedOpen[cntLeds] >= ERRORCNT)
    7cf0:	ac13      	cmp	A, #19
    7cf2:	1e02      	jug	0x7cf8 <.L17>

00007cf4 <.L42>:
					openState = 1;
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[1] < RED_SHORTCUT_VOL)
			{
				cntredLedShortCut[cntLeds]++;
    7cf4:	52f0      	mov	[Y], A
    7cf6:	07c9      	jmp	0x7c8a <.L15>

00007cf8 <.L17>:
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[1] > RED_OPEN_VOL)
			{
				cntredLedOpen[cntLeds]++;
				if(cntredLedOpen[cntLeds] >= ERRORCNT)
				{
					cntredLedOpen[cntLeds] = ERRORCNT;
    7cf8:	7014      	lod	A, #20
    7cfa:	52f0      	mov	[Y], A

00007cfc <.LM38>:
					txData[cntLeds + 1] = (LED_OPEN<<0);
    7cfc:	6001      	lod	AL, #1
    7cfe:	7a07      	lod	Y, [S-8]
    7d00:	e2da 12d4 	add	Y, #4820
    7d04:	42f0      	mov	[Y], AL

00007d06 <.LM39>:
					openState = 1;
    7d06:	42d8 128a 	mov	0x128a <_openState>, AL
    7d0a:	07bf      	jmp	0x7c8a <.L15>

00007d0c <.L16>:
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[1] < RED_SHORTCUT_VOL)
    7d0c:	eeda 018f 	cmp	Y, #399
    7d10:	1f12      	jsg	0x7d36 <.L18>
    7d12:	7ae2      	lod	Y, A
    7d14:	e2da 12ba 	add	Y, #4794

00007d18 <.LM41>:
			{
				cntredLedShortCut[cntLeds]++;
    7d18:	72f0      	lod	A, [Y]
    7d1a:	a001      	add	A, #1

00007d1c <.LM42>:
				if(cntredLedShortCut[cntLeds] >= ERRORCNT)
    7d1c:	ac13      	cmp	A, #19
    7d1e:	1a6a      	jule	0x7cf4 <.L42>

00007d20 <.LM43>:
				{
					cntredLedShortCut[cntLeds] = ERRORCNT;
    7d20:	7014      	lod	A, #20
    7d22:	52f0      	mov	[Y], A

00007d24 <.LM44>:
					txData[cntLeds + 1] = (LED_SHORTCUT<<0);
    7d24:	6002      	lod	AL, #2
    7d26:	7a07      	lod	Y, [S-8]
    7d28:	e2da 12d4 	add	Y, #4820
    7d2c:	42f0      	mov	[Y], AL

00007d2e <.LM45>:
					shortCutState = 1;
    7d2e:	6001      	lod	AL, #1
    7d30:	42d8 128b 	mov	0x128b <_shortCutState>, AL
    7d34:	07aa      	jmp	0x7c8a <.L15>

00007d36 <.L18>:
				}
			}
			else
			{
				cntredLedOpen[cntLeds] = 0;
    7d36:	a0fe      	add	A, #-2
    7d38:	7ee2      	lod	X, A
    7d3a:	22da 12c8 	add	X, #4808
    7d3e:	7800      	lod	Y, #0
    7d40:	5af8      	mov	[X], Y

00007d42 <.LM47>:
				cntredLedShortCut[cntLeds] = 0;
    7d42:	a2da 12bc 	add	A, #4796
    7d46:	7ee2      	lod	X, A
    7d48:	5af8      	mov	[X], Y

00007d4a <.LM48>:
				txData[cntLeds + 1] = (LED_NORMAL<<0);
    7d4a:	7e07      	lod	X, [S-8]
    7d4c:	22da 12d4 	add	X, #4820
    7d50:	46f8      	mov	[X], YL
    7d52:	079b      	jmp	0x7c8a <.L15>

00007d54 <.L24>:
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[0] > GREEN_OPEN_VOL)
			{
				cntgreenLedOpen[cntLeds]++;
				if(cntgreenLedOpen[cntLeds] >= ERRORCNT)
				{
					cntgreenLedOpen[cntLeds] = ERRORCNT;
    7d54:	7014      	lod	A, #20
    7d56:	52f0      	mov	[Y], A
    7d58:	7a07      	lod	Y, [S-8]
    7d5a:	e2da 12d4 	add	Y, #4820

00007d5e <.LM50>:
					txData[cntLeds + 1] |= (LED_OPEN<<2);
    7d5e:	62f0      	lod	AL, [Y]
    7d60:	8404      	or	AL, #4
    7d62:	42f0      	mov	[Y], AL

00007d64 <.LM51>:
					openState = 1;
    7d64:	6001      	lod	AL, #1
    7d66:	42d8 128a 	mov	0x128a <_openState>, AL

00007d6a <.L22>:
				txData[cntLeds + 1] |= (LED_NORMAL<<2);
			}
		}

		//No detection when the led is turned off
		if((getLedAdcSampleState(cntLeds, 2) == 0)&&(shortCutState == 0)&&(openState == 0))
    7d6a:	54ca 0002 	pushw	#2

00007d6e <.LCFI5>:
    7d6e:	720b      	lod	A, [S-12]
    7d70:	82db 34ec 	callf	0x69d8 <_getLedAdcSampleState>
    7d74:	5c01      	dec	S, #2

00007d76 <.LCFI6>:
    7d76:	ac00      	cmp	A, #0
    7d78:	1d07      	jne	0x7d88 <.L28>

00007d7a <.LM53>:
    7d7a:	62d8 128b 	lod	AL, 0x128b <_shortCutState>
    7d7e:	1d04      	jne	0x7d88 <.L28>

00007d80 <.LM54>:
    7d80:	62d8 128a 	lod	AL, 0x128a <_openState>
    7d84:	1d01      	jne	0x7d88 <.L28>
    7d86:	0041      	jmp	0x7e0a <.L29>

00007d88 <.L28>:
			txData[cntLeds + 1] |= (LED_NORMAL<<4);
		}
		else
		{
			//blue led voltage
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[2] > BLUE_OPEN_VOL)
    7d88:	7207      	lod	A, [S-8]
    7d8a:	487a 0006 	muls	Y, A, #6
    7d8e:	e2da 14b6 	add	Y, #5302
    7d92:	7af0      	lod	Y, [Y]
    7d94:	4422      	asl	A
    7d96:	eeda 1194 	cmp	Y, #4500
    7d9a:	1f01      	jsg	0x7d9e <.L28+0x16>
    7d9c:	0078      	jmp	0x7e8e <.L30>
    7d9e:	7ae2      	lod	Y, A
    7da0:	e2da 1296 	add	Y, #4758

00007da4 <.LM56>:
			{
				cntblueLedOpen[cntLeds]++;
    7da4:	72f0      	lod	A, [Y]
    7da6:	a001      	add	A, #1

00007da8 <.LM57>:
				if(cntblueLedOpen[cntLeds] >= ERRORCNT)
    7da8:	ac13      	cmp	A, #19
    7daa:	1e24      	jug	0x7df4 <.L31>

00007dac <.L44>:
					openState = 1;
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[2] < BLUE_SHORTCUT_VOL)
			{
				cntblueLedShortCut[cntLeds]++;
    7dac:	52f0      	mov	[Y], A
    7dae:	002d      	jmp	0x7e0a <.L29>

00007db0 <.L23>:
					cntgreenLedOpen[cntLeds] = ERRORCNT;
					txData[cntLeds + 1] |= (LED_OPEN<<2);
					openState = 1;
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[0] < GREEN_SHORTCUT_VOL)
    7db0:	eeda 018f 	cmp	Y, #399
    7db4:	1f14      	jsg	0x7dde <.L26>
    7db6:	7ae2      	lod	Y, A
    7db8:	e2da 12a2 	add	Y, #4770

00007dbc <.LM60>:
			{
				cntgreenLedShortCut[cntLeds]++;
    7dbc:	72f0      	lod	A, [Y]
    7dbe:	a001      	add	A, #1

00007dc0 <.LM61>:
				if(cntgreenLedShortCut[cntLeds] >= ERRORCNT)
    7dc0:	ac13      	cmp	A, #19
    7dc2:	1e01      	jug	0x7dc6 <.LM62>
    7dc4:	0784      	jmp	0x7cce <.L43>

00007dc6 <.LM62>:
				{
					cntgreenLedShortCut[cntLeds] = ERRORCNT;
    7dc6:	7014      	lod	A, #20
    7dc8:	52f0      	mov	[Y], A
    7dca:	7a07      	lod	Y, [S-8]
    7dcc:	e2da 12d4 	add	Y, #4820

00007dd0 <.LM63>:
					txData[cntLeds + 1] |= (LED_SHORTCUT<<2);
    7dd0:	62f0      	lod	AL, [Y]
    7dd2:	8408      	or	AL, #8
    7dd4:	42f0      	mov	[Y], AL

00007dd6 <.LM64>:
					shortCutState = 1;
    7dd6:	6001      	lod	AL, #1
    7dd8:	42d8 128b 	mov	0x128b <_shortCutState>, AL
    7ddc:	07c6      	jmp	0x7d6a <.L22>

00007dde <.L26>:
				}
			}
			else
			{
				cntgreenLedOpen[cntLeds] = 0;
    7dde:	a0fe      	add	A, #-2
    7de0:	7ee2      	lod	X, A
    7de2:	22da 12b0 	add	X, #4784
    7de6:	7800      	lod	Y, #0
    7de8:	5af8      	mov	[X], Y

00007dea <.LM66>:
				cntgreenLedShortCut[cntLeds] = 0;
    7dea:	a2da 12a4 	add	A, #4772
    7dee:	7ee2      	lod	X, A
    7df0:	5af8      	mov	[X], Y
    7df2:	07bb      	jmp	0x7d6a <.L22>

00007df4 <.L31>:
			if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[2] > BLUE_OPEN_VOL)
			{
				cntblueLedOpen[cntLeds]++;
				if(cntblueLedOpen[cntLeds] >= ERRORCNT)
				{
					cntblueLedOpen[cntLeds] = ERRORCNT;
    7df4:	7014      	lod	A, #20
    7df6:	52f0      	mov	[Y], A
    7df8:	7a07      	lod	Y, [S-8]
    7dfa:	e2da 12d4 	add	Y, #4820

00007dfe <.LM68>:
					txData[cntLeds + 1] |= (LED_OPEN<<4);
    7dfe:	62f0      	lod	AL, [Y]
    7e00:	8410      	or	AL, #16
    7e02:	42f0      	mov	[Y], AL

00007e04 <.LM69>:
					openState = 1;
    7e04:	6001      	lod	AL, #1
    7e06:	42d8 128a 	mov	0x128a <_openState>, AL

00007e0a <.L29>:
    7e0a:	7207      	lod	A, [S-8]
    7e0c:	5209      	mov	[S-10], A

00007e0e <.LM70>:
	txData[3] = 0x00;
	txData[4] = 0x00;
	txData[5] = 0x00;
	txData[6] = 0x00;

	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    7e0e:	ac06      	cmp	A, #6
    7e10:	1901      	je	0x7e14 <.LM71>
    7e12:	0726      	jmp	0x7c60 <.L35>

00007e14 <.LM71>:
				txData[cntLeds + 1] |= (LED_NORMAL<<4);
			}
		}
	}

	txData[7] = moduleTempratureGetMcu() + 80;//adding 80 is to avoid negative numbers
    7e14:	15a4      	call	0x795e <_moduleTempratureGetMcu>
    7e16:	8050      	add	AL, #80
    7e18:	42d8 12db 	mov	0x12db <_txData+0x7>, AL

00007e1c <.LM72>:
	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    7e1c:	7c00      	lod	X, #0

00007e1e <.L36>:
	{
		txData[8 + cntLeds] = moduleTempratureGetLed(cntLeds)/DTEMP_MULTIPLIED_RATIO + 80;//adding 80 is to avoid negative numbers
    7e1e:	72ee      	lod	A, X
    7e20:	5e05      	mov	[S-6], X
    7e22:	15a0      	call	0x7964 <_moduleTempratureGetLed>

00007e24 <.LVL14>:
    7e24:	7e05      	lod	X, [S-6]
    7e26:	7aee      	lod	Y, X
    7e28:	e2da 12dc 	add	Y, #4828
    7e2c:	5a07      	mov	[S-8], Y
    7e2e:	4cf8      	movs	YA, A
    7e30:	4c72 000a 	divs	YA, #10
    7e34:	4c72 000a 	divs	YA, #10
    7e38:	4c7a 000a 	dadjs	YA, #10
    7e3c:	8050      	add	AL, #80
    7e3e:	7a07      	lod	Y, [S-8]
    7e40:	42f0      	mov	[Y], AL

00007e42 <.LM74>:
			}
		}
	}

	txData[7] = moduleTempratureGetMcu() + 80;//adding 80 is to avoid negative numbers
	for(cntLeds = 0; cntLeds < RGBLEDMAX; cntLeds++)
    7e42:	2001      	add	X, #1

00007e44 <.LVL15>:
    7e44:	2c06      	cmp	X, #6
    7e46:	1d6b      	jne	0x7e1e <.L36>

00007e48 <.LM75>:
	{
		txData[8 + cntLeds] = moduleTempratureGetLed(cntLeds)/DTEMP_MULTIPLIED_RATIO + 80;//adding 80 is to avoid negative numbers
	}

	if(Get_Transmit_Lock() == 0)//if the transmit state is free
    7e48:	82db 372c 	callf	0x6e58 <_Get_Transmit_Lock>

00007e4c <.LVL16>:
    7e4c:	ac00      	cmp	A, #0
    7e4e:	1d1e      	jne	0x7e8c <.L13>

00007e50 <.LM76>:
	{
		systemStatus[0] = 0x0200;
    7e50:	7ada 0200 	lod	Y, #512
    7e54:	5ad8 12f2 	mov	0x12f2 <_systemStatus>, Y
    7e58:	5201      	mov	[S-2], A
    7e5a:	7c0e      	lod	X, #14

00007e5c <.L38>:
    7e5c:	7a01      	lod	Y, [S-2]
    7e5e:	e2da 12d4 	add	Y, #4820
    7e62:	5a03      	mov	[S-4], Y

00007e64 <.LM77>:
		for(i = 1; i < 15; i++)//The data transmission of the chip is in unit of word
		{
			systemStatus[i] = (txData[(i-1)*2]<<8) + txData[(i-1)*2 + 1];
    7e64:	7a01      	lod	Y, [S-2]
    7e66:	e2da 12f2 	add	Y, #4850
    7e6a:	5a09      	mov	[S-10], Y
    7e6c:	7a03      	lod	Y, [S-4]
    7e6e:	62f0      	lod	AL, [Y]
    7e70:	6800      	lod	AH, #0
    7e72:	72e4      	swap	A
    7e74:	5207      	mov	[S-8], A
    7e76:	62f1      	lod	AL, [Y+1]
    7e78:	66e0      	lod	YL, AL
    7e7a:	5cf6      	usex	Y
    7e7c:	7207      	lod	A, [S-8]
    7e7e:	a2e6      	add	A, Y
    7e80:	7a09      	lod	Y, [S-10]
    7e82:	52f2      	mov	[Y+2], A
    7e84:	7201      	lod	A, [S-2]
    7e86:	a002      	add	A, #2
    7e88:	5201      	mov	[S-2], A

00007e8a <.LM78>:
	}

	if(Get_Transmit_Lock() == 0)//if the transmit state is free
	{
		systemStatus[0] = 0x0200;
		for(i = 1; i < 15; i++)//The data transmission of the chip is in unit of word
    7e8a:	1be8      	djnz	X, 0x7e5c <.L38>

00007e8c <.L13>:
		{
			systemStatus[i] = (txData[(i-1)*2]<<8) + txData[(i-1)*2 + 1];
		}
	}
}
    7e8c:	540b      	ret	#12

00007e8e <.L30>:
					cntblueLedOpen[cntLeds] = ERRORCNT;
					txData[cntLeds + 1] |= (LED_OPEN<<4);
					openState = 1;
				}
			}
			else if(currentLedVoltage.LedVoltage[cntLeds].ledChannelData[2] < BLUE_SHORTCUT_VOL)
    7e8e:	eeda 018f 	cmp	Y, #399
    7e92:	1f14      	jsg	0x7ebc <.L33>
    7e94:	7ae2      	lod	Y, A
    7e96:	e2da 128a 	add	Y, #4746

00007e9a <.LM81>:
			{
				cntblueLedShortCut[cntLeds]++;
    7e9a:	72f0      	lod	A, [Y]
    7e9c:	a001      	add	A, #1

00007e9e <.LM82>:
				if(cntblueLedShortCut[cntLeds] >= ERRORCNT)
    7e9e:	ac13      	cmp	A, #19
    7ea0:	1e01      	jug	0x7ea4 <.LM83>
    7ea2:	0784      	jmp	0x7dac <.L44>

00007ea4 <.LM83>:
				{
					cntblueLedShortCut[cntLeds] = ERRORCNT;
    7ea4:	7014      	lod	A, #20
    7ea6:	52f0      	mov	[Y], A
    7ea8:	7a07      	lod	Y, [S-8]
    7eaa:	e2da 12d4 	add	Y, #4820

00007eae <.LM84>:
					txData[cntLeds + 1] |= (LED_SHORTCUT<<4);
    7eae:	62f0      	lod	AL, [Y]
    7eb0:	8420      	or	AL, #32
    7eb2:	42f0      	mov	[Y], AL

00007eb4 <.LM85>:
					shortCutState = 1;
    7eb4:	6001      	lod	AL, #1
    7eb6:	42d8 128b 	mov	0x128b <_shortCutState>, AL
    7eba:	07a7      	jmp	0x7e0a <.L29>

00007ebc <.L33>:
				}
			}
			else
			{
				cntblueLedOpen[cntLeds] = 0;
    7ebc:	a0fe      	add	A, #-2
    7ebe:	7ee2      	lod	X, A
    7ec0:	22da 1298 	add	X, #4760
    7ec4:	7800      	lod	Y, #0
    7ec6:	5af8      	mov	[X], Y

00007ec8 <.LM87>:
				cntblueLedShortCut[cntLeds] = 0;
    7ec8:	a2da 128c 	add	A, #4748
    7ecc:	7ee2      	lod	X, A
    7ece:	5af8      	mov	[X], Y
    7ed0:	079c      	jmp	0x7e0a <.L29>

00007ed2 <_systemProtocolControl>:
		}
	}
}

void systemProtocolControl(SCommMessage *Message, SColorParams *params)
{
    7ed2:	583f      	inc	S, #64

00007ed4 <.LCFI7>:
    7ed4:	7ee2      	lod	X, A

00007ed6 <.LM89>:
//	modulePwmLedSpecialMask(0);

#if 1
	uint16_t ledIndex;

	switch (Message->func)
    7ed6:	72f8      	lod	A, [X]

00007ed8 <.LVL21>:
    7ed8:	a0ff      	add	A, #-1
    7eda:	ac04      	cmp	A, #4
    7edc:	1a01      	jule	0x7ee0 <.LVL21+0x8>
    7ede:	0281      	jmp	0x83e2 <.L45>
    7ee0:	4422      	asl	A
    7ee2:	7ae2      	lod	Y, A
    7ee4:	e2da 5b62 	add	Y, #23394
    7ee8:	76f0      	jmp	[Y]

00007eea <.L47>:
    	{
#if 1
    		SLedColorData_t tempData;
    		uint16_t step = 0;

    		if (Message->msgLength > 6)
    7eea:	72fc      	lod	A, [X+4]
    7eec:	ac06      	cmp	A, #6
    7eee:	1e01      	jug	0x7ef2 <.LM91>
    7ef0:	0073      	jmp	0x7fd8 <.L64>

00007ef2 <.LM91>:
    			step = 4;
    7ef2:	7004      	lod	A, #4
    7ef4:	5219      	mov	[S-26], A

00007ef6 <.L53>:
    7ef6:	7afe      	lod	Y, [X+6]
    7ef8:	7e43      	lod	X, [S-68]

00007efa <.LVL24>:
    7efa:	200c      	add	X, #12
    7efc:	5e0f      	mov	[S-16], X
    7efe:	7c06      	lod	X, #6
    7f00:	5e15      	mov	[S-22], X

00007f02 <.L54>:
    			step = 0;

    		for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    		{
    			uint8_t* dataPtr = Message->data;
    			tempData.rawData[0] = *(dataPtr+1+step*ledIndex);
    7f02:	62f1      	lod	AL, [Y+1]
    7f04:	5cf2      	usex	A
    7f06:	521d      	mov	[S-30], A
    7f08:	62f1      	lod	AL, [Y+1]
    7f0a:	423f      	mov	[S-64], AL

00007f0c <.LM93>:
    			tempData.rawData[1] = *(dataPtr+0+step*ledIndex);
    7f0c:	62f0      	lod	AL, [Y]
    7f0e:	5cf2      	usex	A
    7f10:	5217      	mov	[S-24], A
    7f12:	62f0      	lod	AL, [Y]
    7f14:	423e      	mov	[S-63], AL

00007f16 <.LM94>:
    			tempData.rawData[2] = *(dataPtr+3+step*ledIndex);
    7f16:	62f3      	lod	AL, [Y+3]
    7f18:	5cf2      	usex	A
    7f1a:	521f      	mov	[S-32], A
    7f1c:	62f3      	lod	AL, [Y+3]
    7f1e:	423d      	mov	[S-62], AL

00007f20 <.LM95>:
    			tempData.rawData[3] = *(dataPtr+2+step*ledIndex);
    7f20:	62f2      	lod	AL, [Y+2]
    7f22:	5cf2      	usex	A
    7f24:	5213      	mov	[S-20], A
    7f26:	62f2      	lod	AL, [Y+2]
    7f28:	423c      	mov	[S-61], AL

00007f2a <.LM96>:

    			params->colorU[RGBLEDMAX - ledIndex - 1] = tempData.color.u;
    7f2a:	723d      	lod	A, [S-62]
    7f2c:	44b2      	lsr	A, #2
    7f2e:	44b2      	lsr	A, #2
    7f30:	44b2      	lsr	A, #2
    7f32:	b6da 03ff 	and	A, #1023
    7f36:	7e0f      	lod	X, [S-16]
    7f38:	52ce      	mov	[--X], A
    7f3a:	5e0f      	mov	[S-16], X

00007f3c <.LM97>:
    			params->colorV[RGBLEDMAX - ledIndex - 1] = tempData.color.v;
    7f3c:	200c      	add	X, #12
    7f3e:	5e21      	mov	[S-34], X
    7f40:	723f      	lod	A, [S-64]
    7f42:	44c2      	rl	A, #2
    7f44:	44c2      	rl	A, #2
    7f46:	b40f      	and	A, #15
    7f48:	7e3d      	lod	X, [S-62]
    7f4a:	343f      	and	X, #63
    7f4c:	44ae      	asl	X, #2
    7f4e:	44ae      	asl	X, #2
    7f50:	a6ee      	or	A, X
    7f52:	7e21      	lod	X, [S-34]
    7f54:	52f8      	mov	[X], A

00007f56 <.LM98>:
    			params->intensity[RGBLEDMAX - ledIndex - 1] = tempData.color.L;
    7f56:	7e0f      	lod	X, [S-16]
    7f58:	2018      	add	X, #24
    7f5a:	723f      	lod	A, [S-64]
    7f5c:	b6da 0fff 	and	A, #4095
    7f60:	52f8      	mov	[X], A
    7f62:	e219      	add	Y, [S-26]

00007f64 <.LBE3>:
    		if (Message->msgLength > 6)
    			step = 4;
    		else
    			step = 0;

    		for (ledIndex = 0; ledIndex < RGBLEDMAX; ledIndex++)
    7f64:	7215      	lod	A, [S-22]
    7f66:	a0ff      	add	A, #-1
    7f68:	5215      	mov	[S-22], A
    7f6a:	1d4b      	jne	0x7f02 <.L54>

00007f6c <.LM100>:
    			params->colorU[RGBLEDMAX - ledIndex - 1] = tempData.color.u;
    			params->colorV[RGBLEDMAX - ledIndex - 1] = tempData.color.v;
    			params->intensity[RGBLEDMAX - ledIndex - 1] = tempData.color.L;
    		}

    		if((tempData.rawData[0] == 0)
    7f6c:	7a1d      	lod	Y, [S-30]
    7f6e:	1d30      	jne	0x7fd0 <.L56>

00007f70 <.LM101>:
    				&&(tempData.rawData[1] == 0)
    7f70:	7217      	lod	A, [S-24]
    7f72:	1d2e      	jne	0x7fd0 <.L56>

00007f74 <.LM102>:
					&&(tempData.rawData[2] == 0)
    7f74:	7a1f      	lod	Y, [S-32]
    7f76:	1d2c      	jne	0x7fd0 <.L56>

00007f78 <.LM103>:
					&&(tempData.rawData[3] == 0))
    7f78:	7a13      	lod	Y, [S-20]
    7f7a:	1d2a      	jne	0x7fd0 <.L56>

00007f7c <.LM104>:
    		{
    			if(shortCutState == 1)
    7f7c:	62d8 128b 	lod	AL, 0x128b <_shortCutState>
    7f80:	8c01      	cmp	AL, #1
    7f82:	1d10      	jne	0x7fa4 <.L58>

00007f84 <.LM105>:
				{
					systemStatus[0] = 0x0000;
    7f84:	5ad8 12f2 	mov	0x12f2 <_systemStatus>, Y

00007f88 <.LM106>:
					systemStatus[1] = 0x0000;
    7f88:	5ad8 12f4 	mov	0x12f4 <_systemStatus+0x2>, Y

00007f8c <.LM107>:
					systemStatus[2] = 0x0000;
    7f8c:	5ad8 12f6 	mov	0x12f6 <_systemStatus+0x4>, Y

00007f90 <.LM108>:
					systemStatus[3] &= 0xFF00;
    7f90:	72d8 12f8 	lod	A, 0x12f8 <_systemStatus+0x6>
    7f94:	b6da ff00 	and	A, #65280
    7f98:	52d8 12f8 	mov	0x12f8 <_systemStatus+0x6>, A

00007f9c <.LM109>:
					ShortCutCntInit();
    7f9c:	162d      	call	0x7bf8 <_ShortCutCntInit>

00007f9e <.LM110>:
					shortCutState = 0;
    7f9e:	6613      	lod	YL, [S-20]
    7fa0:	46d8 128b 	mov	0x128b <_shortCutState>, YL

00007fa4 <.L58>:
				}
				if(openState == 1)
    7fa4:	62d8 128a 	lod	AL, 0x128a <_openState>
    7fa8:	8c01      	cmp	AL, #1
    7faa:	1d12      	jne	0x7fd0 <.L56>

00007fac <.LM112>:
				{
					systemStatus[0] = 0x0000;
    7fac:	7000      	lod	A, #0
    7fae:	52d8 12f2 	mov	0x12f2 <_systemStatus>, A

00007fb2 <.LM113>:
					systemStatus[1] = 0x0000;
    7fb2:	52d8 12f4 	mov	0x12f4 <_systemStatus+0x2>, A

00007fb6 <.LM114>:
					systemStatus[2] = 0x0000;
    7fb6:	52d8 12f6 	mov	0x12f6 <_systemStatus+0x4>, A

00007fba <.LM115>:
					systemStatus[3] &= 0xFF00;
    7fba:	7ad8 12f8 	lod	Y, 0x12f8 <_systemStatus+0x6>
    7fbe:	f6da ff00 	and	Y, #65280
    7fc2:	5ad8 12f8 	mov	0x12f8 <_systemStatus+0x6>, Y

00007fc6 <.LM116>:
					OpenCntInit();
    7fc6:	520b      	mov	[S-12], A
    7fc8:	1628      	call	0x7c1a <_OpenCntInit>

00007fca <.LM117>:
					openState = 0;
    7fca:	720b      	lod	A, [S-12]
    7fcc:	42d8 128a 	mov	0x128a <_openState>, AL

00007fd0 <.L56>:
    		else
    		{

    		}

    		modulePwmLedSpecialMask(0);
    7fd0:	7000      	lod	A, #0

00007fd2 <.L72>:
#endif
    	}
    	break;
		case ECommFunctionCalLed:
		{
			modulePwmLedSpecialMask(Message->data[0]);
    7fd2:	82db 39ae 	callf	0x735c <_modulePwmLedSpecialMask>

00007fd6 <.LM120>:
		}
		break;
    7fd6:	5441      	ret	#66

00007fd8 <.L64>:
    		uint16_t step = 0;

    		if (Message->msgLength > 6)
    			step = 4;
    		else
    			step = 0;
    7fd8:	7800      	lod	Y, #0
    7fda:	5a19      	mov	[S-26], Y
    7fdc:	078c      	jmp	0x7ef6 <.L53>

00007fde <.L49>:
#endif
    	}
    	break;
		case ECommFunctionCalLed:
		{
			modulePwmLedSpecialMask(Message->data[0]);
    7fde:	7afe      	lod	Y, [X+6]
    7fe0:	62f0      	lod	AL, [Y]
    7fe2:	5cf2      	usex	A
    7fe4:	07f6      	jmp	0x7fd2 <.L72>

00007fe6 <.L50>:
		break;
		case ECommFunctionCalData:
		{
			uint8_t ledChannel;
			uint8_t ledCalMask, index;
			uint8_t* dataPtr = &Message->data[2];
    7fe6:	7efe      	lod	X, [X+6]

00007fe8 <.LVL32>:
    7fe8:	5e0f      	mov	[S-16], X

00007fea <.LM124>:
			ledCalMask = Message->data[0];
    7fea:	62f8      	lod	AL, [X]
    7fec:	5cf2      	usex	A
    7fee:	521d      	mov	[S-30], A

00007ff0 <.LVL34>:
    7ff0:	7000      	lod	A, #0
    7ff2:	5215      	mov	[S-22], A
    7ff4:	7c06      	lod	X, #6

00007ff6 <.LVL35>:
    7ff6:	5e1b      	mov	[S-28], X

00007ff8 <.L60>:
			for (index = 0; index < 6; index++)
			{
				if (ledCalMask & (0x1<<index))
    7ff8:	721d      	lod	A, [S-30]
    7ffa:	7a15      	lod	Y, [S-22]
    7ffc:	ec00      	cmp	Y, #0
    7ffe:	1b03      	jsle	0x8006 <.L74>
    8000:	46e9      	mov	Cx, YL
    8002:	4472      	asr	A
    8004:	1ffe      	djnz	Cx, 0x8002 <.L60+0xa>

00008006 <.L74>:
    8006:	9401      	and	AL, #1
    8008:	1d01      	jne	0x800c <.L74+0x6>
    800a:	00f7      	jmp	0x81fa <.L59>
    800c:	72e6      	lod	A, Y
    800e:	487a fffe 	muls	Y, A, #65534
    8012:	e2da 1364 	add	Y, #4964
    8016:	5a13      	mov	[S-20], Y

00008018 <.LM126>:
				{
					savedConfig.redx[5-index] = dataPtr[1] | (dataPtr[0]<<8);
    8018:	e00c      	add	Y, #12
    801a:	5a17      	mov	[S-24], Y
    801c:	7a0f      	lod	Y, [S-16]
    801e:	62f2      	lod	AL, [Y+2]
    8020:	66e0      	lod	YL, AL
    8022:	5cf6      	usex	Y
    8024:	7e0f      	lod	X, [S-16]
    8026:	62fb      	lod	AL, [X+3]
    8028:	6800      	lod	AH, #0
    802a:	72e4      	swap	A
    802c:	a6e6      	or	A, Y
    802e:	72e4      	swap	A
    8030:	7a17      	lod	Y, [S-24]
    8032:	52f0      	mov	[Y], A

00008034 <.LM127>:
					savedConfig.redy[5-index] = dataPtr[3] | (dataPtr[2]<<8);
    8034:	7e13      	lod	X, [S-20]
    8036:	2018      	add	X, #24
    8038:	5e17      	mov	[S-24], X
    803a:	7a0f      	lod	Y, [S-16]
    803c:	62f4      	lod	AL, [Y+4]
    803e:	66e0      	lod	YL, AL
    8040:	5cf6      	usex	Y
    8042:	7e0f      	lod	X, [S-16]
    8044:	62fd      	lod	AL, [X+5]
    8046:	6800      	lod	AH, #0
    8048:	72e4      	swap	A
    804a:	a6e6      	or	A, Y
    804c:	72e4      	swap	A
    804e:	7a17      	lod	Y, [S-24]
    8050:	52f0      	mov	[Y], A
    8052:	7215      	lod	A, [S-22]
    8054:	487a fffc 	muls	Y, A, #65532
    8058:	e2da 1364 	add	Y, #4964
    805c:	5a19      	mov	[S-26], Y

0000805e <.LM128>:
					savedConfig.redY[5-index] = (uint32_t)dataPtr[5] | ((uint32_t)dataPtr[4]<<8) | ((uint32_t)dataPtr[7]<<16) | ((uint32_t)dataPtr[6]<<24);
    805e:	7ee6      	lod	X, Y
    8060:	202e      	add	X, #46
    8062:	7a0f      	lod	Y, [S-16]
    8064:	62f6      	lod	AL, [Y+6]
    8066:	5cf2      	usex	A
    8068:	4cc8      	movu	D, A
    806a:	48c7      	asl	D, #8
    806c:	e009      	add	Y, #9
    806e:	62f0      	lod	AL, [Y]
    8070:	5cf2      	usex	A
    8072:	4cf2      	usex	YA
    8074:	48ef      	asl	YA, #16
    8076:	58a2      	mov	[S-8], YA
    8078:	4c80      	mov	YA, D
    807a:	a607      	or	A, [S-8]
    807c:	e605      	or	Y, [S-6]
    807e:	4cc0      	mov	D, YA
    8080:	7a0f      	lod	Y, [S-16]
    8082:	62f7      	lod	AL, [Y+7]
    8084:	5cf2      	usex	A
    8086:	4cf2      	usex	YA
    8088:	58a2      	mov	[S-8], YA
    808a:	4c80      	mov	YA, D
    808c:	a607      	or	A, [S-8]
    808e:	e605      	or	Y, [S-6]
    8090:	4cc0      	mov	D, YA
    8092:	7a0f      	lod	Y, [S-16]
    8094:	e008      	add	Y, #8
    8096:	62f0      	lod	AL, [Y]
    8098:	5cf2      	usex	A
    809a:	4cf2      	usex	YA
    809c:	48ef      	asl	YA, #16
    809e:	48e7      	asl	YA, #8
    80a0:	58a2      	mov	[S-8], YA
    80a2:	4c80      	mov	YA, D
    80a4:	a607      	or	A, [S-8]
    80a6:	e605      	or	Y, [S-6]
    80a8:	4ca7      	mov	[X], YA

000080aa <.LM129>:
					savedConfig.greenx[5-index] = dataPtr[9] | (dataPtr[8]<<8);
    80aa:	7a13      	lod	Y, [S-20]
    80ac:	e03c      	add	Y, #60
    80ae:	5a17      	mov	[S-24], Y
    80b0:	7e0f      	lod	X, [S-16]
    80b2:	200a      	add	X, #10
    80b4:	62f8      	lod	AL, [X]
    80b6:	66e0      	lod	YL, AL
    80b8:	5cf6      	usex	Y
    80ba:	62f9      	lod	AL, [X+1]
    80bc:	6800      	lod	AH, #0
    80be:	72e4      	swap	A
    80c0:	a6e6      	or	A, Y
    80c2:	72e4      	swap	A
    80c4:	7e17      	lod	X, [S-24]
    80c6:	52f8      	mov	[X], A

000080c8 <.LM130>:
					savedConfig.greeny[5-index] = dataPtr[11] | (dataPtr[10]<<8);
    80c8:	7a13      	lod	Y, [S-20]
    80ca:	e048      	add	Y, #72
    80cc:	5a17      	mov	[S-24], Y
    80ce:	7e0f      	lod	X, [S-16]
    80d0:	200c      	add	X, #12
    80d2:	62f8      	lod	AL, [X]
    80d4:	66e0      	lod	YL, AL
    80d6:	5cf6      	usex	Y
    80d8:	62f9      	lod	AL, [X+1]
    80da:	6800      	lod	AH, #0
    80dc:	72e4      	swap	A
    80de:	a6e6      	or	A, Y
    80e0:	72e4      	swap	A
    80e2:	7e17      	lod	X, [S-24]
    80e4:	52f8      	mov	[X], A

000080e6 <.LM131>:
					savedConfig.greenY[5-index] = (uint32_t)dataPtr[13] | ((uint32_t)dataPtr[12]<<8) | ((uint32_t)dataPtr[15]<<16) | ((uint32_t)dataPtr[14]<<24);
    80e6:	7e19      	lod	X, [S-26]
    80e8:	205e      	add	X, #94
    80ea:	7a0f      	lod	Y, [S-16]
    80ec:	e00e      	add	Y, #14
    80ee:	62f0      	lod	AL, [Y]
    80f0:	5cf2      	usex	A
    80f2:	4cc8      	movu	D, A
    80f4:	48c7      	asl	D, #8
    80f6:	7a0f      	lod	Y, [S-16]
    80f8:	e011      	add	Y, #17
    80fa:	62f0      	lod	AL, [Y]
    80fc:	5cf2      	usex	A
    80fe:	4cf2      	usex	YA
    8100:	48ef      	asl	YA, #16
    8102:	58a2      	mov	[S-8], YA
    8104:	4c80      	mov	YA, D
    8106:	a607      	or	A, [S-8]
    8108:	e605      	or	Y, [S-6]
    810a:	4cc0      	mov	D, YA
    810c:	7a0f      	lod	Y, [S-16]
    810e:	e00f      	add	Y, #15
    8110:	62f0      	lod	AL, [Y]
    8112:	5cf2      	usex	A
    8114:	4cf2      	usex	YA
    8116:	58a2      	mov	[S-8], YA
    8118:	4c80      	mov	YA, D
    811a:	a607      	or	A, [S-8]
    811c:	e605      	or	Y, [S-6]
    811e:	4cc0      	mov	D, YA
    8120:	7a0f      	lod	Y, [S-16]
    8122:	e010      	add	Y, #16
    8124:	62f0      	lod	AL, [Y]
    8126:	5cf2      	usex	A
    8128:	4cf2      	usex	YA
    812a:	48ef      	asl	YA, #16
    812c:	48e7      	asl	YA, #8
    812e:	58a2      	mov	[S-8], YA
    8130:	4c80      	mov	YA, D
    8132:	a607      	or	A, [S-8]
    8134:	e605      	or	Y, [S-6]
    8136:	4ca7      	mov	[X], YA

00008138 <.LM132>:
					savedConfig.bluex[5-index] = dataPtr[17] | (dataPtr[16]<<8);
    8138:	7a13      	lod	Y, [S-20]
    813a:	e06c      	add	Y, #108
    813c:	5a17      	mov	[S-24], Y
    813e:	7e0f      	lod	X, [S-16]
    8140:	2012      	add	X, #18
    8142:	62f8      	lod	AL, [X]
    8144:	66e0      	lod	YL, AL
    8146:	5cf6      	usex	Y
    8148:	62f9      	lod	AL, [X+1]
    814a:	6800      	lod	AH, #0
    814c:	72e4      	swap	A
    814e:	a6e6      	or	A, Y
    8150:	72e4      	swap	A
    8152:	7e17      	lod	X, [S-24]
    8154:	52f8      	mov	[X], A

00008156 <.LM133>:
					savedConfig.bluey[5-index] = dataPtr[19] | (dataPtr[18]<<8);
    8156:	7a13      	lod	Y, [S-20]
    8158:	e078      	add	Y, #120
    815a:	5a13      	mov	[S-20], Y
    815c:	7e0f      	lod	X, [S-16]
    815e:	2014      	add	X, #20
    8160:	62f8      	lod	AL, [X]
    8162:	66e0      	lod	YL, AL
    8164:	5cf6      	usex	Y
    8166:	62f9      	lod	AL, [X+1]
    8168:	6800      	lod	AH, #0
    816a:	72e4      	swap	A
    816c:	a6e6      	or	A, Y
    816e:	72e4      	swap	A
    8170:	7e13      	lod	X, [S-20]
    8172:	52f8      	mov	[X], A

00008174 <.LM134>:
					savedConfig.blueY[5-index] = (uint32_t)dataPtr[21] | ((uint32_t)dataPtr[20]<<8) | ((uint32_t)dataPtr[23]<<16) | ((uint32_t)dataPtr[22]<<24);
    8174:	7e19      	lod	X, [S-26]
    8176:	22da 008e 	add	X, #142
    817a:	7a0f      	lod	Y, [S-16]
    817c:	e016      	add	Y, #22
    817e:	62f0      	lod	AL, [Y]
    8180:	5cf2      	usex	A
    8182:	4cc8      	movu	D, A
    8184:	48c7      	asl	D, #8
    8186:	7a0f      	lod	Y, [S-16]
    8188:	e019      	add	Y, #25
    818a:	62f0      	lod	AL, [Y]
    818c:	5cf2      	usex	A
    818e:	4cf2      	usex	YA
    8190:	48ef      	asl	YA, #16
    8192:	58a8      	mov	[S-20], YA
    8194:	4c80      	mov	YA, D
    8196:	a613      	or	A, [S-20]
    8198:	e611      	or	Y, [S-18]
    819a:	4cc0      	mov	D, YA
    819c:	7a0f      	lod	Y, [S-16]
    819e:	e017      	add	Y, #23
    81a0:	62f0      	lod	AL, [Y]
    81a2:	5cf2      	usex	A
    81a4:	4cf2      	usex	YA
    81a6:	58a8      	mov	[S-20], YA
    81a8:	4c80      	mov	YA, D
    81aa:	a613      	or	A, [S-20]
    81ac:	e611      	or	Y, [S-18]
    81ae:	4cc0      	mov	D, YA
    81b0:	7a0f      	lod	Y, [S-16]
    81b2:	e018      	add	Y, #24
    81b4:	62f0      	lod	AL, [Y]
    81b6:	5cf2      	usex	A
    81b8:	4cf2      	usex	YA
    81ba:	48ef      	asl	YA, #16
    81bc:	48e7      	asl	YA, #8
    81be:	58a8      	mov	[S-20], YA
    81c0:	4c80      	mov	YA, D
    81c2:	a613      	or	A, [S-20]
    81c4:	e611      	or	Y, [S-18]
    81c6:	4ca7      	mov	[X], YA
    81c8:	7215      	lod	A, [S-22]
    81ca:	487a 0006 	muls	Y, A, #6
    81ce:	7ee6      	lod	X, Y
    81d0:	22da 14b8 	add	X, #5304
    81d4:	5e17      	mov	[S-24], X
    81d6:	72e6      	lod	A, Y
    81d8:	a2da 1364 	add	A, #4964

000081dc <.LM135>:

					for(ledChannel = 0; ledChannel < 3; ledChannel++)
					{
						savedConfig.LedVoltage_25Celsius.LedVoltage[index].ledChannelData[ledChannel] = currentLedVoltage.LedVoltage[index].ledChannelData[ledChannel];
    81dc:	7ae2      	lod	Y, A
    81de:	e2da 00a4 	add	Y, #164
    81e2:	7ef8      	lod	X, [X]
    81e4:	5ef0      	mov	[Y], X
    81e6:	e002      	add	Y, #2
    81e8:	7e17      	lod	X, [S-24]
    81ea:	7efa      	lod	X, [X+2]
    81ec:	5ef0      	mov	[Y], X
    81ee:	a2da 00a8 	add	A, #168
    81f2:	7e17      	lod	X, [S-24]
    81f4:	7afc      	lod	Y, [X+4]
    81f6:	7ee2      	lod	X, A
    81f8:	5af8      	mov	[X], Y

000081fa <.L59>:
    81fa:	7215      	lod	A, [S-22]
    81fc:	a001      	add	A, #1
    81fe:	5215      	mov	[S-22], A

00008200 <.LM136>:
		{
			uint8_t ledChannel;
			uint8_t ledCalMask, index;
			uint8_t* dataPtr = &Message->data[2];
			ledCalMask = Message->data[0];
			for (index = 0; index < 6; index++)
    8200:	7a1b      	lod	Y, [S-28]
    8202:	e0ff      	add	Y, #-1
    8204:	5a1b      	mov	[S-28], Y
    8206:	1901      	je	0x820a <.LM136+0xa>
    8208:	06f7      	jmp	0x7ff8 <.L60>
    820a:	7000      	lod	A, #0

0000820c <.LVL42>:
    820c:	520f      	mov	[S-16], A

0000820e <.L61>:
    820e:	720f      	lod	A, [S-16]
    8210:	44a2      	asl	A, #2
    8212:	a2da 1364 	add	A, #4964
    8216:	5213      	mov	[S-20], A
    8218:	720f      	lod	A, [S-16]
    821a:	4422      	asl	A
    821c:	7ae2      	lod	Y, A
    821e:	e2da 1364 	add	Y, #4964
    8222:	5a15      	mov	[S-22], Y

00008224 <.LM137>:
				}
			}

			for (index = 0; index < RGBLEDMAX; index++)
			{
				algoUpdateRedCIE(index, savedConfig.redx[index], savedConfig.redy[index], savedConfig.redY[index]);
    8224:	7a13      	lod	Y, [S-20]
    8226:	e01a      	add	Y, #26
    8228:	7ef0      	lod	X, [Y]
    822a:	5edf      	push	X

0000822c <.LCFI8>:
    822c:	7ef2      	lod	X, [Y+2]
    822e:	5edf      	push	X

00008230 <.LCFI9>:
    8230:	7219      	lod	A, [S-26]
    8232:	a00e      	add	A, #14
    8234:	7ae2      	lod	Y, A
    8236:	72f0      	lod	A, [Y]
    8238:	52df      	push	A

0000823a <.LCFI10>:
    823a:	7e1b      	lod	X, [S-28]
    823c:	72fa      	lod	A, [X+2]
    823e:	52df      	push	A

00008240 <.LCFI11>:
    8240:	7217      	lod	A, [S-24]
    8242:	82db 2eab 	callf	0x5d56 <_algoUpdateRedCIE>

00008246 <.LM138>:
				algoUpdateGreenCIE(index, savedConfig.greenx[index], savedConfig.greeny[index], savedConfig.greenY[index]);
    8246:	721b      	lod	A, [S-28]
    8248:	a04a      	add	A, #74
    824a:	7ee2      	lod	X, A
    824c:	7af8      	lod	Y, [X]
    824e:	5adf      	push	Y

00008250 <.LCFI12>:
    8250:	7afa      	lod	Y, [X+2]
    8252:	5adf      	push	Y

00008254 <.LCFI13>:
    8254:	7221      	lod	A, [S-34]
    8256:	a03e      	add	A, #62
    8258:	7ae2      	lod	Y, A
    825a:	72f0      	lod	A, [Y]
    825c:	52df      	push	A

0000825e <.LCFI14>:
    825e:	7223      	lod	A, [S-36]
    8260:	a032      	add	A, #50
    8262:	7ee2      	lod	X, A
    8264:	72f8      	lod	A, [X]
    8266:	52df      	push	A

00008268 <.LCFI15>:
    8268:	721f      	lod	A, [S-32]
    826a:	82db 2ec2 	callf	0x5d84 <_algoUpdateGreenCIE>

0000826e <.LM139>:
				algoUpdateBlueCIE(index, savedConfig.bluex[index], savedConfig.bluey[index], savedConfig.blueY[index]);
    826e:	7e23      	lod	X, [S-36]
    8270:	207a      	add	X, #122
    8272:	72f8      	lod	A, [X]
    8274:	52df      	push	A

00008276 <.LCFI16>:
    8276:	72fa      	lod	A, [X+2]
    8278:	52df      	push	A

0000827a <.LCFI17>:
    827a:	7e29      	lod	X, [S-42]
    827c:	206e      	add	X, #110
    827e:	72f8      	lod	A, [X]
    8280:	52df      	push	A

00008282 <.LCFI18>:
    8282:	7a2b      	lod	Y, [S-44]
    8284:	e062      	add	Y, #98
    8286:	72f0      	lod	A, [Y]
    8288:	52df      	push	A

0000828a <.LCFI19>:
    828a:	7227      	lod	A, [S-40]
    828c:	82db 2ed9 	callf	0x5db2 <_algoUpdateBlueCIE>

00008290 <.LVL58>:
    8290:	7a27      	lod	Y, [S-40]
    8292:	e001      	add	Y, #1
    8294:	5a27      	mov	[S-40], Y

00008296 <.LM140>:
				else
				{
				}
			}

			for (index = 0; index < RGBLEDMAX; index++)
    8296:	5c17      	dec	S, #24

00008298 <.LCFI20>:
    8298:	ec06      	cmp	Y, #6
    829a:	1901      	je	0x829e <.LM141>
    829c:	07b8      	jmp	0x820e <.L61>

0000829e <.LM141>:
				algoUpdateRedCIE(index, savedConfig.redx[index], savedConfig.redy[index], savedConfig.redY[index]);
				algoUpdateGreenCIE(index, savedConfig.greenx[index], savedConfig.greeny[index], savedConfig.greenY[index]);
				algoUpdateBlueCIE(index, savedConfig.bluex[index], savedConfig.bluey[index], savedConfig.blueY[index]);
			}

			if (flashFlag == EFlashUpdateFree)
    829e:	72d8 1362 	lod	A, 0x1362 <_flashFlag>
    82a2:	1901      	je	0x82a6 <.LM142>
    82a4:	009e      	jmp	0x83e2 <.L45>

000082a6 <.LM142>:
				flashFlag |= EFlashUpdateProcessing;
    82a6:	72d8 1362 	lod	A, 0x1362 <_flashFlag>
    82aa:	a401      	or	A, #1
    82ac:	52d8 1362 	mov	0x1362 <_flashFlag>, A
    82b0:	5441      	ret	#66

000082b2 <.L51>:
		break;

		case ECommFunctionRequestCalData:
		{
			uint8_t index;
			uint8_t caldata[30] = {0};
    82b2:	7aef      	lod	Y, S
    82b4:	e0da      	add	Y, #-38
    82b6:	6000      	lod	AL, #0
    82b8:	54e4      	mov	Cx, #4
    82ba:	42d6      	mov	[Y++], AL
    82bc:	1ffe      	djnz	Cx, 0x82ba <.L51+0x8>

000082be <.LM144>:
			uint8_t i = 0;
			index = Message->data[0];
    82be:	7afe      	lod	Y, [X+6]
    82c0:	62f0      	lod	AL, [Y]
    82c2:	66e0      	lod	YL, AL
    82c4:	5cf6      	usex	Y
    82c6:	7ee6      	lod	X, Y

000082c8 <.LM145>:

			caldata[0] = 0x01;
    82c8:	6401      	lod	YL, #1
    82ca:	463f      	mov	[S-64], YL

000082cc <.LM146>:
			caldata[1] = index;
    82cc:	423e      	mov	[S-63], AL

000082ce <.LM147>:
			caldata[2] = savedConfig.redx[5-index];
    82ce:	7005      	lod	A, #5

000082d0 <.LVL63>:
    82d0:	aaee      	sub	A, X
    82d2:	520f      	mov	[S-16], A
    82d4:	4422      	asl	A
    82d6:	7ae2      	lod	Y, A
    82d8:	e2da 1366 	add	Y, #4966
    82dc:	72f0      	lod	A, [Y]
    82de:	423d      	mov	[S-62], AL

000082e0 <.LM148>:
			caldata[3] = savedConfig.redx[5-index]>>8;
    82e0:	4a3c      	mov	[S-61], AH

000082e2 <.LM149>:
			caldata[4] = savedConfig.redy[5-index];
    82e2:	720f      	lod	A, [S-16]
    82e4:	4422      	asl	A
    82e6:	7ae2      	lod	Y, A
    82e8:	e2da 1372 	add	Y, #4978
    82ec:	72f0      	lod	A, [Y]
    82ee:	423b      	mov	[S-60], AL

000082f0 <.LM150>:
			caldata[5] = savedConfig.redy[5-index]>>8;
    82f0:	4a3a      	mov	[S-59], AH

000082f2 <.LM151>:
			caldata[6] = savedConfig.redY[5-index];
    82f2:	720f      	lod	A, [S-16]
    82f4:	44a2      	asl	A, #2
    82f6:	7ee2      	lod	X, A
    82f8:	22da 1364 	add	X, #4964
    82fc:	7aee      	lod	Y, X
    82fe:	e01a      	add	Y, #26
    8300:	72f0      	lod	A, [Y]
    8302:	5207      	mov	[S-8], A
    8304:	72f2      	lod	A, [Y+2]
    8306:	5205      	mov	[S-6], A
    8308:	6607      	lod	YL, [S-8]
    830a:	4639      	mov	[S-58], YL

0000830c <.LM152>:
			caldata[7] = savedConfig.redY[5-index]>>8;
    830c:	58e2      	mov	YA, [S-8]
    830e:	48a7      	lsr	YA, #8
    8310:	58a8      	mov	[S-20], YA
    8312:	4238      	mov	[S-57], AL

00008314 <.LM153>:
			caldata[8] = savedConfig.redY[5-index]>>16;
    8314:	6605      	lod	YL, [S-6]
    8316:	4637      	mov	[S-56], YL

00008318 <.LM154>:
			caldata[9] = savedConfig.redY[5-index]>>24;
    8318:	58e2      	mov	YA, [S-8]
    831a:	48af      	lsr	YA, #16
    831c:	48a7      	lsr	YA, #8
    831e:	4236      	mov	[S-55], AL

00008320 <.LM155>:
			caldata[10] = savedConfig.greenx[5-index];
    8320:	720f      	lod	A, [S-16]
    8322:	4422      	asl	A
    8324:	7ae2      	lod	Y, A
    8326:	e2da 1396 	add	Y, #5014
    832a:	7af0      	lod	Y, [Y]
    832c:	4635      	mov	[S-54], YL

0000832e <.LM156>:
			caldata[11] = savedConfig.greenx[5-index]>>8;
    832e:	4e34      	mov	[S-53], YH

00008330 <.LM157>:
			caldata[12] = savedConfig.greeny[5-index];
    8330:	720f      	lod	A, [S-16]
    8332:	4422      	asl	A
    8334:	7ae2      	lod	Y, A
    8336:	e2da 13a2 	add	Y, #5026
    833a:	7af0      	lod	Y, [Y]
    833c:	4633      	mov	[S-52], YL

0000833e <.LM158>:
			caldata[13] = savedConfig.greeny[5-index]>>8;
    833e:	4e32      	mov	[S-51], YH

00008340 <.LM159>:
			caldata[14] = savedConfig.greenY[5-index];
    8340:	7aee      	lod	Y, X
    8342:	e04a      	add	Y, #74
    8344:	72f0      	lod	A, [Y]
    8346:	5207      	mov	[S-8], A
    8348:	72f2      	lod	A, [Y+2]
    834a:	5205      	mov	[S-6], A
    834c:	6607      	lod	YL, [S-8]
    834e:	4631      	mov	[S-50], YL

00008350 <.LM160>:
			caldata[15] = savedConfig.greenY[5-index]>>8;
    8350:	58e2      	mov	YA, [S-8]
    8352:	48a7      	lsr	YA, #8
    8354:	58a8      	mov	[S-20], YA
    8356:	4230      	mov	[S-49], AL

00008358 <.LM161>:
			caldata[16] = savedConfig.greenY[5-index]>>16;
    8358:	6605      	lod	YL, [S-6]
    835a:	462f      	mov	[S-48], YL

0000835c <.LM162>:
			caldata[17] = savedConfig.greenY[5-index]>>24;
    835c:	58e2      	mov	YA, [S-8]
    835e:	48af      	lsr	YA, #16
    8360:	48a7      	lsr	YA, #8
    8362:	422e      	mov	[S-47], AL

00008364 <.LM163>:
			caldata[18] = savedConfig.bluex[5-index];
    8364:	720f      	lod	A, [S-16]
    8366:	4422      	asl	A
    8368:	7ae2      	lod	Y, A
    836a:	e2da 13c6 	add	Y, #5062
    836e:	7af0      	lod	Y, [Y]
    8370:	462d      	mov	[S-46], YL

00008372 <.LM164>:
			caldata[19] = savedConfig.bluex[5-index]>>8;
    8372:	4e2c      	mov	[S-45], YH

00008374 <.LM165>:
			caldata[20] = savedConfig.bluey[5-index];
    8374:	720f      	lod	A, [S-16]
    8376:	4422      	asl	A
    8378:	7ae2      	lod	Y, A
    837a:	e2da 13d2 	add	Y, #5074
    837e:	72f0      	lod	A, [Y]
    8380:	422b      	mov	[S-44], AL

00008382 <.LM166>:
			caldata[21] = savedConfig.bluey[5-index]>>8;
    8382:	4a2a      	mov	[S-43], AH

00008384 <.LM167>:
			caldata[22] = savedConfig.blueY[5-index];
    8384:	207a      	add	X, #122
    8386:	72f8      	lod	A, [X]
    8388:	5213      	mov	[S-20], A
    838a:	72fa      	lod	A, [X+2]
    838c:	5211      	mov	[S-18], A
    838e:	6613      	lod	YL, [S-20]
    8390:	4629      	mov	[S-42], YL

00008392 <.LM168>:
			caldata[23] = savedConfig.blueY[5-index]>>8;
    8392:	58e8      	mov	YA, [S-20]
    8394:	48a7      	lsr	YA, #8
    8396:	58a6      	mov	[S-16], YA
    8398:	4228      	mov	[S-41], AL

0000839a <.LM169>:
			caldata[24] = savedConfig.blueY[5-index]>>16;
    839a:	6611      	lod	YL, [S-18]
    839c:	4627      	mov	[S-40], YL

0000839e <.LM170>:
			caldata[25] = savedConfig.blueY[5-index]>>24;
    839e:	58e8      	mov	YA, [S-20]
    83a0:	48af      	lsr	YA, #16
    83a2:	48a7      	lsr	YA, #8
    83a4:	4226      	mov	[S-39], AL

000083a6 <.LM171>:

			if(Get_Transmit_Lock() == 0)
    83a6:	82db 372c 	callf	0x6e58 <_Get_Transmit_Lock>

000083aa <.LVL64>:
    83aa:	ac00      	cmp	A, #0
    83ac:	1d16      	jne	0x83da <.L62>
    83ae:	7aef      	lod	Y, S
    83b0:	e0c0      	add	Y, #-64
    83b2:	5a15      	mov	[S-22], Y
    83b4:	7eda 1310 	lod	X, #4880
    83b8:	5e0f      	mov	[S-16], X
    83ba:	7c0f      	lod	X, #15

000083bc <.L63>:
			{
				for(i = 0; i < 15; i++)
				{
					ledCalData[i] = (caldata[i*2]<<8) + caldata[i*2 + 1];
    83bc:	7a15      	lod	Y, [S-22]
    83be:	62f0      	lod	AL, [Y]
    83c0:	6800      	lod	AH, #0
    83c2:	72e4      	swap	A
    83c4:	5213      	mov	[S-20], A
    83c6:	62f1      	lod	AL, [Y+1]
    83c8:	5cf2      	usex	A
    83ca:	a213      	add	A, [S-20]
    83cc:	7a0f      	lod	Y, [S-16]
    83ce:	52d6      	mov	[Y++], A
    83d0:	5a0f      	mov	[S-16], Y
    83d2:	7a15      	lod	Y, [S-22]
    83d4:	e002      	add	Y, #2
    83d6:	5a15      	mov	[S-22], Y

000083d8 <.LM173>:
			caldata[24] = savedConfig.blueY[5-index]>>16;
			caldata[25] = savedConfig.blueY[5-index]>>24;

			if(Get_Transmit_Lock() == 0)
			{
				for(i = 0; i < 15; i++)
    83d8:	1bf1      	djnz	X, 0x83bc <.L63>

000083da <.L62>:
				{
					ledCalData[i] = (caldata[i*2]<<8) + caldata[i*2 + 1];
				}
			}
			//Change the DMA TX pointer to the led calibration data buffer
			IO_SET(PORT_DMA_TX, DMA_TX, (uint16_t)((uint16_t *)&ledCalData[0]));
    83da:	72da 1310 	lod	A, #4880

000083de <.L73>:
		break;

		case ECommFunctionRequestLedStatus:
		{
			//Change the DMA TX pointer to the led status and temperature data buffer
			IO_SET(PORT_DMA_TX, DMA_TX, (uint16_t)((uint16_t *)&systemStatus[0]));
    83de:	52d8 0220 	mov	0x220 <.LASF67+0x9>, A

000083e2 <.L45>:
			break;
		default:
		  break;
	}
#endif
}
    83e2:	5441      	ret	#66

000083e4 <.L52>:
		break;

		case ECommFunctionRequestLedStatus:
		{
			//Change the DMA TX pointer to the led status and temperature data buffer
			IO_SET(PORT_DMA_TX, DMA_TX, (uint16_t)((uint16_t *)&systemStatus[0]));
    83e4:	72da 12f2 	lod	A, #4850
    83e8:	07fa      	jmp	0x83de <.L73>

000083ea <_fw_low_level_init>:
 * @note Current default implementation is empty and can be overwritten by application implementation.
 */
void fw_low_level_init(void)
{
    /* trim area */
    if(nvram_CalcCRC((uint16_t *)EE_TRIM_AREA_START, EE_TRIM_AREA_SIZE>>1) == NVRAM_CORRECT_CRC) {
    83ea:	54ca 001c 	pushw	#28

000083ee <.LCFI0>:
    83ee:	72da 0a00 	lod	A, #2560
    83f2:	82db 1d65 	callf	0x3aca <_nvram_CalcCRC>
    83f6:	5c01      	dec	S, #2

000083f8 <.LCFI1>:
    83f8:	aeda 00ff 	cmp	A, #255
    83fc:	1d38      	jne	0x846e <.L1>

000083fe <.LM3>:
        IO_HOST(TRIM1_LC, LC0_TRIM)=(EE_APP_TRIM23 & 0x0FFF);
    83fe:	7ada 09de 	lod	Y, #2526
    8402:	72f0      	lod	A, [Y]
    8404:	b6da 0fff 	and	A, #4095
    8408:	52d8 022e 	mov	0x22e <.LASF21+0x5>, A

0000840c <.LM4>:
        IO_HOST(TRIM2_LC, LC2_TRIM)=(EE_APP_TRIM24 & 0x0FFF);
    840c:	7ada 09e0 	lod	Y, #2528
    8410:	72f0      	lod	A, [Y]
    8412:	b6da 0fff 	and	A, #4095
    8416:	52d8 0230 	mov	0x230 <.LASF31+0x1>, A

0000841a <.LM5>:
        IO_HOST(TRIM3_LC, LC4_TRIM)=(EE_APP_TRIM25 & 0x0FFF);
    841a:	7ada 09e2 	lod	Y, #2530
    841e:	72f0      	lod	A, [Y]
    8420:	b6da 0fff 	and	A, #4095
    8424:	52d8 0232 	mov	0x232 <.LASF31+0x3>, A

00008428 <.LM6>:
        IO_HOST(TRIM4_LC, LC6_TRIM)=(EE_APP_TRIM26 & 0x0FFF);
    8428:	7ada 09e4 	lod	Y, #2532
    842c:	72f0      	lod	A, [Y]
    842e:	b6da 0fff 	and	A, #4095
    8432:	52d8 0234 	mov	0x234 <.LASF31+0x5>, A

00008436 <.LM7>:
        IO_HOST(TRIM5_LC, LC8_TRIM)=(EE_APP_TRIM27 & 0x0FFF);
    8436:	7ada 09e6 	lod	Y, #2534
    843a:	72f0      	lod	A, [Y]
    843c:	b6da 0fff 	and	A, #4095
    8440:	52d8 0236 	mov	0x236 <.LASF31+0x7>, A

00008444 <.LM8>:
        IO_HOST(TRIM6_LC, LC10_TRIM)=(EE_APP_TRIM28 & 0x0FFF);
    8444:	7ada 09e8 	lod	Y, #2536
    8448:	72f0      	lod	A, [Y]
    844a:	b6da 0fff 	and	A, #4095
    844e:	52d8 0238 	mov	0x238 <.LASF31+0x9>, A

00008452 <.LM9>:
#if defined (__MLX81116xAA__)
        IO_HOST(TRIM_MISC, TR_TAU)=(EE_APP_TRIM29 & 0x1FFF);
#else
        IO_HOST(TRIM_MELIBUS, TR_TAU)=(EE_APP_TRIM22 & 0x1FFF);
    8452:	7ada 09dc 	lod	Y, #2524
    8456:	72f0      	lod	A, [Y]
    8458:	b6da 1fff 	and	A, #8191
    845c:	52d8 0222 	mov	0x222 <.LASF35>, A

00008460 <.LM10>:
        IO_HOST(TRIM_MISC, UNUSED)=(EE_APP_TRIM29 & 0x1FFF);
    8460:	7ada 09ea 	lod	Y, #2538
    8464:	72f0      	lod	A, [Y]
    8466:	b6da 1fff 	and	A, #8191
    846a:	52d8 0244 	mov	0x244 <.LASF20+0x5>, A

0000846e <.L1>:
#endif
    } else {
        /* load default values */
    }
}
    846e:	5401      	ret

00008470 <_fw_premain>:
 * At this point all runtime-initialization is done thus variables/objects
 * get their initial values.
 */
void fw_premain(void)
{
    fw_low_level_init();            /* optionally call more low level initialization */
    8470:	17bc      	call	0x83ea <_fw_low_level_init>

00008472 <.LM14>:

    if (IO_GET(PORT_MISC_IN, RSTAT) == 0u)
    8472:	72d8 01fc 	lod	A, 0x1fc <.LASF71+0x3>
    8476:	b6da 0200 	and	A, #512
    847a:	1d01      	jne	0x847e <.L4>

0000847c <.LM15>:
    {
        /* this is a cold start */
        fw_ram_section_init();      /* RAM initialization */
    847c:	1012      	call	0x84a2 <_fw_ram_section_init>

0000847e <.L4>:
    ac_sel = 0u;
#elif FPLL == 28000
    tmp.u = EE_MS_TRIM7_VALUE;
    ac_sel = 0u;
#elif FPLL == 32000
    tmp.u = EE_MS_TRIM8_VALUE;
    847e:	7ada 0a12 	lod	Y, #2578
    8482:	72f0      	lod	A, [Y]

00008484 <.LM17>:
    ac_sel = 0u;
#else
    #warning "Clock Speed not valid, use 32MHz"
#endif

    SetSystemSpeed(tmp, ac_sel);
    8484:	54ca 0000 	pushw	#0

00008488 <.LCFI2>:
    8488:	82db 1ce7 	callf	0x39ce <_SetSystemSpeed>

0000848c <.LBB11>:
    @param level [0-7]      CPU priority level
 */
static __attribute__((always_inline)) inline
void builtin_mlx16_set_priority (uint8_t level)
{
    __asm__ __volatile__ (
    848c:	54f7      	mov	UPr, #7

0000848e <.LBE11>:
        fw_ram_section_init();      /* RAM initialization */
    }

    set_Clock_Speed();              /* set clock speed */
    builtin_mlx16_set_priority(7);  /* system mode, the lowest priority: 7 */
}
    848e:	5403      	ret	#4

00008490 <_fw_start>:
 *     variables/objects inside this function is FORBIDDEN!
 */
void fw_start(void)
{
    /* Need to run the RAM-test before STACK init */
    SET_STACK(&fw_stack);
    8490:	72da 14dc 	lod	A, #5340
    8494:	52ef      	mov	S, A

00008496 <.LBB4>:
/*
 * Clears M register
 */
STATIC INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    8496:	7000      	lod	A, #0
    8498:	52e3      	mov	M, A

0000849a <.LBE4>:
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    fw_premain();           /* Don't make this functions static to be sure its local variable will not apear before the SP assignment */
    849a:	17ea      	call	0x8470 <_fw_premain>

0000849c <.LM5>:

    __asm__ ("JMP _main\n\t" ::); /* jump to the main function */
    849c:	76da 2ea6 	jmpf	0x5d4c <_main>

000084a0 <.LM6>:
}
    84a0:	5401      	ret

000084a2 <_fw_ram_section_init>:
 * @note Function should NOT be static and/or inlined otherwise space
 * on stack for local variables r and w could be allocated before calling
 * SET_STACK() in start().
 */
void fw_ram_section_init(void)
{
    84a2:	5801      	inc	S, #2

000084a4 <.LCFI0>:
    uint16_t *r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
        *w++ = 0;
    84a4:	72da 1000 	lod	A, #4096
    84a8:	aeda 0fff 	cmp	A, #4095
    84ac:	1c01      	jnc	0x84b0 <.LCFI0+0xc>
    84ae:	003b      	jmp	0x8526 <.L2>
    84b0:	7eda 1001 	lod	X, #4097
    84b4:	2ada 1000 	sub	X, #4096
    84b8:	34fe      	and	X, #-2

000084ba <.L3>:
    84ba:	7ada 1000 	lod	Y, #4096
    84be:	6000      	lod	AL, #0
    84c0:	2c00      	cmp	X, #0
    84c2:	1902      	je	0x84c8 <.L5>

000084c4 <.L4>:
    84c4:	42d6      	mov	[Y++], AL
    84c6:	1bfe      	djnz	X, 0x84c4 <.L4>

000084c8 <.L5>:
    }

    for (w = &_bss_start; w < &_bss_end; ) {
        *w++ = 0;
    84c8:	72da 105d 	lod	A, #4189
    84cc:	aeda 14dc 	cmp	A, #5340
    84d0:	1e2c      	jug	0x852a <.L6>
    84d2:	7eda 14dd 	lod	X, #5341
    84d6:	2ada 105e 	sub	X, #4190
    84da:	34fe      	and	X, #-2

000084dc <.L7>:
    84dc:	7ada 105e 	lod	Y, #4190
    84e0:	6000      	lod	AL, #0
    84e2:	2c00      	cmp	X, #0
    84e4:	1902      	je	0x84ea <.L9>

000084e6 <.L8>:
    84e6:	42d6      	mov	[Y++], AL
    84e8:	1bfe      	djnz	X, 0x84e6 <.L8>

000084ea <.L9>:
    84ea:	7eda 59b0 	lod	X, #22960
    84ee:	7ada 1000 	lod	Y, #4096

000084f2 <.L10>:

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    84f2:	eeda 1000 	cmp	Y, #4096
    84f6:	181b      	jc	0x852e <.L11>

000084f8 <.LM5>:
        *w++ = *r++;
    }

    for (w = &_data_start; w < &_data_end; ) {
        *w++ = *r++;
    84f8:	72da 0fff 	lod	A, #4095
    84fc:	aeda 105e 	cmp	A, #4190
    8500:	1e19      	jug	0x8534 <.L12>
    8502:	72da 105f 	lod	A, #4191
    8506:	aada 1000 	sub	A, #4096
    850a:	b4fe      	and	A, #-2

0000850c <.L13>:
    850c:	7ada 1000 	lod	Y, #4096
    8510:	5a01      	mov	[S-2], Y
    8512:	7aee      	lod	Y, X
    8514:	ac00      	cmp	A, #0
    8516:	1906      	je	0x8524 <.L1>

00008518 <.LVL2>:
    8518:	a2ee      	add	A, X
    851a:	7eda 1000 	lod	X, #4096

0000851e <.L26>:
    851e:	54c6      	movsw	[X++], [Y++]
    8520:	eee2      	cmp	Y, A
    8522:	1d7d      	jne	0x851e <.L26>

00008524 <.L1>:
    }
#endif /* !RAM_APPLICATION */

}
    8524:	5403      	ret	#4

00008526 <.L2>:
    uint16_t *r;
#endif /* !RAM_APPLICATION */

    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
        *w++ = 0;
    8526:	7c00      	lod	X, #0
    8528:	07c8      	jmp	0x84ba <.L3>

0000852a <.L6>:
    }

    for (w = &_bss_start; w < &_bss_end; ) {
        *w++ = 0;
    852a:	7c00      	lod	X, #0
    852c:	07d7      	jmp	0x84dc <.L7>

0000852e <.L11>:
#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
        *w++ = *r++;
    852e:	0ea7      	lod	C, ML.7
    8530:	54ce      	movsw	[Y++], [X++]

00008532 <.LVL6>:
    8532:	07df      	jmp	0x84f2 <.L10>

00008534 <.L12>:
    }

    for (w = &_data_start; w < &_data_end; ) {
        *w++ = *r++;
    8534:	7000      	lod	A, #0
    8536:	07ea      	jmp	0x850c <.L13>

00008538 <__MLX16_EXCHG_INT>:
#define __interrupt__ __attribute__((interrupt, weak))

extern void _fatal (void);

__interrupt__ void _MLX16_EXCHG_INT(void)
{
    8538:	5edf      	push	X

0000853a <.LCFI0>:
    853a:	5adf      	push	Y

0000853c <.LCFI1>:
    853c:	52df      	push	A

0000853e <.LCFI2>:
    853e:	4c83      	push	D

00008540 <.LCFI3>:
    _fatal();
    8540:	82db 1ae0 	callf	0x35c0 <__fatal>

00008544 <.LM3>:
}
    8544:	4cc3      	pop	D

00008546 <.LCFI4>:
    8546:	72cf      	pop	A

00008548 <.LCFI5>:
    8548:	7acf      	pop	Y

0000854a <.LCFI6>:
    854a:	7ecf      	pop	X

0000854c <.LCFI7>:
    854c:	72cb      	pop	M
    854e:	5401      	ret

00008550 <__MLX16_DMAERR_INT>:
    8550:	5edf      	push	X
    8552:	5adf      	push	Y
    8554:	52df      	push	A
    8556:	4c83      	push	D
    8558:	17ef      	call	0x8538 <__MLX16_EXCHG_INT>
    855a:	4cc3      	pop	D
    855c:	72cf      	pop	A
    855e:	7acf      	pop	Y
    8560:	7ecf      	pop	X
    8562:	72cb      	pop	M
    8564:	5401      	ret

00008566 <__AWD_ATT_INT>:
    8566:	5edf      	push	X
    8568:	5adf      	push	Y
    856a:	52df      	push	A
    856c:	4c83      	push	D
    856e:	17e4      	call	0x8538 <__MLX16_EXCHG_INT>
    8570:	4cc3      	pop	D
    8572:	72cf      	pop	A
    8574:	7acf      	pop	Y
    8576:	7ecf      	pop	X
    8578:	72cb      	pop	M
    857a:	5401      	ret

0000857c <__IWD_ATT_INT>:
    857c:	5edf      	push	X
    857e:	5adf      	push	Y
    8580:	52df      	push	A
    8582:	4c83      	push	D
    8584:	17d9      	call	0x8538 <__MLX16_EXCHG_INT>
    8586:	4cc3      	pop	D
    8588:	72cf      	pop	A
    858a:	7acf      	pop	Y
    858c:	7ecf      	pop	X
    858e:	72cb      	pop	M
    8590:	5401      	ret

00008592 <__EE_ECC_INT>:
    8592:	5edf      	push	X
    8594:	5adf      	push	Y
    8596:	52df      	push	A
    8598:	4c83      	push	D
    859a:	17ce      	call	0x8538 <__MLX16_EXCHG_INT>
    859c:	4cc3      	pop	D
    859e:	72cf      	pop	A
    85a0:	7acf      	pop	Y
    85a2:	7ecf      	pop	X
    85a4:	72cb      	pop	M
    85a6:	5401      	ret

000085a8 <__FL_ECC_INT>:
    85a8:	5edf      	push	X
    85aa:	5adf      	push	Y
    85ac:	52df      	push	A
    85ae:	4c83      	push	D
    85b0:	17c3      	call	0x8538 <__MLX16_EXCHG_INT>
    85b2:	4cc3      	pop	D
    85b4:	72cf      	pop	A
    85b6:	7acf      	pop	Y
    85b8:	7ecf      	pop	X
    85ba:	72cb      	pop	M
    85bc:	5401      	ret

000085be <__UV_VDDA_INT>:
    85be:	5edf      	push	X
    85c0:	5adf      	push	Y
    85c2:	52df      	push	A
    85c4:	4c83      	push	D
    85c6:	17b8      	call	0x8538 <__MLX16_EXCHG_INT>
    85c8:	4cc3      	pop	D
    85ca:	72cf      	pop	A
    85cc:	7acf      	pop	Y
    85ce:	7ecf      	pop	X
    85d0:	72cb      	pop	M
    85d2:	5401      	ret

000085d4 <__UV_VS_INT>:
    85d4:	5edf      	push	X
    85d6:	5adf      	push	Y
    85d8:	52df      	push	A
    85da:	4c83      	push	D
    85dc:	17ad      	call	0x8538 <__MLX16_EXCHG_INT>
    85de:	4cc3      	pop	D
    85e0:	72cf      	pop	A
    85e2:	7acf      	pop	Y
    85e4:	7ecf      	pop	X
    85e6:	72cb      	pop	M
    85e8:	5401      	ret

000085ea <__OVT_INT>:
    85ea:	5edf      	push	X
    85ec:	5adf      	push	Y
    85ee:	52df      	push	A
    85f0:	4c83      	push	D
    85f2:	17a2      	call	0x8538 <__MLX16_EXCHG_INT>
    85f4:	4cc3      	pop	D
    85f6:	72cf      	pop	A
    85f8:	7acf      	pop	Y
    85fa:	7ecf      	pop	X
    85fc:	72cb      	pop	M
    85fe:	5401      	ret

00008600 <__STIMER_INT>:
    8600:	5edf      	push	X
    8602:	5adf      	push	Y
    8604:	52df      	push	A
    8606:	4c83      	push	D
    8608:	1797      	call	0x8538 <__MLX16_EXCHG_INT>
    860a:	4cc3      	pop	D
    860c:	72cf      	pop	A
    860e:	7acf      	pop	Y
    8610:	7ecf      	pop	X
    8612:	72cb      	pop	M
    8614:	5401      	ret

00008616 <__CTIMER0_1_INT>:
    8616:	5edf      	push	X
    8618:	5adf      	push	Y
    861a:	52df      	push	A
    861c:	4c83      	push	D
    861e:	178c      	call	0x8538 <__MLX16_EXCHG_INT>
    8620:	4cc3      	pop	D
    8622:	72cf      	pop	A
    8624:	7acf      	pop	Y
    8626:	7ecf      	pop	X
    8628:	72cb      	pop	M
    862a:	5401      	ret

0000862c <__CTIMER0_2_INT>:
    862c:	5edf      	push	X
    862e:	5adf      	push	Y
    8630:	52df      	push	A
    8632:	4c83      	push	D
    8634:	1781      	call	0x8538 <__MLX16_EXCHG_INT>
    8636:	4cc3      	pop	D
    8638:	72cf      	pop	A
    863a:	7acf      	pop	Y
    863c:	7ecf      	pop	X
    863e:	72cb      	pop	M
    8640:	5401      	ret

00008642 <__CTIMER0_3_INT>:
    8642:	5edf      	push	X
    8644:	5adf      	push	Y
    8646:	52df      	push	A
    8648:	4c83      	push	D
    864a:	1776      	call	0x8538 <__MLX16_EXCHG_INT>
    864c:	4cc3      	pop	D
    864e:	72cf      	pop	A
    8650:	7acf      	pop	Y
    8652:	7ecf      	pop	X
    8654:	72cb      	pop	M
    8656:	5401      	ret

00008658 <__CTIMER1_1_INT>:
    8658:	5edf      	push	X
    865a:	5adf      	push	Y
    865c:	52df      	push	A
    865e:	4c83      	push	D
    8660:	176b      	call	0x8538 <__MLX16_EXCHG_INT>
    8662:	4cc3      	pop	D
    8664:	72cf      	pop	A
    8666:	7acf      	pop	Y
    8668:	7ecf      	pop	X
    866a:	72cb      	pop	M
    866c:	5401      	ret

0000866e <__CTIMER1_2_INT>:
    866e:	5edf      	push	X
    8670:	5adf      	push	Y
    8672:	52df      	push	A
    8674:	4c83      	push	D
    8676:	1760      	call	0x8538 <__MLX16_EXCHG_INT>
    8678:	4cc3      	pop	D
    867a:	72cf      	pop	A
    867c:	7acf      	pop	Y
    867e:	7ecf      	pop	X
    8680:	72cb      	pop	M
    8682:	5401      	ret

00008684 <__CTIMER1_3_INT>:
    8684:	5edf      	push	X
    8686:	5adf      	push	Y
    8688:	52df      	push	A
    868a:	4c83      	push	D
    868c:	1755      	call	0x8538 <__MLX16_EXCHG_INT>
    868e:	4cc3      	pop	D
    8690:	72cf      	pop	A
    8692:	7acf      	pop	Y
    8694:	7ecf      	pop	X
    8696:	72cb      	pop	M
    8698:	5401      	ret

0000869a <__PWM_MASTER1_END_INT>:
    869a:	5edf      	push	X
    869c:	5adf      	push	Y
    869e:	52df      	push	A
    86a0:	4c83      	push	D
    86a2:	174a      	call	0x8538 <__MLX16_EXCHG_INT>
    86a4:	4cc3      	pop	D
    86a6:	72cf      	pop	A
    86a8:	7acf      	pop	Y
    86aa:	7ecf      	pop	X
    86ac:	72cb      	pop	M
    86ae:	5401      	ret

000086b0 <__PWM_SLAVE1_CMP_INT>:
    86b0:	5edf      	push	X
    86b2:	5adf      	push	Y
    86b4:	52df      	push	A
    86b6:	4c83      	push	D
    86b8:	173f      	call	0x8538 <__MLX16_EXCHG_INT>
    86ba:	4cc3      	pop	D
    86bc:	72cf      	pop	A
    86be:	7acf      	pop	Y
    86c0:	7ecf      	pop	X
    86c2:	72cb      	pop	M
    86c4:	5401      	ret

000086c6 <__PWM_SLAVE2_CMP_INT>:
    86c6:	5edf      	push	X
    86c8:	5adf      	push	Y
    86ca:	52df      	push	A
    86cc:	4c83      	push	D
    86ce:	1734      	call	0x8538 <__MLX16_EXCHG_INT>
    86d0:	4cc3      	pop	D
    86d2:	72cf      	pop	A
    86d4:	7acf      	pop	Y
    86d6:	7ecf      	pop	X
    86d8:	72cb      	pop	M
    86da:	5401      	ret

000086dc <__PWM_SLAVE3_CMP_INT>:
    86dc:	5edf      	push	X
    86de:	5adf      	push	Y
    86e0:	52df      	push	A
    86e2:	4c83      	push	D
    86e4:	1729      	call	0x8538 <__MLX16_EXCHG_INT>
    86e6:	4cc3      	pop	D
    86e8:	72cf      	pop	A
    86ea:	7acf      	pop	Y
    86ec:	7ecf      	pop	X
    86ee:	72cb      	pop	M
    86f0:	5401      	ret

000086f2 <__PWM_SLAVE4_CMP_INT>:
    86f2:	5edf      	push	X
    86f4:	5adf      	push	Y
    86f6:	52df      	push	A
    86f8:	4c83      	push	D
    86fa:	171e      	call	0x8538 <__MLX16_EXCHG_INT>
    86fc:	4cc3      	pop	D
    86fe:	72cf      	pop	A
    8700:	7acf      	pop	Y
    8702:	7ecf      	pop	X
    8704:	72cb      	pop	M
    8706:	5401      	ret

00008708 <__PWM_SLAVE5_CMP_INT>:
    8708:	5edf      	push	X
    870a:	5adf      	push	Y
    870c:	52df      	push	A
    870e:	4c83      	push	D
    8710:	1713      	call	0x8538 <__MLX16_EXCHG_INT>
    8712:	4cc3      	pop	D
    8714:	72cf      	pop	A
    8716:	7acf      	pop	Y
    8718:	7ecf      	pop	X
    871a:	72cb      	pop	M
    871c:	5401      	ret

0000871e <__PWM_SLAVE6_CMP_INT>:
    871e:	5edf      	push	X
    8720:	5adf      	push	Y
    8722:	52df      	push	A
    8724:	4c83      	push	D
    8726:	1708      	call	0x8538 <__MLX16_EXCHG_INT>
    8728:	4cc3      	pop	D
    872a:	72cf      	pop	A
    872c:	7acf      	pop	Y
    872e:	7ecf      	pop	X
    8730:	72cb      	pop	M
    8732:	5401      	ret

00008734 <__PWM_SLAVE7_CMP_INT>:
    8734:	5edf      	push	X
    8736:	5adf      	push	Y
    8738:	52df      	push	A
    873a:	4c83      	push	D
    873c:	16fd      	call	0x8538 <__MLX16_EXCHG_INT>
    873e:	4cc3      	pop	D
    8740:	72cf      	pop	A
    8742:	7acf      	pop	Y
    8744:	7ecf      	pop	X
    8746:	72cb      	pop	M
    8748:	5401      	ret

0000874a <__PWM_SLAVE8_CMP_INT>:
    874a:	5edf      	push	X
    874c:	5adf      	push	Y
    874e:	52df      	push	A
    8750:	4c83      	push	D
    8752:	16f2      	call	0x8538 <__MLX16_EXCHG_INT>
    8754:	4cc3      	pop	D
    8756:	72cf      	pop	A
    8758:	7acf      	pop	Y
    875a:	7ecf      	pop	X
    875c:	72cb      	pop	M
    875e:	5401      	ret

00008760 <__PWM_SLAVE9_CMP_INT>:
    8760:	5edf      	push	X
    8762:	5adf      	push	Y
    8764:	52df      	push	A
    8766:	4c83      	push	D
    8768:	16e7      	call	0x8538 <__MLX16_EXCHG_INT>
    876a:	4cc3      	pop	D
    876c:	72cf      	pop	A
    876e:	7acf      	pop	Y
    8770:	7ecf      	pop	X
    8772:	72cb      	pop	M
    8774:	5401      	ret

00008776 <__PWM_SLAVE10_CMP_INT>:
    8776:	5edf      	push	X
    8778:	5adf      	push	Y
    877a:	52df      	push	A
    877c:	4c83      	push	D
    877e:	16dc      	call	0x8538 <__MLX16_EXCHG_INT>
    8780:	4cc3      	pop	D
    8782:	72cf      	pop	A
    8784:	7acf      	pop	Y
    8786:	7ecf      	pop	X
    8788:	72cb      	pop	M
    878a:	5401      	ret

0000878c <__PWM_SLAVE11_CMP_INT>:
    878c:	5edf      	push	X
    878e:	5adf      	push	Y
    8790:	52df      	push	A
    8792:	4c83      	push	D
    8794:	16d1      	call	0x8538 <__MLX16_EXCHG_INT>
    8796:	4cc3      	pop	D
    8798:	72cf      	pop	A
    879a:	7acf      	pop	Y
    879c:	7ecf      	pop	X
    879e:	72cb      	pop	M
    87a0:	5401      	ret

000087a2 <__EE_COMPLETE_INT>:
    87a2:	5edf      	push	X
    87a4:	5adf      	push	Y
    87a6:	52df      	push	A
    87a8:	4c83      	push	D
    87aa:	16c6      	call	0x8538 <__MLX16_EXCHG_INT>
    87ac:	4cc3      	pop	D
    87ae:	72cf      	pop	A
    87b0:	7acf      	pop	Y
    87b2:	7ecf      	pop	X
    87b4:	72cb      	pop	M
    87b6:	5401      	ret

000087b8 <__FL_COMPLETE_INT>:
    87b8:	5edf      	push	X
    87ba:	5adf      	push	Y
    87bc:	52df      	push	A
    87be:	4c83      	push	D
    87c0:	16bb      	call	0x8538 <__MLX16_EXCHG_INT>
    87c2:	4cc3      	pop	D
    87c4:	72cf      	pop	A
    87c6:	7acf      	pop	Y
    87c8:	7ecf      	pop	X
    87ca:	72cb      	pop	M
    87cc:	5401      	ret

000087ce <__OV_VS_INT>:
    87ce:	5edf      	push	X
    87d0:	5adf      	push	Y
    87d2:	52df      	push	A
    87d4:	4c83      	push	D
    87d6:	16b0      	call	0x8538 <__MLX16_EXCHG_INT>
    87d8:	4cc3      	pop	D
    87da:	72cf      	pop	A
    87dc:	7acf      	pop	Y
    87de:	7ecf      	pop	X
    87e0:	72cb      	pop	M
    87e2:	5401      	ret

000087e4 <__OVT_WARN_INT>:
    87e4:	5edf      	push	X
    87e6:	5adf      	push	Y
    87e8:	52df      	push	A
    87ea:	4c83      	push	D
    87ec:	16a5      	call	0x8538 <__MLX16_EXCHG_INT>
    87ee:	4cc3      	pop	D
    87f0:	72cf      	pop	A
    87f2:	7acf      	pop	Y
    87f4:	7ecf      	pop	X
    87f6:	72cb      	pop	M
    87f8:	5401      	ret

000087fa <__UV_VDD5_INT>:
    87fa:	5edf      	push	X
    87fc:	5adf      	push	Y
    87fe:	52df      	push	A
    8800:	4c83      	push	D
    8802:	169a      	call	0x8538 <__MLX16_EXCHG_INT>
    8804:	4cc3      	pop	D
    8806:	72cf      	pop	A
    8808:	7acf      	pop	Y
    880a:	7ecf      	pop	X
    880c:	72cb      	pop	M
    880e:	5401      	ret

00008810 <__AA_IN_INT>:
    8810:	5edf      	push	X
    8812:	5adf      	push	Y
    8814:	52df      	push	A
    8816:	4c83      	push	D
    8818:	168f      	call	0x8538 <__MLX16_EXCHG_INT>
    881a:	4cc3      	pop	D
    881c:	72cf      	pop	A
    881e:	7acf      	pop	Y
    8820:	7ecf      	pop	X
    8822:	72cb      	pop	M
    8824:	5401      	ret

00008826 <__UART_SB_INT>:
    8826:	5edf      	push	X
    8828:	5adf      	push	Y
    882a:	52df      	push	A
    882c:	4c83      	push	D
    882e:	1684      	call	0x8538 <__MLX16_EXCHG_INT>
    8830:	4cc3      	pop	D
    8832:	72cf      	pop	A
    8834:	7acf      	pop	Y
    8836:	7ecf      	pop	X
    8838:	72cb      	pop	M
    883a:	5401      	ret

0000883c <__UART_RS_INT>:
    883c:	5edf      	push	X
    883e:	5adf      	push	Y
    8840:	52df      	push	A
    8842:	4c83      	push	D
    8844:	1679      	call	0x8538 <__MLX16_EXCHG_INT>
    8846:	4cc3      	pop	D
    8848:	72cf      	pop	A
    884a:	7acf      	pop	Y
    884c:	7ecf      	pop	X
    884e:	72cb      	pop	M
    8850:	5401      	ret

00008852 <__UART_RR_INT>:
    8852:	5edf      	push	X
    8854:	5adf      	push	Y
    8856:	52df      	push	A
    8858:	4c83      	push	D
    885a:	166e      	call	0x8538 <__MLX16_EXCHG_INT>
    885c:	4cc3      	pop	D
    885e:	72cf      	pop	A
    8860:	7acf      	pop	Y
    8862:	7ecf      	pop	X
    8864:	72cb      	pop	M
    8866:	5401      	ret

00008868 <__UART_TS_INT>:
    8868:	5edf      	push	X
    886a:	5adf      	push	Y
    886c:	52df      	push	A
    886e:	4c83      	push	D
    8870:	1663      	call	0x8538 <__MLX16_EXCHG_INT>
    8872:	4cc3      	pop	D
    8874:	72cf      	pop	A
    8876:	7acf      	pop	Y
    8878:	7ecf      	pop	X
    887a:	72cb      	pop	M
    887c:	5401      	ret

0000887e <__UART_TR_INT>:
    887e:	5edf      	push	X
    8880:	5adf      	push	Y
    8882:	52df      	push	A
    8884:	4c83      	push	D
    8886:	1658      	call	0x8538 <__MLX16_EXCHG_INT>
    8888:	4cc3      	pop	D
    888a:	72cf      	pop	A
    888c:	7acf      	pop	Y
    888e:	7ecf      	pop	X
    8890:	72cb      	pop	M
    8892:	5401      	ret

00008894 <__UART_TE_INT>:
    8894:	5edf      	push	X
    8896:	5adf      	push	Y
    8898:	52df      	push	A
    889a:	4c83      	push	D
    889c:	164d      	call	0x8538 <__MLX16_EXCHG_INT>
    889e:	4cc3      	pop	D
    88a0:	72cf      	pop	A
    88a2:	7acf      	pop	Y
    88a4:	7ecf      	pop	X
    88a6:	72cb      	pop	M
    88a8:	5401      	ret

000088aa <__MLX16_SOFT_INT>:
    88aa:	5edf      	push	X
    88ac:	5adf      	push	Y
    88ae:	52df      	push	A
    88b0:	4c83      	push	D
    88b2:	1642      	call	0x8538 <__MLX16_EXCHG_INT>
    88b4:	4cc3      	pop	D
    88b6:	72cf      	pop	A
    88b8:	7acf      	pop	Y
    88ba:	7ecf      	pop	X
    88bc:	72cb      	pop	M
    88be:	5401      	ret
